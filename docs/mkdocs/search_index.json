{
    "docs": [
        {
            "location": "/home/", 
            "text": "What is OpenVidu?\n\n\n\n\n\n\nOpenVidu is a platform to facilitate the addition of video calls in your web or mobile \napplication, either group or one-to-one calls. In fact, any combination you come up with is easy to implement with OpenVidu.\n\n\nOpenVidu is licensed under \nApache License v2\n.\n\n\n\n\nWhat can I do with OpenVidu?\n\n\nYou can add video-call functionalities to your app, among many other things. The process is really simple: OpenVidu offers all the necessary services and tools. You just need to integrate them in your app to start enjoying its benefits: \n\n\n\n\nOne-to-One, One-to-Many, Many-to-Many calls\n\n\nDecide which user can publish and which can't with predefined roles\n\n\nSend audio + video, audio-only or video-only streams\n\n\nBroadcast text messages\n\n\nMute any track whenever you want\n\n\nShare your screen\n\n\nRecord your videocalls\n\n\n\n\n\nSo, what about adding a video-call center for attending your customers face to face? Or maybe you are developing an application to hold meetings via videoconference. Or you are thinking about teachers streaming to all their students within online lessons, or doctors communicating with their patients with a human touch. The possibilities are endless.\n\n\nYou can check our \nDemos\n to get an idea of what you can do with OpenVidu. Here are some cool pictures of them:\n\n\n\n    \n\n    \n\n    \n\n    \n\n\n\n\n\n\n\nOpenVidu Architecture\n\n\n\n  \n\n\n\n\n\nOpenVidu is divided into two parts:\n\n\n\n\nOpenVidu Browser\n: it is a library to use in your client side (available for JavaScript and TypeScript). It allows you to create video-calls, join users to them, send and receive video and audio, etc... All the actions available with OpenVidu are managed via OpenVidu Browser.\n\n\nOpenVidu Server\n: it is an application that handles the server-side stuff. It receives the operations from OpenVidu Browser and do whatever is necessary to establish and manage your video-calls. You will never have to explicitly use it: just to run it and know its IP address.\n\n\n\n\n\n\nGet started\n\n\nThese are the recommended steps for getting started with OpenVidu:\n\n\n\n\n\n\nThe best way to get your first app working in a few minutes is following our \nOpenVidu Hello Word Tutorial\n.\n\n\n\n\n\n\nAfter that, you can try any of our \nClient-Side-Only\n tutorials, or maybe go straight to step 3 if you think that you already handle OpenVidu reasonably well.\n\n\n\n\n\n\nTry now any of our \nClient-Side + Server-Side\n tutorials, where you can see how a complete web application works with OpenVidu. Choose your preferred framework, since all 4 applications are exactly the same regarding their look and functionality.\n\n\n\n\n\n\nFinally you can \ndeploy your first app\n and see it working in the real world. You can follow our tutorial, where you can deploy our Demos in your own Amazon machine in a few minutes (\nDeploying OpenVidu Demos on AWS\n). Then you can deploy your own app following these steps (\nDeploying OpenVidu Server and your app on AWS\n).\n\n\n\n\n\n\n\n\nHow does OpenVidu work?\n\n\nWebRTC\n is the ultimate responsible for all media transmission at the very heart of OpenVidu. WebRTC is a modern, cross-platform framework that democratizes media transmission over the Internet. It is promoted by Google, Mozilla, Opera and others.\n\n\nKurento\n is the WebRTC framework on which OpenVidu is built. Openvidu was forked from \nKurentoRoom project\n.\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n  \n\n\n\n\n\nWhat are the differences between Kurento and OpenVidu?\n\n\nOpenVidu wraps and hides all the low-level operations. The main goal we pursue is to provide a simple, effective, easy-to-use API so you can forget about WebRTC, ICE candidates and media server tricky stuff. We internally use Kurento to generate, connect, modify and destroy media-pipelines, but OpenVidu simplifies as far as possible the process, focusing on the use-case of video-call sessions (one-to-one, one-to-many, many-to-many, users with different roles).\n\n\nUltimately, developers can create video-calls with just a few lines of code, all from their client-side\n.\n\n\n\n\nAcknowledgments\n\n\nOpenVidu platform has been supported under project LERNIM (RTC-2016-4674-7) confunded by the \nMinistry of Economy, Finance and Competitiveness\n of Spain, as well as by the \nEuropean Union\n FEDER, whose main goal with this funds is to promote technological development, innovation and high-quality research.\n\n\n\n  \n\n  \n\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery-wellcome\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });\n\n\n\n\n\n\n\n\n\n\n    $('.docs-gallery').slick({\n      autoplay: true,\n      autoplaySpeed: 4000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "What is OpenVidu?"
        }, 
        {
            "location": "/home/#what-can-i-do-with-openvidu", 
            "text": "You can add video-call functionalities to your app, among many other things. The process is really simple: OpenVidu offers all the necessary services and tools. You just need to integrate them in your app to start enjoying its benefits:    One-to-One, One-to-Many, Many-to-Many calls  Decide which user can publish and which can't with predefined roles  Send audio + video, audio-only or video-only streams  Broadcast text messages  Mute any track whenever you want  Share your screen  Record your videocalls   \nSo, what about adding a video-call center for attending your customers face to face? Or maybe you are developing an application to hold meetings via videoconference. Or you are thinking about teachers streaming to all their students within online lessons, or doctors communicating with their patients with a human touch. The possibilities are endless.  You can check our  Demos  to get an idea of what you can do with OpenVidu. Here are some cool pictures of them:", 
            "title": "What can I do with OpenVidu?"
        }, 
        {
            "location": "/home/#openvidu-architecture", 
            "text": "OpenVidu is divided into two parts:   OpenVidu Browser : it is a library to use in your client side (available for JavaScript and TypeScript). It allows you to create video-calls, join users to them, send and receive video and audio, etc... All the actions available with OpenVidu are managed via OpenVidu Browser.  OpenVidu Server : it is an application that handles the server-side stuff. It receives the operations from OpenVidu Browser and do whatever is necessary to establish and manage your video-calls. You will never have to explicitly use it: just to run it and know its IP address.", 
            "title": "OpenVidu Architecture"
        }, 
        {
            "location": "/home/#get-started", 
            "text": "These are the recommended steps for getting started with OpenVidu:    The best way to get your first app working in a few minutes is following our  OpenVidu Hello Word Tutorial .    After that, you can try any of our  Client-Side-Only  tutorials, or maybe go straight to step 3 if you think that you already handle OpenVidu reasonably well.    Try now any of our  Client-Side + Server-Side  tutorials, where you can see how a complete web application works with OpenVidu. Choose your preferred framework, since all 4 applications are exactly the same regarding their look and functionality.    Finally you can  deploy your first app  and see it working in the real world. You can follow our tutorial, where you can deploy our Demos in your own Amazon machine in a few minutes ( Deploying OpenVidu Demos on AWS ). Then you can deploy your own app following these steps ( Deploying OpenVidu Server and your app on AWS ).", 
            "title": "Get started"
        }, 
        {
            "location": "/home/#how-does-openvidu-work", 
            "text": "WebRTC  is the ultimate responsible for all media transmission at the very heart of OpenVidu. WebRTC is a modern, cross-platform framework that democratizes media transmission over the Internet. It is promoted by Google, Mozilla, Opera and others.  Kurento  is the WebRTC framework on which OpenVidu is built. Openvidu was forked from  KurentoRoom project .  \n   \n     \n   \n   \n     \n     What are the differences between Kurento and OpenVidu?  OpenVidu wraps and hides all the low-level operations. The main goal we pursue is to provide a simple, effective, easy-to-use API so you can forget about WebRTC, ICE candidates and media server tricky stuff. We internally use Kurento to generate, connect, modify and destroy media-pipelines, but OpenVidu simplifies as far as possible the process, focusing on the use-case of video-call sessions (one-to-one, one-to-many, many-to-many, users with different roles).  Ultimately, developers can create video-calls with just a few lines of code, all from their client-side .", 
            "title": "How does OpenVidu work?"
        }, 
        {
            "location": "/home/#acknowledgments", 
            "text": "OpenVidu platform has been supported under project LERNIM (RTC-2016-4674-7) confunded by the  Ministry of Economy, Finance and Competitiveness  of Spain, as well as by the  European Union  FEDER, whose main goal with this funds is to promote technological development, innovation and high-quality research.  \n   \n       \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery-wellcome\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });     \n    $('.docs-gallery').slick({\n      autoplay: true,\n      autoplaySpeed: 4000,\n      dots: true,\n      infinite: true,\n      pauseOnHover: false,\n      pauseOnFocus: false,\n      responsive: [\n      {\n        breakpoint: 768,\n        settings: {\n          arrows: false,\n          slidesToShow: 1\n        }\n      },\n    ]\n    });", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/tutorials/", 
            "text": "OpenVidu Tutorials\n\n\n\n\n\n\n\n\n\n\n    \n\n\n        \n\n            \nHello World\n\n            \nMake your first video-call with just a few lines of code\n\n        \n\n\n        \n\n            \n\n            \n\n                \n\n                    \n\n                        \nGo!\n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n            \n\n            \n\n        \n\n\n        \n\n\n        \n\n            \nClient Side only \n\n            \nGet quickly started without worrying about a server-side\n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript\n\n                    \nVanilla JavaScript app: good old JS code for a traditional approach.\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nAngular\n\n                    \nTry this fantastic tutorial using the last version of Angular framework.\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \nComing soon...\n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nIonic\n\n                    \nThis Ionic app will get you going in the blink of an eye\n\n                \n\n            \n\n\n        \n\n        \n\n\n        \n\n            \n\n            \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \nOpenVidu\n is present on both client-side and server-side, but the \napplication\n is only present on client-side.\n\n                        \nSince these are client-side-only applications, you will be dealing only with \nfrontend technologies\n: HTML, CSS, Javascript / Typescript ...\n\n                        \nThe main difference compared to Client Side + Server Side tutorials is that here you don't have real control over your users: your\n                            \nvideo-calls won't be secure\n beacuse you cannot identify them and cannot determine if allow or deny their access.\n\n                    \n\n                \n\n            \n\n        \n\n\n        \n\n\n        \n\n            \nClient Side + Server Side \n\n            \nTry any of our ready-for-production web apps to see OpenVidu in action with a real example\n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Java SPA\n\n                    \nVanilla JavasCript frontend and a SPA Java Backend: forget building HTML templates, just feed your\n                        front with HTTP requests\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Java MVC\n\n                    \nVanilla JavasCript frontend and a traditional Java MVC Backend: serve HTML pages from your server\n\n                \n\n            \n\n\n        \n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Node SPA\n\n                    \nVanilla JavasCript frontend and a SPA Node Backend: forget building HTML templates, just feed your\n                        front with HTTP requests\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Node MVC\n\n                    \nVanilla JavasCript frontend and a traditional Node MVC backend: serve HTML pages from your server\n\n                \n\n            \n\n\n        \n\n\n        \n\n            \n\n            \n\n                \n\n                    \n\n                        \n\n                    \n\n                    \n\n                        \nOpenVidu\n and the \napplication\n are present on both client-side and server-side.\n\n                        \nSince these are full web applications, you will be dealing with \nfrontend technologies\n (HTML, CSS, Javascript / Typescript ...) \n                            but also with \nbackend technologies\n (Java / Node)\n\n                        \nThe main difference compared to Client Side Only tutorials is that here you have total control over your users: your \n                            \nvideo-calls are secure\n beacuse you can identify them and allow or deny their access.", 
            "title": "Intro"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/", 
            "text": "openvidu-hello-world\n\n\n Check it on GitHub\n\n\nThis is the simplest demo you can try to get started with OpenVidu: HTML code is only about 30 lines and the JavaScript code not even 50, but it has the minimum set of features to make a group video-call. You will only need a few minutes to get your first application working!\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need an http web server installed in your development computer to execute the tutorial. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n3) Run the tutorial:\n\n\nhttp-server openvidu-tutorials/openvidu-hello-world/web\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nlocalhost:8080\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nopenvidu-browser-VERSION.js\n: openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n: sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n.\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\nindex.html\n: HTML code for the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files: \n\n\n\n\n\n  \nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\nLet's see how \napp.js\n uses \nopenvidu-browser-VERSION.js\n:\n\n\n\n\nFirst lines declare the two variables that will be needed in different points along the code. \nOV\n will be our OpenVidu object and \nsession\n the video-call we will connect to:\n\n\nvar OV;\nvar session;\n\n\n\n\n\n\nInitialize a new session and its events:\n\n\nOV = new OpenVidu();\nsession = OV.initSession(\nwss://\n + location.hostname + \n:8443/\n + sessionId + '?secret=MY_SECRET');\n\nsession.on('streamCreated', function (event) {\n  session.subscribe(event.stream, 'subscriber');\n});\n\n\n\n\nAs you can see in the code, the process is very simple: get an OpenVidu object for initializing a Session object with it. \ninitSession\n method must recieve a string with the following format: \n\n\n\"wss://\"\n + \nOPENVIDU_IP\n + \n\":8443/\"\n + \nSESSION_ID\n + \n\"?secret=\"\n + \nOPENVIDU_SECRET\n\n\n\n\n\nOPENVIDU_IP\n  is the IP where your OpenVidu Server is running. In this case, it will be \nlocalhost\n.\n\n\nSESSION_ID\n is the unique identifier of your session. This parameter will determine which session you are connecting to: in this case, we get this from the HTML text input, where the user can type whatever he wants.\n\n\nOPENVIDU_SECRET\n is the same secret as used to initialize you OpenVidu Server (check param \nopenvidu.secret\n in step 4 of \nRunning this tutorial\n).\n\n\n\n\n\n\nThis parameter building process for \ninitrSession\n method is only necessary when your app has no server-side. Obviously in a production environment appending your secret is not recommended. Check \nthis FAQ\n to learn more.\n\n\n\n\nThen you can subscribe to all the events you want for your session. In this case we just want to subscribe to every stream that is being created in the session: on \nstreamCreated\n we subscribe to the specific stream, available at \nevent.stream\n property.\n\n\n\n\nYou can take a look at all the events in the \nReference Documentation\n\n\n\n\n\n\nConnect to the session and publish your webcam:\n\n\nsession.connect(null, function (error) {\n\n  if (!error) {\n    var publisher = OV.initPublisher('publisher');\n    session.publish(publisher);\n  } else {\n    console.log('There was an error connecting to the session:', error.code, error.message);\n  }\n\n});\n\n\n\n\nWe simply need to call \nsession.connect\n method providing a callback to execute when the operation is completed. First parameter \nnull\n is now irrelevant because we have no server-side (check the \nFAQ\n).\n\n\nThe only parameter received by our callback is \nerror\n object, which will be undefined if everything has gone well. To publish our webcam to the session we just get a \npublisher\n (thanks to \nOpenVidu.initPublisher\n method), and a new HTML video showing our webcam will be appended to the page inside element with id \npublisher\n.\n\n\nLast but not least, we publish this \npublisher\n object thanks to \nsession.publish\n. At this point the rest of users connected to this session will trigger their own \nstreamCreated\n event and can start watching our webcam.\n\n\n\n\nLeaving the session:\n\n\nsession.disconnect();\n\n\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method. Here it will be called inside \nleaveSession\n function, triggered when the user clicks on \"LEAVE\" button.", 
            "title": "openvidu-hello-world"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#openvidu-hello-world", 
            "text": "Check it on GitHub  This is the simplest demo you can try to get started with OpenVidu: HTML code is only about 30 lines and the JavaScript code not even 50, but it has the minimum set of features to make a group video-call. You will only need a few minutes to get your first application working!", 
            "title": "openvidu-hello-world"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need an http web server installed in your development computer to execute the tutorial. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server  3) Run the tutorial:  http-server openvidu-tutorials/openvidu-hello-world/web  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  localhost:8080  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file.   app.js : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js .  style.css : some CSS classes to style  index.html .  index.html : HTML code for the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:    \n   script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script   Let's see how  app.js  uses  openvidu-browser-VERSION.js :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#first-lines-declare-the-two-variables-that-will-be-needed-in-different-points-along-the-code-ov-will-be-our-openvidu-object-and-session-the-video-call-we-will-connect-to", 
            "text": "var OV;\nvar session;", 
            "title": "First lines declare the two variables that will be needed in different points along the code. OV will be our OpenVidu object and session the video-call we will connect to:"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#initialize-a-new-session-and-its-events", 
            "text": "OV = new OpenVidu();\nsession = OV.initSession( wss://  + location.hostname +  :8443/  + sessionId + '?secret=MY_SECRET');\n\nsession.on('streamCreated', function (event) {\n  session.subscribe(event.stream, 'subscriber');\n});  As you can see in the code, the process is very simple: get an OpenVidu object for initializing a Session object with it.  initSession  method must recieve a string with the following format:   \"wss://\"  +  OPENVIDU_IP  +  \":8443/\"  +  SESSION_ID  +  \"?secret=\"  +  OPENVIDU_SECRET   OPENVIDU_IP   is the IP where your OpenVidu Server is running. In this case, it will be  localhost .  SESSION_ID  is the unique identifier of your session. This parameter will determine which session you are connecting to: in this case, we get this from the HTML text input, where the user can type whatever he wants.  OPENVIDU_SECRET  is the same secret as used to initialize you OpenVidu Server (check param  openvidu.secret  in step 4 of  Running this tutorial ).    This parameter building process for  initrSession  method is only necessary when your app has no server-side. Obviously in a production environment appending your secret is not recommended. Check  this FAQ  to learn more.   Then you can subscribe to all the events you want for your session. In this case we just want to subscribe to every stream that is being created in the session: on  streamCreated  we subscribe to the specific stream, available at  event.stream  property.   You can take a look at all the events in the  Reference Documentation", 
            "title": "Initialize a new session and its events:"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#connect-to-the-session-and-publish-your-webcam", 
            "text": "session.connect(null, function (error) {\n\n  if (!error) {\n    var publisher = OV.initPublisher('publisher');\n    session.publish(publisher);\n  } else {\n    console.log('There was an error connecting to the session:', error.code, error.message);\n  }\n\n});  We simply need to call  session.connect  method providing a callback to execute when the operation is completed. First parameter  null  is now irrelevant because we have no server-side (check the  FAQ ).  The only parameter received by our callback is  error  object, which will be undefined if everything has gone well. To publish our webcam to the session we just get a  publisher  (thanks to  OpenVidu.initPublisher  method), and a new HTML video showing our webcam will be appended to the page inside element with id  publisher .  Last but not least, we publish this  publisher  object thanks to  session.publish . At this point the rest of users connected to this session will trigger their own  streamCreated  event and can start watching our webcam.", 
            "title": "Connect to the session and publish your webcam:"
        }, 
        {
            "location": "/tutorials/openvidu-hello-world/#leaving-the-session", 
            "text": "session.disconnect();  Whenever we want a user to leave the session, we just need to call  session.disconnect  method. Here it will be called inside  leaveSession  function, triggered when the user clicks on \"LEAVE\" button.", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/", 
            "text": "openvidu-insecure-js\n\n\n Check it on GitHub\n\n\nA client-side only application built with JavaScript, HTML and CSS.\n\n\nIf it is the first time you use OpenVidu, it is higly recommended to start with \nopenvidu-hello-world\n tutorial, as this app is no more than an extension of it with some new features and sytles.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flows transmission\n\n\n\n\n\n    \n\n\n\n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.\n\n\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need an http web server installed in your development computer to execute the sample application. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n3) Run the tutorial:\n\n\nhttp-server openvidu-tutorials/openvidu-insecure-js/web\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nlocalhost:8080\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nopenvidu-browser-VERSION.js\n: openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n: sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n. You can manipulate this file to suit your needs.\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n. You can manipulate this file to suit your needs.\n\n\nindex.html\n: HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: \n\n\n\n\n\n    \nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\nLet's see how \napp.js\n uses \nopenvidu-browser-VERSION.js\n:\n\n\n\n\nFirst lines declare the two variables that will be needed in different points along the code. \nOV\n will be our OpenVidu object and \nsession\n the video-call we will connect to:\n\n\nvar OV;\nvar session;\n\n\n\n\n\n\nLet's initialize a new session and configure our events:\n\n\n// --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// Init OpenVidu object\nOV = new OpenVidu();\n\n// We will join the video-call \nsessionId\n. As there's no server, this parameter must start with the URL of\n// OpenVidu Server (with secure websocket protocol: \nwss://\n) and must include the OpenVidu secret at the end\nsession = OV.initSession(\nwss://\n + location.hostname + \n:8443/\n + sessionId + '?secret=MY_SECRET');\n\n\n\n\nSession's identifiers must begin with the URL where \nopenvidu-server\n listens, so they can connect through WebSocket to it. It is necessary to explicitly set this URL in the param when using a pure frontend web. Since we are in a local sample app, \nOV.initSession\n will finally receive \nwss://localhost:8443/\n as its \nopenvidu-server\n URL. \nsessionId\n is the distinctive portion of the session identifier and allows OpenVidu to differentiate sessions from each other. In this case, this parameter is retrieved from HTML input \ninput class=\"form-control\" type=\"text\" id=\"sessionId\" required\n, which may be filled by the user. Finally, \n'?secret=MY_SECRET'\n string allows us to connect to OpenVidu directly from the browser, without a server side. \n\n\n\n    \n\n\n\n    \nWARNING\n: this is only for demos and developing environments. Do NOT include your secret in production. Check this \nFAQ\n to learn more.\n\n\n\n\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it. HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new \np\n element for the user's nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n\n    // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM\n    removeUserData(event.stream.connection);\n});\n\n\n\n\nHere we subscribe to the events that interest us. In this case, we want to receive all videos published to the video-call, as well as displaying every user's nickname next to its video. To achieve this:\n\n\n\n\n\n\nstreamCreated\n: for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'video-container'. \n\n\n\n\n\n\nvideoElementCreated\n: event triggered by Subscriber object (returned by the previous \nSession.subscribe\n method). This allows us to add the participant nickname to the new video previously added in \nstreamCreated\n event. Auxiliary method \nappendUserData\n is responsible for appending a new paragraph element just below the \nevent.element\n video, containing \nsubscriber.stream.connection.data\n field. In this case, this field contains the user's nickName. You can see how to feed this property from the client in the next step.\n\n\n\n\n\n\nstreamDestroyed\n: for each Stream that has been destroyed (which means a user has left the video-call), we remove the element with the user's nickname that we added in the previous event with the auxiliary method \nremoveUserData\n (\nappendUserData\n method created the element with an \nid\n containing \nevent.stream.connection.connectionId\n unique value, so we can now identify the right element to be removed). OpenVidu automatically deletes the proper video element by default, so we don't need to do anything else.\n\n\n\n\n\n\n\n\nCheck \nApplication specific methods\n section to see all the auxiliary methods used in this app\n\n\n\n\n\n\nFinally connect to the session and publish your webcam:\n\n\n// --- 3) Connect to the session ---\n\n    // First param irrelevant if your app has no server-side. Second param will be received by every user\n    // in Stream.connection.data property, which will be appended to DOM as the user's nickname\n    session.connect(null, '{\nclientData\n: \n' + userName + '\n}', function (error) {\n\n        // If the connection is successful, initialize a publisher and publish to the session\n        if (!error) {\n\n            // --- 4) Get your own camera stream with the desired resolution ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                initMainVideo(event.element, userName);\n                appendUserData(event.element, userName);\n                event.element['muted']  = true;\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        }\n    });\n\n\n\n\nIn \nsession.connect\n method: first param is irrelevant when you don't have a backend (it is the user's token). Remember \nvideoElementCreated\n event, when we added the user's nickname to the HTML? Well, second parameter is the actual value you will receive in \nStream.connection.data\n property. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input \ninput type=\"text\" id=\"participantId\" required\n (filled by the user and also reused for the first \ntoken\n param).\n\n\nIn the callback of \nSession.connect\n method, we check the connection has been succesful (\nerror\n value must be \nnull\n) and right after that we get a \nPublisher\n object with both audio and video activated and MEDIUM quality. This process will end with the addition of a new HTML video element showing your camera, as a child of element with \nid\n 'video-container'. Event \nvideoElementCreated\n will be fired by the Publisher object just after this video is added to DOM, so we can subscribe to it and do whatever we want with it. In this case, we init a big video element with our video and append our nickname to it, by using auxiliary methods \ninitMainVideo\n and \nappendUserData\n.\n\n\nFinally we just have to publish \npublisher\n object through \nSession.publish\n method, and the rest of users will begin receiving our webcam.\n\n\n\n\nLeaving the session:\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method:\n\n\nfunction leaveSession() {\n\n    // --- 6) Leave the session by calling 'disconnect' method over the Session object ---\n\n    session.disconnect();\n\n    // Removing all HTML elements with the user's nicknames. \n    // HTML videos are automatically removed when leaving a Session\n    removeAllUserData();\n\n    // Back to 'Join session' page\n    document.getElementById('join').style.display = 'block';\n    document.getElementById('session').style.display = 'none';\n}\n\n\n\n\n\n\nApplication specific methods\n\n\nHere you have all the auxiliary methods used in this app, which are not directly related to OpenVidu:\n\n\n/* APPLICATION SPECIFIC METHODS */\n\nwindow.addEventListener('load', function () {\n    generateParticipantInfo();\n});\n\nwindow.onbeforeunload = function () {\n    if (session) session.disconnect();\n};\n\nfunction generateParticipantInfo() {\n    document.getElementById(\nsessionId\n).value = \nSessionA\n;\n    document.getElementById(\nuserName\n).value = \nParticipant\n + Math.floor(Math.random() * 100);\n}\n\nfunction appendUserData(videoElement, connection) {\n    var userData;\n    var nodeId;\n    if (typeof connection === \nstring\n) {\n        userData = connection;\n        nodeId = connection;\n    } else {\n        userData = JSON.parse(connection.data).clientData;\n        nodeId = connection.connectionId;\n    }\n    var dataNode = document.createElement('div');\n    dataNode.className = \ndata-node\n;\n    dataNode.id = \ndata-\n + nodeId;\n    dataNode.innerHTML = \np\n + userData + \n/p\n;\n    videoElement.parentNode.insertBefore(dataNode, videoElement.nextSibling);\n    addClickListener(videoElement, userData);\n}\n\nfunction removeUserData(connection) {\n    var dataNode = document.getElementById(\ndata-\n + connection.connectionId);\n    dataNode.parentNode.removeChild(dataNode);\n}\n\nfunction removeAllUserData() {\n    var nicknameElements = document.getElementsByClassName('data-node');\n    while (nicknameElements[0]) {\n        nicknameElements[0].parentNode.removeChild(nicknameElements[0]);\n    }\n}\n\nfunction addClickListener(videoElement, userData) {\n    videoElement.addEventListener('click', function () {\n        var mainVideo = document.querySelector('#main-video video');\n        var mainUserData = document.querySelector('#main-video p');\n        if (mainVideo.srcObject !== videoElement.srcObject) {\n            mainUserData.innerHTML = userData;\n            mainVideo.srcObject = videoElement.srcObject;\n        }\n    });\n}\n\nfunction initMainVideo(videoElement, userData) {\n    document.querySelector('#main-video video').srcObject = videoElement.srcObject;\n    document.querySelector('#main-video p').innerHTML = userData;\n    document.querySelector('#main-video video')['muted'] = true;\n}\n\n/* APPLICATION SPECIFIC METHODS */\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-insecure-js"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#openvidu-insecure-js", 
            "text": "Check it on GitHub  A client-side only application built with JavaScript, HTML and CSS.  If it is the first time you use OpenVidu, it is higly recommended to start with  openvidu-hello-world  tutorial, as this app is no more than an extension of it with some new features and sytles.", 
            "title": "openvidu-insecure-js"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flows transmission   \n      \n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need an http web server installed in your development computer to execute the sample application. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server  3) Run the tutorial:  http-server openvidu-tutorials/openvidu-insecure-js/web  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  localhost:8080  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file.   app.js : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js . You can manipulate this file to suit your needs.  style.css : some CSS classes to style  index.html . You can manipulate this file to suit your needs.  index.html : HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files:    \n     script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script   Let's see how  app.js  uses  openvidu-browser-VERSION.js :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#first-lines-declare-the-two-variables-that-will-be-needed-in-different-points-along-the-code-ov-will-be-our-openvidu-object-and-session-the-video-call-we-will-connect-to", 
            "text": "var OV;\nvar session;", 
            "title": "First lines declare the two variables that will be needed in different points along the code. OV will be our OpenVidu object and session the video-call we will connect to:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#lets-initialize-a-new-session-and-configure-our-events", 
            "text": "// --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// Init OpenVidu object\nOV = new OpenVidu();\n\n// We will join the video-call  sessionId . As there's no server, this parameter must start with the URL of\n// OpenVidu Server (with secure websocket protocol:  wss:// ) and must include the OpenVidu secret at the end\nsession = OV.initSession( wss://  + location.hostname +  :8443/  + sessionId + '?secret=MY_SECRET');  Session's identifiers must begin with the URL where  openvidu-server  listens, so they can connect through WebSocket to it. It is necessary to explicitly set this URL in the param when using a pure frontend web. Since we are in a local sample app,  OV.initSession  will finally receive  wss://localhost:8443/  as its  openvidu-server  URL.  sessionId  is the distinctive portion of the session identifier and allows OpenVidu to differentiate sessions from each other. In this case, this parameter is retrieved from HTML input  input class=\"form-control\" type=\"text\" id=\"sessionId\" required , which may be filled by the user. Finally,  '?secret=MY_SECRET'  string allows us to connect to OpenVidu directly from the browser, without a server side.   \n      \n     WARNING : this is only for demos and developing environments. Do NOT include your secret in production. Check this  FAQ  to learn more.   // --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it. HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new  p  element for the user's nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n\n    // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM\n    removeUserData(event.stream.connection);\n});  Here we subscribe to the events that interest us. In this case, we want to receive all videos published to the video-call, as well as displaying every user's nickname next to its video. To achieve this:    streamCreated : for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'video-container'.     videoElementCreated : event triggered by Subscriber object (returned by the previous  Session.subscribe  method). This allows us to add the participant nickname to the new video previously added in  streamCreated  event. Auxiliary method  appendUserData  is responsible for appending a new paragraph element just below the  event.element  video, containing  subscriber.stream.connection.data  field. In this case, this field contains the user's nickName. You can see how to feed this property from the client in the next step.    streamDestroyed : for each Stream that has been destroyed (which means a user has left the video-call), we remove the element with the user's nickname that we added in the previous event with the auxiliary method  removeUserData  ( appendUserData  method created the element with an  id  containing  event.stream.connection.connectionId  unique value, so we can now identify the right element to be removed). OpenVidu automatically deletes the proper video element by default, so we don't need to do anything else.     Check  Application specific methods  section to see all the auxiliary methods used in this app", 
            "title": "Let's initialize a new session and configure our events:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#finally-connect-to-the-session-and-publish-your-webcam", 
            "text": "// --- 3) Connect to the session ---\n\n    // First param irrelevant if your app has no server-side. Second param will be received by every user\n    // in Stream.connection.data property, which will be appended to DOM as the user's nickname\n    session.connect(null, '{ clientData :  ' + userName + ' }', function (error) {\n\n        // If the connection is successful, initialize a publisher and publish to the session\n        if (!error) {\n\n            // --- 4) Get your own camera stream with the desired resolution ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                initMainVideo(event.element, userName);\n                appendUserData(event.element, userName);\n                event.element['muted']  = true;\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        }\n    });  In  session.connect  method: first param is irrelevant when you don't have a backend (it is the user's token). Remember  videoElementCreated  event, when we added the user's nickname to the HTML? Well, second parameter is the actual value you will receive in  Stream.connection.data  property. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input  input type=\"text\" id=\"participantId\" required  (filled by the user and also reused for the first  token  param).  In the callback of  Session.connect  method, we check the connection has been succesful ( error  value must be  null ) and right after that we get a  Publisher  object with both audio and video activated and MEDIUM quality. This process will end with the addition of a new HTML video element showing your camera, as a child of element with  id  'video-container'. Event  videoElementCreated  will be fired by the Publisher object just after this video is added to DOM, so we can subscribe to it and do whatever we want with it. In this case, we init a big video element with our video and append our nickname to it, by using auxiliary methods  initMainVideo  and  appendUserData .  Finally we just have to publish  publisher  object through  Session.publish  method, and the rest of users will begin receiving our webcam.", 
            "title": "Finally connect to the session and publish your webcam:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#leaving-the-session", 
            "text": "Whenever we want a user to leave the session, we just need to call  session.disconnect  method:  function leaveSession() {\n\n    // --- 6) Leave the session by calling 'disconnect' method over the Session object ---\n\n    session.disconnect();\n\n    // Removing all HTML elements with the user's nicknames. \n    // HTML videos are automatically removed when leaving a Session\n    removeAllUserData();\n\n    // Back to 'Join session' page\n    document.getElementById('join').style.display = 'block';\n    document.getElementById('session').style.display = 'none';\n}", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#application-specific-methods", 
            "text": "Here you have all the auxiliary methods used in this app, which are not directly related to OpenVidu:  /* APPLICATION SPECIFIC METHODS */\n\nwindow.addEventListener('load', function () {\n    generateParticipantInfo();\n});\n\nwindow.onbeforeunload = function () {\n    if (session) session.disconnect();\n};\n\nfunction generateParticipantInfo() {\n    document.getElementById( sessionId ).value =  SessionA ;\n    document.getElementById( userName ).value =  Participant  + Math.floor(Math.random() * 100);\n}\n\nfunction appendUserData(videoElement, connection) {\n    var userData;\n    var nodeId;\n    if (typeof connection ===  string ) {\n        userData = connection;\n        nodeId = connection;\n    } else {\n        userData = JSON.parse(connection.data).clientData;\n        nodeId = connection.connectionId;\n    }\n    var dataNode = document.createElement('div');\n    dataNode.className =  data-node ;\n    dataNode.id =  data-  + nodeId;\n    dataNode.innerHTML =  p  + userData +  /p ;\n    videoElement.parentNode.insertBefore(dataNode, videoElement.nextSibling);\n    addClickListener(videoElement, userData);\n}\n\nfunction removeUserData(connection) {\n    var dataNode = document.getElementById( data-  + connection.connectionId);\n    dataNode.parentNode.removeChild(dataNode);\n}\n\nfunction removeAllUserData() {\n    var nicknameElements = document.getElementsByClassName('data-node');\n    while (nicknameElements[0]) {\n        nicknameElements[0].parentNode.removeChild(nicknameElements[0]);\n    }\n}\n\nfunction addClickListener(videoElement, userData) {\n    videoElement.addEventListener('click', function () {\n        var mainVideo = document.querySelector('#main-video video');\n        var mainUserData = document.querySelector('#main-video p');\n        if (mainVideo.srcObject !== videoElement.srcObject) {\n            mainUserData.innerHTML = userData;\n            mainVideo.srcObject = videoElement.srcObject;\n        }\n    });\n}\n\nfunction initMainVideo(videoElement, userData) {\n    document.querySelector('#main-video video').srcObject = videoElement.srcObject;\n    document.querySelector('#main-video p').innerHTML = userData;\n    document.querySelector('#main-video video')['muted'] = true;\n}\n\n/* APPLICATION SPECIFIC METHODS */    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Application specific methods"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/", 
            "text": "openvidu-insecure-angular\n\n\n Check it on GitHub\n\n\nA client-side only application built with Angular framwork.\n\n\nIf it is the first time you use OpenVidu, it is higly recommended to start with \nopenvidu-hello-world\n tutorial, as this app is no more than an extension of it with some new features and sytles.\n\n\nThis is the Angular version of \nopenvidu-insecure-js\n. Try it if you plan to use Angular framework for your frontend.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n    \n\n\n\n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.\n\n\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need angular-cli to serve the Angular frontend. You can install it with the following command:\n\n\nnpm install -g @angular/cli\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-insecure-angular\nnpm install\nng serve\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nlocalhost:4200\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\n\n    \n\n        \n\n        \n\n    \n\n    \n\n    \n\n        \n\n        \n\n    \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is an Angular project generated with angular-cli, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under \nsrc/app/\n folder:\n\n\n\n\napp.component.ts\n: AppComponent, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.\n\n\napp.component.html\n: HTML for AppComponent.\n\n\napp.component.css\n: CSS for AppComponent.\n\n\nstream.component.css\n: StreamComponent, auxiliary component to manage Stream objects on our own. It wraps the final HTML \nvideo\n which will display the video of its Stream property, as well as the user's nickname in a \np\n element.\n\n\n\n\nLet's see how \napp.component.ts\n uses NPM package \nopenvidu-browser\n:\n\n\n\n\nFirst line imports the necessary objects from \nopenvidu-browser\n:\n\n\nimport { OpenVidu, Session, Stream } from 'openvidu-browser';\n\n\n\n\n\n\napp.component.ts\n declares the following properties:\n\n\n// OpenVidu objects\nOV: OpenVidu;\nsession: Session;\n\n// Streams to feed StreamComponent's\nremoteStreams: Stream[] = [];\nlocalStream: Stream;\n\n// Join form\nsessionId: string;\ntoken: string;\n\n// Main video of the page, will be 'localStream' or one of the 'remoteStreams',\n// updated by an Output event of StreamComponent children\n@Input() mainVideoStream: Stream;\n\n\n\n\nOpenVidu\n object will allow us to get a \nSession\n object, which is declared just after it. \nremoteStreams\n array will store the active streams of other users in the video-call and \nlocalStream\n will be your own local webcam stream. Finally, \nsessionId\n and \ntoken\n params simply represent the video-call and your participant's nickname, as you will see in a moment.\n\n\n\n\nWhenever a user clicks on the submit input defined in \napp.component.html\n, \njoinSession()\n method is called:\n\n\n// --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// Init OpenVidu object\nthis.OV = new OpenVidu();\n\n// We will join the video-call \nsessionId\n. As there's no server, this parameter must start with the URL of\n// OpenVidu Server (with secure websocket protocol: \nwss://\n) and must include the OpenVidu secret at the end\nthis.session = this.OV.initSession('wss://' + location.hostname + ':8443/' + this.sessionId + '?secret=MY_SECRET');\n\n\n\n\nSession's identifiers must begin with the URL where \nopenvidu-server\n listens, so they can connect through WebSocket to it. It is necessary to explicitly set this URL in the param when using a pure frontend web. Since we are in a local sample app, \nOV.initSession\n will finally receive \nwss://localhost:8443/\n as its \nopenvidu-server\n URL. \nsessionId\n is the distinctive portion of the session identifier and allows OpenVidu to differentiate sessions from each other. In this case, this parameter is retrieved from HTML input \ninput class=\"form-control\" type=\"text\" id=\"sessionId\" ... \n, which may be filled by the user. Finally, \n'?secret=MY_SECRET'\n string allows us to connect to OpenVidu directly from the browser, without a server side.\n\n\n\n    \n\n\n\n    \nWARNING\n: this is only for demos and developing environments. Do NOT include your secret in production. Check this \nFAQ\n to learn more.\n\n\n\n\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event) =\n {\n\n    // Add the new stream to 'remoteStreams' array\n    this.remoteStreams.push(event.stream);\n\n    // Subscribe to the Stream to receive it. Second parameter is an empty string \n    // so OpenVidu doesn't create an HTML video by its own \n    this.session.subscribe(event.stream, '');\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event) =\n {\n\n    // Avoid OpenVidu trying to remove the HTML video element\n    event.preventDefault();\n\n    // Remove the stream from 'remoteStreams' array\n    this.deleteRemoteStream(event.stream);\n});\n\n\n\n\nHere we subscribe to the Session events that interest us. As we are using Angular framework, a good approach will be treating each Stream as a component, contained in a StreamComponent. Thus, we need to store each new stream we received in an array (\nremoteStreams\n), and we must remove from it every deleted stream whenever it is necessary. To achieve this, we use the following events:\n\n\n\n\n\n\nstreamCreated\n: for each new Stream received by OpenVidu, we store it in our \nremoteStreams\n array and immediately subscribe to it so we can receive its video (empty string as second parameter, so OpenVidu doesn't create an HTML video on its own). HTML template of AppComponent will show the new video, as it contains an \nngFor\n directive which will create a new StreamComponent for each Stream object stored in the array:\n\n\ndiv *ngFor=\"let s of this.remoteStreams\" class=\"stream-container col-md-6 col-xs-6\"\n\n  \nstream-component [stream]=\"s\" (mainVideoStream)=\"getMainVideoStream($event)\"\n/stream-component\n\n\n/div\n\n\n\n\n\n\n\n\nstreamDestroyed\n: for each Stream that has been destroyed (which means a user has left the video-call), we remove it from \nremoteStreams\n array, so Angular will automatically delete the required StreamComponent from HTML. We call \nevent.preventDefault()\n to cancel OpenVidu default behaviour towards \nstreamDestroyed\n event, which is the deletion of the previously created HTML video element on \nstreamCreated\n event. Because we are handling the video elements by ourselves taking advantage of Angular capabilities, we tell OpenVidu not to create them on \nstreamCreated\n and not to delete them on \nstreamDestroyed\n, by passing an empty string as second parameter on \nSession.subscribe()\n method on \nstreamCreated\n and by calling \nevent.preventDefault()\n on \nstreamDestroyed\n.\n\n\n\n\n\n\n\n\nFinally connect to the session and publish your webcam:\n\n\n\n// --- 3) Connect to the session ---\n\n// First param irrelevant if your app has no server-side. Second param will be received by every user\n// in Stream.connection.data property, which will be appended to DOM as the user's nickname\nthis.session.connect(null, '{\nclientData\n: \n' + this.userName + '\n}', (error) =\n {\n\n    // If connection successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // --- 4) Get your own camera stream with the desired resolution ---\n\n        // Both audio and video will be active. Second parameter is an empty string\n        // so OpenVidu doesn't create an HTML video by its own\n        let publisher = this.OV.initPublisher('', {\n            audio: true,\n            video: true,\n            quality: 'MEDIUM'\n        });\n\n        // Store your webcam stream in 'localStream' object\n        this.localStream = publisher.stream;\n        // Set the main video in the page to display our webcam\n        this.mainVideoStream = this.localStream;\n\n        // --- 5) Publish your stream ---\n\n        this.session.publish(publisher);\n\n    } else {\n        console.log('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n\n\n\nIn \nsession.connect\n method: first param is irrelevant when you don't have a backend (it is the user's token). Remember \nvideoElementCreated\n event, when we added the user's nickname to the HTML? Well, second parameter is the actual value you will receive in \nStream.connection.data\n property. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input \ninput type=\"text\" id=\"participantId\" required\n (filled by the user and also reused for the first \ntoken\n param).\n\n\nIn the callback of \nSession.connect\n method, we check the connection has been succesful (\nerror\n value must be \nnull\n) and right after that we get a \nPublisher\n object with both audio and video activated and MEDIUM quality. We then store our local Stream (contained in \nPublisher.stream\n object) in \nlocalStream\n, make our main video display our stream and publish the Publisher object through \nSession.publish()\n method. The rest of users will receive our Stream object and will execute their \nstreamCreated\n event.\n\n\nWith regard to our local Stream, AppComponent's HTML template has also one StreamComponent declaration ready to show our own webcam as we did with remote streams:\n\n\ndiv *ngIf=\nthis.localStream\n class=\nstream-container col-md-6 col-xs-6\n\n    \nstream-component [stream]=\nthis.localStream\n (mainVideoStream)=\ngetMainVideoStream($event)\n/stream-component\n\n\n/div\n\n\n\n\n\nLast point worth considering is the implementation of StreamComponent. As we are handling Stream objects by ourselves (task which usually is taken care by OpenVidu), and because the URL of Stream objects takes some time to get its final value as the WebRTC negotiation takes place, we must listen to any change in \nstream\n @Input property. We do so getting the \nHTMLVideoElement\n from our view on \nngAfterViewInit()\n hook method (attribute \nvideoElement\n), and then listening to \nngDoCheck()\n. This allows us to update \nvideoElement.srcObject\n value, which is the ultimate property that indicates our\nvideo\n element where to receive the media stream. If we didn't do this, the Stream object will update its \nsrcObject\n property, but our StreamComponent would keep the same initial \nvideoElement.srcObject\n value. This ensures that all our StreamComponent's will properly display all the videos in the video-call using the correct \nsrcOjbect\n value.\n\n\ngetNickNameTag()\n method feeds the view of StreamComponent with the nickName of the user. Remember \nsession.connect\n method and its second param? It can be now found at \nstream.connection.data\n, so every user will receive the nickName of others.\n\n\nvideoClicked()\n tells our AppComponent parent that the user has clicked on certain video, and that the main view should update the main video stream.\n\n\nngAfterViewInit() { // Get HTMLVideoElement from the view\n    this.videoElement = this.elementRef.nativeElement;\n}\n\nngDoCheck() { // Detect any change in 'stream' property (specifically in its 'srcObject' property)\n    if (this.videoElement \n (this.videoElement.srcObject !== this.stream.getVideoSrcObject())) {\n        this.videoElement.srcObject = this.stream.getVideoSrcObject();\n    }\n}\n\ngetNicknameTag() { // Gets the nickName of the user\n    return JSON.parse(this.stream.connection.data).clientData;\n}\n\nvideoClicked() { // Triggers event for the parent component to update its view\n    this.mainVideoStream.next(this.stream);\n}\n\n\n\n\n\n\nLeaving the session:\n\n\nWhenever we want a user to leave the session, we just need to call \nsession.disconnect\n method:\n\n\nleaveSession() {\n\n    // --- 6) Leave the session by calling 'disconnect' method over the Session object ---\n    if (this.session) { this.session.disconnect(); };\n\n    ...\n}\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-insecure-angular"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#openvidu-insecure-angular", 
            "text": "Check it on GitHub  A client-side only application built with Angular framwork.  If it is the first time you use OpenVidu, it is higly recommended to start with  openvidu-hello-world  tutorial, as this app is no more than an extension of it with some new features and sytles.  This is the Angular version of  openvidu-insecure-js . Try it if you plan to use Angular framework for your frontend.", 
            "title": "openvidu-insecure-angular"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions   \n      \n    Tutorial's name includes \"insecure\" word because this application has no backend and therefore it has no control over the users. Typically you don't want such application in production environments. When you feel comfortable with the client-side of OpenVidu, add your own server or follow one of our super simple secure tutorials.", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need angular-cli to serve the Angular frontend. You can install it with the following command:  npm install -g @angular/cli  3) Run the tutorial:  cd openvidu-tutorials/openvidu-insecure-angular\nnpm install\nng serve  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  localhost:4200  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#understanding-the-code", 
            "text": "This is an Angular project generated with angular-cli, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. We will focus on the following files under  src/app/  folder:   app.component.ts : AppComponent, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.  app.component.html : HTML for AppComponent.  app.component.css : CSS for AppComponent.  stream.component.css : StreamComponent, auxiliary component to manage Stream objects on our own. It wraps the final HTML  video  which will display the video of its Stream property, as well as the user's nickname in a  p  element.   Let's see how  app.component.ts  uses NPM package  openvidu-browser :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#first-line-imports-the-necessary-objects-from-openvidu-browser", 
            "text": "import { OpenVidu, Session, Stream } from 'openvidu-browser';", 
            "title": "First line imports the necessary objects from openvidu-browser:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#appcomponentts-declares-the-following-properties", 
            "text": "// OpenVidu objects\nOV: OpenVidu;\nsession: Session;\n\n// Streams to feed StreamComponent's\nremoteStreams: Stream[] = [];\nlocalStream: Stream;\n\n// Join form\nsessionId: string;\ntoken: string;\n\n// Main video of the page, will be 'localStream' or one of the 'remoteStreams',\n// updated by an Output event of StreamComponent children\n@Input() mainVideoStream: Stream;  OpenVidu  object will allow us to get a  Session  object, which is declared just after it.  remoteStreams  array will store the active streams of other users in the video-call and  localStream  will be your own local webcam stream. Finally,  sessionId  and  token  params simply represent the video-call and your participant's nickname, as you will see in a moment.", 
            "title": "app.component.ts declares the following properties:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#whenever-a-user-clicks-on-the-submit-input-defined-in-appcomponenthtml-joinsession-method-is-called", 
            "text": "// --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// Init OpenVidu object\nthis.OV = new OpenVidu();\n\n// We will join the video-call  sessionId . As there's no server, this parameter must start with the URL of\n// OpenVidu Server (with secure websocket protocol:  wss:// ) and must include the OpenVidu secret at the end\nthis.session = this.OV.initSession('wss://' + location.hostname + ':8443/' + this.sessionId + '?secret=MY_SECRET');  Session's identifiers must begin with the URL where  openvidu-server  listens, so they can connect through WebSocket to it. It is necessary to explicitly set this URL in the param when using a pure frontend web. Since we are in a local sample app,  OV.initSession  will finally receive  wss://localhost:8443/  as its  openvidu-server  URL.  sessionId  is the distinctive portion of the session identifier and allows OpenVidu to differentiate sessions from each other. In this case, this parameter is retrieved from HTML input  input class=\"form-control\" type=\"text\" id=\"sessionId\" ...  , which may be filled by the user. Finally,  '?secret=MY_SECRET'  string allows us to connect to OpenVidu directly from the browser, without a server side.  \n      \n     WARNING : this is only for demos and developing environments. Do NOT include your secret in production. Check this  FAQ  to learn more.   // --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event) =  {\n\n    // Add the new stream to 'remoteStreams' array\n    this.remoteStreams.push(event.stream);\n\n    // Subscribe to the Stream to receive it. Second parameter is an empty string \n    // so OpenVidu doesn't create an HTML video by its own \n    this.session.subscribe(event.stream, '');\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event) =  {\n\n    // Avoid OpenVidu trying to remove the HTML video element\n    event.preventDefault();\n\n    // Remove the stream from 'remoteStreams' array\n    this.deleteRemoteStream(event.stream);\n});  Here we subscribe to the Session events that interest us. As we are using Angular framework, a good approach will be treating each Stream as a component, contained in a StreamComponent. Thus, we need to store each new stream we received in an array ( remoteStreams ), and we must remove from it every deleted stream whenever it is necessary. To achieve this, we use the following events:    streamCreated : for each new Stream received by OpenVidu, we store it in our  remoteStreams  array and immediately subscribe to it so we can receive its video (empty string as second parameter, so OpenVidu doesn't create an HTML video on its own). HTML template of AppComponent will show the new video, as it contains an  ngFor  directive which will create a new StreamComponent for each Stream object stored in the array:  div *ngFor=\"let s of this.remoteStreams\" class=\"stream-container col-md-6 col-xs-6\" \n   stream-component [stream]=\"s\" (mainVideoStream)=\"getMainVideoStream($event)\" /stream-component  /div     streamDestroyed : for each Stream that has been destroyed (which means a user has left the video-call), we remove it from  remoteStreams  array, so Angular will automatically delete the required StreamComponent from HTML. We call  event.preventDefault()  to cancel OpenVidu default behaviour towards  streamDestroyed  event, which is the deletion of the previously created HTML video element on  streamCreated  event. Because we are handling the video elements by ourselves taking advantage of Angular capabilities, we tell OpenVidu not to create them on  streamCreated  and not to delete them on  streamDestroyed , by passing an empty string as second parameter on  Session.subscribe()  method on  streamCreated  and by calling  event.preventDefault()  on  streamDestroyed .", 
            "title": "Whenever a user clicks on the submit input defined in app.component.html, joinSession() method is called:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#finally-connect-to-the-session-and-publish-your-webcam", 
            "text": "// --- 3) Connect to the session ---\n\n// First param irrelevant if your app has no server-side. Second param will be received by every user\n// in Stream.connection.data property, which will be appended to DOM as the user's nickname\nthis.session.connect(null, '{ clientData :  ' + this.userName + ' }', (error) =  {\n\n    // If connection successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // --- 4) Get your own camera stream with the desired resolution ---\n\n        // Both audio and video will be active. Second parameter is an empty string\n        // so OpenVidu doesn't create an HTML video by its own\n        let publisher = this.OV.initPublisher('', {\n            audio: true,\n            video: true,\n            quality: 'MEDIUM'\n        });\n\n        // Store your webcam stream in 'localStream' object\n        this.localStream = publisher.stream;\n        // Set the main video in the page to display our webcam\n        this.mainVideoStream = this.localStream;\n\n        // --- 5) Publish your stream ---\n\n        this.session.publish(publisher);\n\n    } else {\n        console.log('There was an error connecting to the session:', error.code, error.message);\n    }\n});  In  session.connect  method: first param is irrelevant when you don't have a backend (it is the user's token). Remember  videoElementCreated  event, when we added the user's nickname to the HTML? Well, second parameter is the actual value you will receive in  Stream.connection.data  property. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input  input type=\"text\" id=\"participantId\" required  (filled by the user and also reused for the first  token  param).  In the callback of  Session.connect  method, we check the connection has been succesful ( error  value must be  null ) and right after that we get a  Publisher  object with both audio and video activated and MEDIUM quality. We then store our local Stream (contained in  Publisher.stream  object) in  localStream , make our main video display our stream and publish the Publisher object through  Session.publish()  method. The rest of users will receive our Stream object and will execute their  streamCreated  event.  With regard to our local Stream, AppComponent's HTML template has also one StreamComponent declaration ready to show our own webcam as we did with remote streams:  div *ngIf= this.localStream  class= stream-container col-md-6 col-xs-6 \n     stream-component [stream]= this.localStream  (mainVideoStream)= getMainVideoStream($event) /stream-component  /div   Last point worth considering is the implementation of StreamComponent. As we are handling Stream objects by ourselves (task which usually is taken care by OpenVidu), and because the URL of Stream objects takes some time to get its final value as the WebRTC negotiation takes place, we must listen to any change in  stream  @Input property. We do so getting the  HTMLVideoElement  from our view on  ngAfterViewInit()  hook method (attribute  videoElement ), and then listening to  ngDoCheck() . This allows us to update  videoElement.srcObject  value, which is the ultimate property that indicates our video  element where to receive the media stream. If we didn't do this, the Stream object will update its  srcObject  property, but our StreamComponent would keep the same initial  videoElement.srcObject  value. This ensures that all our StreamComponent's will properly display all the videos in the video-call using the correct  srcOjbect  value.  getNickNameTag()  method feeds the view of StreamComponent with the nickName of the user. Remember  session.connect  method and its second param? It can be now found at  stream.connection.data , so every user will receive the nickName of others.  videoClicked()  tells our AppComponent parent that the user has clicked on certain video, and that the main view should update the main video stream.  ngAfterViewInit() { // Get HTMLVideoElement from the view\n    this.videoElement = this.elementRef.nativeElement;\n}\n\nngDoCheck() { // Detect any change in 'stream' property (specifically in its 'srcObject' property)\n    if (this.videoElement   (this.videoElement.srcObject !== this.stream.getVideoSrcObject())) {\n        this.videoElement.srcObject = this.stream.getVideoSrcObject();\n    }\n}\n\ngetNicknameTag() { // Gets the nickName of the user\n    return JSON.parse(this.stream.connection.data).clientData;\n}\n\nvideoClicked() { // Triggers event for the parent component to update its view\n    this.mainVideoStream.next(this.stream);\n}", 
            "title": "Finally connect to the session and publish your webcam:"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#leaving-the-session", 
            "text": "Whenever we want a user to leave the session, we just need to call  session.disconnect  method:  leaveSession() {\n\n    // --- 6) Leave the session by calling 'disconnect' method over the Session object ---\n    if (this.session) { this.session.disconnect(); };\n\n    ...\n}    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "Leaving the session:"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/", 
            "text": "openvidu-js-java\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of \nopenvidu-java-client\n to get the necessary params from OpenVidu Server.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-java-client\n: Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-java-client\n to get this sample app working\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nmaven\n to build the project. You can install it with:\n\n\nsudo apt-get install maven\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-js-java\nmvn package exec:java\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nHttpSession\n API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: \njournaldev.com\n, \nstudytonight.com\n.\n\n\n\n\n\n\nBackend\n: SpringBoot app with the following classes (\nsrc/main/java\n path, \nio.openvidu.js.java\n package)\n\n\n\n\nApp.java\n : entrypoint for the app\n\n\nLoginController.java\n : rest controller for handling login and logout operations\n\n\nSessionController.java\n : rest controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them\n\n\n\n\n\n\n\n\nFrontend\n: Pure JS/HTML/CSS files (\nsrc/main/resources/static\n)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n : sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n.\n\n\n\n\nindex.html\n : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:\n\n\nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1)  User logs in\n\n\nWe have implemented a method for making HTTP requests to the backend, as we will need to make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:\n\n\nfunction httpRequest(method, url, body, errorMsg, callback)\n\n\n\n\nWhere \nmethod\n is whether \"POST\" or \"GET\", \nurl\n the path of the REST operation, \nbody\n the data to be passed, \nerrorMsg\n the output error message if something goes wrong and \ncallback\n the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.\n\n\nindex.html\n will first show a form to log in:\n\n\n\n  \n\n\n\n\n\napp.js\n sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:\n\n\nfunction logIn() {\n    var user = $(\n#user\n).val(); // Username\n    var pass = $(\n#pass\n).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        console.warn(userName + ' login');\n        // HTML shows logged-in page ...\n    });\n}\n\n\n\n\nLoginController.java\n checks the params are correct and if so sets an \nHttpSession\n for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object):\n\n\n@RequestMapping(value = \n/login\n, method = RequestMethod.POST)\npublic ResponseEntity\nObject\n login(@RequestBody String userPass, HttpSession httpSession) throws ParseException {\n\n    // Retrieve params from POST body\n    JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass);\n    String user = (String) userPassJson.get(\nuser\n);\n    String pass = (String) userPassJson.get(\npass\n);\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute(\nloggedUser\n, user);\n        return new ResponseEntity\n(HttpStatus.OK);\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        httpSession.invalidate();\n        return new ResponseEntity\n(\nUser/Pass incorrect\n, HttpStatus.UNAUTHORIZED);\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\nHTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:\n\n\n\n  \n\n\n\n\n\napp.js\n will execute \njoinSession()\n method, which starts like this:\n\n\nfunction joinSession() {\n    getSessionIdAndToken(function () { ...\n\n\n\n\nSo the first thing to do here is to retrieve a \nsessionId\n and a \ntoken\n from our backend. Only when we have them available in the browser we will continue with the \njoin\n operation. Let's see what \ngetSessionIdAndToken()\n looks like:\n\n\nfunction getSessionIdAndToken(callback) {\n    sessionName = $(\n#sessionName\n).val(); // Video-call chosen by the user (\nTUTORIAL\n)\n    nickName = $(\n#participantName\n).val(); // Nickname chosen by the user\n\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}\n\n\n\n\nHere is the second time we must call our \nhttpRequest()\n method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a \nsessionId\n and a \ntoken\n as response. The interesting part here is in \nSessionController.java\n. First of all there are some important attributes in this class we must mention:\n\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map\nString, Session\n mapSessions = new ConcurrentHashMap\n();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map\nString, Map\nString, OpenViduRole\n mapSessionIdsTokens = new ConcurrentHashMap\n();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;\n\n\n\n\nRest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: \ntokenOptions\n.\n\n\n@RequestMapping(value = \n/api-sessions/get-sessionid-token\n, method = RequestMethod.POST)\npublic ResponseEntity\nJSONObject\n getSessionIdToken(@RequestBody String sessionNameParam, \n        HttpSession httpSession) throws ParseException {\n    // Check the user is logged ... \n\n    JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam);\n\n    // The video-call to connect (\nTUTORIAL\n)\n    String sessionName = (String) sessionJSON.get(\nsession\n);\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\nloggedUser\n)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData = \n{\\\nserverData\\\n: \\\n + httpSession.getAttribute(\nloggedUser\n) + \n\\\n}\n;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n    JSONObject responseJson = new JSONObject();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exist? \n\n\nif (this.mapSessions.get(sessionName) != null) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap\n());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity\n(responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}\n\n\n\n\nWe are almost there! Now in \napp.js\n we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{\nclientData\n: \n' + nickName + '\n}', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n// HTML shows session page ...\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nSessionController.java\n executes \ngetSessionIdAndToken()\n method. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param (\nTUTORIAL\n)\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity\n(responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}\n\n\n\n\nThe code executed in \napp.js\n would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nleaveSession()\n (and therefore \nsession.disconnect()\n) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, \nsession.disconnect()\n updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in \napp.js\n we run:\n\n\nfunction removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}\n\n\n\n\nAnd in \nSessionController.java\n we update the collections:\n\n\n@RequestMapping(value = \n/api-sessions/remove-user\n, method = RequestMethod.POST)\npublic ResponseEntity\nJSONObject\n removeUser(@RequestBody String sessionNameToken, \n    HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // Retrieve the params from BODY\n    JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken);\n    String sessionName = (String) sessionNameTokenJSON.get(\nsessionName\n);\n    String token = (String) sessionNameTokenJSON.get(\ntoken\n);\n\n    // If the session exists (\nTUTORIAL\n in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // User left the session\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session \nTUTORIAL\n must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                return new ResponseEntity\n(HttpStatus.OK);\n            } else {\n                // The TOKEN wasn't valid\n                return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    } else {\n        // The SESSION does not exist\n        return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n\n\n\n\nWhen the last user leaves the session \nthis.mapSessions.remove(sessionName);\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-js-java"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#openvidu-js-java", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of  openvidu-java-client  to get the necessary params from OpenVidu Server.", 
            "title": "openvidu-js-java"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-java-client : Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-java-client  to get this sample app working", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  maven  to build the project. You can install it with:  sudo apt-get install maven  3) Run the tutorial:  cd openvidu-tutorials/openvidu-js-java\nmvn package exec:java  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  HttpSession  API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial:  journaldev.com ,  studytonight.com .    Backend : SpringBoot app with the following classes ( src/main/java  path,  io.openvidu.js.java  package)   App.java  : entrypoint for the app  LoginController.java  : rest controller for handling login and logout operations  SessionController.java  : rest controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them     Frontend : Pure JS/HTML/CSS files ( src/main/resources/static )   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file.   app.js  : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js .   index.html  : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:  script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script     style.css : some CSS classes to style  index.html .      Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#1-user-logs-in", 
            "text": "We have implemented a method for making HTTP requests to the backend, as we will need to make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:  function httpRequest(method, url, body, errorMsg, callback)  Where  method  is whether \"POST\" or \"GET\",  url  the path of the REST operation,  body  the data to be passed,  errorMsg  the output error message if something goes wrong and  callback  the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.  index.html  will first show a form to log in:  \n     app.js  sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:  function logIn() {\n    var user = $( #user ).val(); // Username\n    var pass = $( #pass ).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        console.warn(userName + ' login');\n        // HTML shows logged-in page ...\n    });\n}  LoginController.java  checks the params are correct and if so sets an  HttpSession  for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object):  @RequestMapping(value =  /login , method = RequestMethod.POST)\npublic ResponseEntity Object  login(@RequestBody String userPass, HttpSession httpSession) throws ParseException {\n\n    // Retrieve params from POST body\n    JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass);\n    String user = (String) userPassJson.get( user );\n    String pass = (String) userPassJson.get( pass );\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute( loggedUser , user);\n        return new ResponseEntity (HttpStatus.OK);\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        httpSession.invalidate();\n        return new ResponseEntity ( User/Pass incorrect , HttpStatus.UNAUTHORIZED);\n    }\n}", 
            "title": "1)  User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#2-user-connects-to-tutorial-video-call", 
            "text": "HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:  \n     app.js  will execute  joinSession()  method, which starts like this:  function joinSession() {\n    getSessionIdAndToken(function () { ...  So the first thing to do here is to retrieve a  sessionId  and a  token  from our backend. Only when we have them available in the browser we will continue with the  join  operation. Let's see what  getSessionIdAndToken()  looks like:  function getSessionIdAndToken(callback) {\n    sessionName = $( #sessionName ).val(); // Video-call chosen by the user ( TUTORIAL )\n    nickName = $( #participantName ).val(); // Nickname chosen by the user\n\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}  Here is the second time we must call our  httpRequest()  method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a  sessionId  and a  token  as response. The interesting part here is in  SessionController.java . First of all there are some important attributes in this class we must mention:  // OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map String, Session  mapSessions = new ConcurrentHashMap ();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map String, Map String, OpenViduRole  mapSessionIdsTokens = new ConcurrentHashMap ();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;  Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on:  tokenOptions .  @RequestMapping(value =  /api-sessions/get-sessionid-token , method = RequestMethod.POST)\npublic ResponseEntity JSONObject  getSessionIdToken(@RequestBody String sessionNameParam, \n        HttpSession httpSession) throws ParseException {\n    // Check the user is logged ... \n\n    JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam);\n\n    // The video-call to connect ( TUTORIAL )\n    String sessionName = (String) sessionJSON.get( session );\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute( loggedUser )).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData =  {\\ serverData\\ : \\  + httpSession.getAttribute( loggedUser ) +  \\ } ;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n    JSONObject responseJson = new JSONObject();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exist?   if (this.mapSessions.get(sessionName) != null) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap ());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity (responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}  We are almost there! Now in  app.js  we can init a new Session with  sessionId  and connect to it with  token :  // --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{ clientData :  ' + nickName + ' }', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n// HTML shows session page ...  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  SessionController.java  executes  getSessionIdAndToken()  method. Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param ( TUTORIAL )\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity (responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}  The code executed in  app.js  would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  leaveSession()  (and therefore  session.disconnect() ) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up,  session.disconnect()  updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in  app.js  we run:  function removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}  And in  SessionController.java  we update the collections:  @RequestMapping(value =  /api-sessions/remove-user , method = RequestMethod.POST)\npublic ResponseEntity JSONObject  removeUser(@RequestBody String sessionNameToken, \n    HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // Retrieve the params from BODY\n    JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken);\n    String sessionName = (String) sessionNameTokenJSON.get( sessionName );\n    String token = (String) sessionNameTokenJSON.get( token );\n\n    // If the session exists ( TUTORIAL  in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // User left the session\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session  TUTORIAL  must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                return new ResponseEntity (HttpStatus.OK);\n            } else {\n                // The TOKEN wasn't valid\n                return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    } else {\n        // The SESSION does not exist\n        return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}  When the last user leaves the session  this.mapSessions.remove(sessionName);  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/", 
            "text": "openvidu-mvc-java\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Java backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to \nopenvidu-js-java\n. This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. \nThymeleaf\n is the template engine of choice for this tutorial.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-java-client\n: Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-java-client\n to get this sample app working\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nmaven\n to build the project. You can install it with:\n\n\nsudo apt-get install maven\n\n\n\n\n3) Run the tutorial:\n\n\ncd openvidu-tutorials/openvidu-mvc-java\nmvn package exec:java\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of \nThymeleaf\n.\n\n\nOpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nHttpSession\n API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: \njournaldev.com\n, \nstudytonight.com\n.\n\n\n\n\n\n\nBackend\n: SpringBoot app with the following classes (\nsrc/main/java\n path, \nio.openvidu.js.java\n package)\n\n\n\n\nApp.java\n : entrypoint for the app\n\n\nLoginController.java\n : controller for handling login and logout operations\n\n\nSessionController.java\n : controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them\n\n\n\n\n\n\n\n\nFrontend templates\n: Pure JS/HTML/CSS files served by the backend (\nsrc/main/resources/templates\n)\n\n\n\n\nindex.html\n : template with the login form\n\n\ndashboard.html\n : template with the form to join a video-call\n\n\nsession.html\n : template of the video-call itself\n\n\n\n\n\n\n\n\nFrontend static files\n (\nsrc/main/resources/static\n)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file\n\n\nstyle.css\n : some CSS classes to style the templates\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nAt path \n/\n a login form will be displayed:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/dashboard\n whenever \"Log in\" button is clicked, passing the username and the password:\n\n\nform class=\nform-group jumbotron\n action=\n/dashboard\n method=\npost\n\n    \np\n\n        \nlabel\nUser\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nuser\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nPass\n/label\n\n        \ninput class=\nform-control\n type=\npassword\n name=\npass\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-info\n type=\nsubmit\nLog in\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nLoginController.java\n first checks if the user is already logged (maybe he has just refreshed \n/dashboard\n page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an \nHttpSession\n for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns \ndashboard.html\n template:\n\n\n@RequestMapping(value = \n/dashboard\n, method = { RequestMethod.GET, RequestMethod.POST })\npublic String login(@RequestParam(name = \nuser\n, required = false) String user,\n            @RequestParam(name = \npass\n, required = false) String pass,\n            Model model, HttpSession httpSession) {\n\n    // Check if the user is already logged in\n    String userName = (String) httpSession.getAttribute(\nloggedUser\n);\n    if (userName != null) { \n        // User is already logged. Immediately return dashboard\n        model.addAttribute(\nusername\n, userName);\n        return \ndashboard\n;\n    }\n\n    // User wasn't logged and wants to\n    if (login(user, pass)) { // Correct user-pass\n\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute(\nloggedUser\n, user);\n        model.addAttribute(\nusername\n, user);\n\n        // Return dashboard.html template\n        return \ndashboard\n;\n\n    } else { // Wrong user-pass\n        // Invalidate session and redirect to index.html\n        httpSession.invalidate();\n        return \nredirect:/\n;\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\ndashboard.html\n template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/session\n whenever \"Join!\" button is clicked, passing the nickname and the session name:\n\n\nform class=\nform-group\n action=\n/session\n method=\npost\n\n    \np\n\n        \nlabel\nParticipant\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\ndata\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nSession\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nsession-name\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-success\n type=\nsubmit\nJoin!\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nWhen \nSessionController.java\n receives a request at \n/session\n path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:\n\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map\nString, Session\n mapSessions = new ConcurrentHashMap\n();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map\nString, Map\nString, OpenViduRole\n mapSessionIdsTokens = new ConcurrentHashMap\n();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;\n\n\n\n\nRest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: \ntokenOptions\n.\n\n\n@RequestMapping(value = \n/session\n, method = RequestMethod.POST)\npublic String joinSession(@RequestParam(name = \ndata\n) String clientData,\n              @RequestParam(name = \nsession-name\n) String sessionName, \n              Model model, HttpSession httpSession) {\n    // Check the user is logged ... \n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\nloggedUser\n)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData = \n{\\\nserverData\\\n: \\\n + httpSession.getAttribute(\nloggedUser\n) + \n\\\n}\n;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exist? \n\n\nif (this.mapSessions.get(sessionName) != null) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap\n());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute(\nsessionId\n, sessionId);\n        model.addAttribute(\ntoken\n, token);\n        model.addAttribute(\nnickName\n, clientData);\n        model.addAttribute(\nuserName\n, httpSession.getAttribute(\nloggedUser\n));\n        model.addAttribute(\nsessionName\n, sessionName);\n\n        // Return session.html template\n        return \nsession\n;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute(\nusername\n, httpSession.getAttribute(\nloggedUser\n));\n        return \ndashboard\n;\n    }\n}\n\n\n\n\nWe are almost there! Now in \nsession.html\n JavaScript code (preceded by a tag \nscript th:inline=\"javascript\"\n) we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// Get all the attributes from the template in Thymeleaf style\nvar sessionId = [[${sessionId}]];\nvar token = [[${token}]];\nvar nickName = [[${nickName}]];\nvar userName = [[${userName}]];\nvar sessionName = [[${sessionName}]];\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\nsession.connect(token, '{\nclientData\n: \n' + nickName + '\n}', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true);  // Mute local video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nSessionController.java\n executes \ngetSessionIdAndToken()\n method. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param (\nTUTORIAL\n)\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute(\nsessionId\n, sessionId);\n        model.addAttribute(\ntoken\n, token);\n        model.addAttribute(\nnickName\n, clientData);\n        model.addAttribute(\nuserName\n, httpSession.getAttribute(\nloggedUser\n));\n        model.addAttribute(\nsessionName\n, sessionName);\n\n        // Return session.html template\n        return \nsession\n;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute(\nusername\n, httpSession.getAttribute(\nloggedUser\n));\n        return \ndashboard\n;\n    }\n}\n\n\n\n\nThe code executed in \nsession.html\n \n script \n tag would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nsession.disconnect()\n (triggered in \nleaveSession()\n \nonclick\n method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.\n\n\nIn \nsession.html\n template the \"Leave session\" button actually performs a POST operation to path \n/leave-session\n with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the \nleaveSession()\n method. First updates our backend. Second updates our openvidu-server.\n\n\nform action=\n/leave-session\n method=\npost\n\n    \ninput type=\nhidden\n name=\nsession-name\n th:value=\n${sessionName}\n/input\n\n    \ninput type=\nhidden\n name=\ntoken\n th:value=\n${token}\n/input\n\n    \nbutton id=\nbuttonLeaveSession\n class=\nbtn btn-large btn-danger\n type=\nsubmit\n onclick=\nleaveSession()\n\n        Leave session\n/button\n\n\n/form\n\n\n\n\n\nIn \nSessionController.java\n we update the collections:\n\n\n@RequestMapping(value = \n/leave-session\n, method = RequestMethod.POST)\npublic String removeUser(@RequestParam(name = \nsession-name\n) String sessionName,\n             @RequestParam(name = \ntoken\n) String token,\n             Model model, HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // If the session exists (\nTUTORIAL\n in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // User left the session\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session \nTUTORIAL\n must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                return \nredirect:/dashboard\n;\n            } else {\n                // The TOKEN wasn't valid\n                return \nredirect:/dashboard\n;\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            return \nredirect:/dashboard\n;\n        }\n    } else {\n        // The SESSION does not exist\n        return \nredirect:/dashboard\n;\n    }\n}\n\n\n\n\nWhen the last user leaves the session \nthis.mapSessions.remove(sessionName);\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-mvc-java"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#openvidu-mvc-java", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Java backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to  openvidu-js-java . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends.  Thymeleaf  is the template engine of choice for this tutorial.", 
            "title": "openvidu-mvc-java"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-java-client : Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-java-client  to get this sample app working", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  maven  to build the project. You can install it with:  sudo apt-get install maven  3) Run the tutorial:  cd openvidu-tutorials/openvidu-mvc-java\nmvn package exec:java  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of  Thymeleaf .  OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  HttpSession  API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial:  journaldev.com ,  studytonight.com .    Backend : SpringBoot app with the following classes ( src/main/java  path,  io.openvidu.js.java  package)   App.java  : entrypoint for the app  LoginController.java  : controller for handling login and logout operations  SessionController.java  : controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them     Frontend templates : Pure JS/HTML/CSS files served by the backend ( src/main/resources/templates )   index.html  : template with the login form  dashboard.html  : template with the form to join a video-call  session.html  : template of the video-call itself     Frontend static files  ( src/main/resources/static )   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file  style.css  : some CSS classes to style the templates     Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#1-user-logs-in", 
            "text": "At path  /  a login form will be displayed:  \n     The form will execute a POST operation to path  /dashboard  whenever \"Log in\" button is clicked, passing the username and the password:  form class= form-group jumbotron  action= /dashboard  method= post \n     p \n         label User /label \n         input class= form-control  type= text  name= user  required= true /input \n     /p \n     p \n         label Pass /label \n         input class= form-control  type= password  name= pass  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-info  type= submit Log in /button \n     /p  /form   LoginController.java  first checks if the user is already logged (maybe he has just refreshed  /dashboard  page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an  HttpSession  for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns  dashboard.html  template:  @RequestMapping(value =  /dashboard , method = { RequestMethod.GET, RequestMethod.POST })\npublic String login(@RequestParam(name =  user , required = false) String user,\n            @RequestParam(name =  pass , required = false) String pass,\n            Model model, HttpSession httpSession) {\n\n    // Check if the user is already logged in\n    String userName = (String) httpSession.getAttribute( loggedUser );\n    if (userName != null) { \n        // User is already logged. Immediately return dashboard\n        model.addAttribute( username , userName);\n        return  dashboard ;\n    }\n\n    // User wasn't logged and wants to\n    if (login(user, pass)) { // Correct user-pass\n\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute( loggedUser , user);\n        model.addAttribute( username , user);\n\n        // Return dashboard.html template\n        return  dashboard ;\n\n    } else { // Wrong user-pass\n        // Invalidate session and redirect to index.html\n        httpSession.invalidate();\n        return  redirect:/ ;\n    }\n}", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#2-user-connects-to-tutorial-video-call", 
            "text": "dashboard.html  template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:  \n     The form will execute a POST operation to path  /session  whenever \"Join!\" button is clicked, passing the nickname and the session name:  form class= form-group  action= /session  method= post \n     p \n         label Participant /label \n         input class= form-control  type= text  name= data  required= true /input \n     /p \n     p \n         label Session /label \n         input class= form-control  type= text  name= session-name  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-success  type= submit Join! /button \n     /p  /form   When  SessionController.java  receives a request at  /session  path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:  // OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map String, Session  mapSessions = new ConcurrentHashMap ();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map String, Map String, OpenViduRole  mapSessionIdsTokens = new ConcurrentHashMap ();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;  Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on:  tokenOptions .  @RequestMapping(value =  /session , method = RequestMethod.POST)\npublic String joinSession(@RequestParam(name =  data ) String clientData,\n              @RequestParam(name =  session-name ) String sessionName, \n              Model model, HttpSession httpSession) {\n    // Check the user is logged ... \n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute( loggedUser )).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData =  {\\ serverData\\ : \\  + httpSession.getAttribute( loggedUser ) +  \\ } ;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exist?   if (this.mapSessions.get(sessionName) != null) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap ());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute( sessionId , sessionId);\n        model.addAttribute( token , token);\n        model.addAttribute( nickName , clientData);\n        model.addAttribute( userName , httpSession.getAttribute( loggedUser ));\n        model.addAttribute( sessionName , sessionName);\n\n        // Return session.html template\n        return  session ;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute( username , httpSession.getAttribute( loggedUser ));\n        return  dashboard ;\n    }\n}  We are almost there! Now in  session.html  JavaScript code (preceded by a tag  script th:inline=\"javascript\" ) we can init a new Session with  sessionId  and connect to it with  token :  // Get all the attributes from the template in Thymeleaf style\nvar sessionId = [[${sessionId}]];\nvar token = [[${token}]];\nvar nickName = [[${nickName}]];\nvar userName = [[${userName}]];\nvar sessionName = [[${sessionName}]];\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new HTML element for the user's name and nickname over its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\nsession.connect(token, '{ clientData :  ' + nickName + ' }', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true);  // Mute local video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  SessionController.java  executes  getSessionIdAndToken()  method. Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param ( TUTORIAL )\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute( sessionId , sessionId);\n        model.addAttribute( token , token);\n        model.addAttribute( nickName , clientData);\n        model.addAttribute( userName , httpSession.getAttribute( loggedUser ));\n        model.addAttribute( sessionName , sessionName);\n\n        // Return session.html template\n        return  session ;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute( username , httpSession.getAttribute( loggedUser ));\n        return  dashboard ;\n    }\n}  The code executed in  session.html    script   tag would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  session.disconnect()  (triggered in  leaveSession()   onclick  method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.  In  session.html  template the \"Leave session\" button actually performs a POST operation to path  /leave-session  with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the  leaveSession()  method. First updates our backend. Second updates our openvidu-server.  form action= /leave-session  method= post \n     input type= hidden  name= session-name  th:value= ${sessionName} /input \n     input type= hidden  name= token  th:value= ${token} /input \n     button id= buttonLeaveSession  class= btn btn-large btn-danger  type= submit  onclick= leaveSession() \n        Leave session /button  /form   In  SessionController.java  we update the collections:  @RequestMapping(value =  /leave-session , method = RequestMethod.POST)\npublic String removeUser(@RequestParam(name =  session-name ) String sessionName,\n             @RequestParam(name =  token ) String token,\n             Model model, HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // If the session exists ( TUTORIAL  in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // User left the session\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session  TUTORIAL  must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                return  redirect:/dashboard ;\n            } else {\n                // The TOKEN wasn't valid\n                return  redirect:/dashboard ;\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            return  redirect:/dashboard ;\n        }\n    } else {\n        // The SESSION does not exist\n        return  redirect:/dashboard ;\n    }\n}  When the last user leaves the session  this.mapSessions.remove(sessionName);  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/", 
            "text": "openvidu-js-node\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of the \nopenvidu-node-client\n to get the necessary params from OpenVidu Server.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-node-client\n: NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-node-client\n to get this sample app working\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nnode\n to execute the app. You can install them with:\n\n\nsudo curl -sL https://deb.nodesource.com/setup_6.x | sudo bash -\nsudo apt-get install -y nodejs\n\n\n\n\n3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute \nserver.js\n server passing two arguments: \"localhost:8443\" as the URL where \nopenvidu-server\n will be listening and \"MY_SECRET\" as the secret share with it:\n\n\ncd openvidu-tutorials/openvidu-js-node\nnpm install\nnode server.js localhost:8443 MY_SECRET\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend with \nexpress\n. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nexpress-session\n API.\n\n\n\n\n\n\nBackend\n: node server\n\n\n\n\nserver.js\n : single file which handles all operations of server.\n\n\n\n\n\n\n\n\nFrontend\n: Pure JS/HTML/CSS files (\n/public\n folder)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n : sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n.\n\n\n\n\nindex.html\n : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:\n\n\nscript src=\"openvidu-browser-VERSION.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nWe have implemented a method for making HTTP requests to the backend, as we will need to    make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:\n\n\nfunction httpRequest(method, url, body, errorMsg, callback)\n\n\n\n\nWhere \nmethod\n is whether \"POST\" or \"GET\", \nurl\n the path of the REST operation, \nbody\n the data to be passed, \nerrorMsg\n the output error message if something goes wrong and \ncallback\n the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.\n\n\nindex.html\n will first show a form to log in:\n\n\n\n  \n\n\n\n\n\napp.js\n sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:\n\n\nfunction logIn() {\n    var user = $(\n#user\n).val(); // Username\n    var pass = $(\n#pass\n).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        // HTML shows logged-in page ...\n    });\n}\n\n\n\n\nserver.js\n at \n/api-login/login\n checks the params are correct and if so sets an active session for the newly logged user (adding a \nloggedUser\n property with its username in the \nreq.session\n object):\n\n\napp.post('/api-login/login', function (req, res) {\n\n    // Retrieve params from POST body\n    var user = req.body.user;\n    var pass = req.body.pass;\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in req.session allows us to identify the user in future requests\n        req.session.loggedUser = user;\n        res.status(200).send();\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        req.session.destroy();\n        res.status(401).send('User/Pass incorrect');\n    }\n});\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\nHTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:\n\n\n\n  \n\n\n\n\n\napp.js\n will execute \njoinSession()\n method, which starts like this:\n\n\nfunction joinSession() {\n    getSessionIdAndToken(function () { ...\n\n\n\n\nSo the first thing to do here is to retrieve a \nsessionId\n and a \ntoken\n from our backend. Only when we have them available in the browser we will continue with the \njoin\n operation. Let's see what \ngetSessionIdAndToken()\n looks like:\n\n\nfunction getSessionIdAndToken(callback) {\n    sessionName = $(\n#sessionName\n).val(); // Video-call chosen by the user (\nTUTORIAL\n)\n    nickName = $(\n#participantName\n).val(); // Nickname chosen by the user\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}\n\n\n\n\nHere is the second time we must call our \nhttpRequest()\n method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a \nsessionId\n and a \ntoken\n as response. The interesting part here is in \nserver.js\n controller at \n/api-sessions/get-sessionid-token\n. First of all there are some important attributes in this class we must mention:\n\n\n// Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};\n\n\n\n\nRest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: \ntokenOptions\n.\n\n\napp.post('/api-sessions/get-sessionid-token', function (req, res) {\n    // Check the user is logged ... \n\n    // The video-call to connect (\nTUTORIAL\n)\n    var sessionName = req.body.session;\n\n    // Role associated to this user\n    var role = users.find(u =\n (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = '{\nserverData\n: \n' + req.session.loggedUser + '\n}';\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = new TokenOptions.Builder()\n        .data(serverData)\n        .role(role)\n        .build();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exist? \n\n\nif (mapSessionNameSession[sessionName]) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse { // New session: return a new sessionId and a new token\n\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return the sessionId and token to the client\n            res.status(200).send({\n                0: sessionId,\n                1: token\n            });\n        });\n    });\n}\n\n\n\n\nWe are almost there! Now in \napp.js\n we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new \np\n element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{\nclientData\n: \n' + nickName + '\n}', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute lcoal video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n// HTML shows session page ...\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nserver.js\n executes controller at \n/api-sessions/get-sessionid-token\n. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        mySession.getSessionId(function (sessionId) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return the sessionId and token to the client\n            res.status(200).send({\n                0: sessionId,\n                1: token\n            });\n        });\n    });\n}\n\n\n\n\nThe code executed in \napp.js\n would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nleaveSession()\n (and therefore \nsession.disconnect()\n) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, \nsession.disconnect()\n updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in \napp.js\n we run:\n\n\nfunction removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}\n\n\n\n\nAnd in \nserver.js\n we update the collections in \n/api-sessions/remove-user\n:\n\n\napp.post('/api-sessions/remove-user', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionName;\n    var token = req.body.token;\n\n    // If the session exists\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        mySession.getSessionId(function (sessionId) {\n            var tokens = mapSessionIdTokens[sessionId];\n            if (tokens) {\n                var index = tokens.indexOf(token);\n\n                // If the token exists\n                if (index !== -1) {\n                    // Token removed!\n                    tokens.splice(index, 1);\n                } else {\n                    var msg = 'Problems in the app server: the TOKEN wasn\\'t valid';\n                    res.status(500).send(msg);\n                }\n                if (mapSessionIdTokens[sessionId].length == 0) {\n                    // Last user left: session must be removed\n                    delete mapSessionNameSession[sessionName];\n                }\n                res.status(200).send();\n            } else {\n                var msg = 'Problems in the app server: the SESSIONID wasn\\'t valid';\n                res.status(500).send(msg);\n            }\n        });\n    } else {\n        var msg = 'Problems in the app server: the SESSION does not exist';\n        res.status(500).send(msg);\n    }\n\n\n\n\nWhen the last user leaves the session \ndelete mapSessionNameSession[sessionName]\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-js-node"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#openvidu-js-node", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of the  openvidu-node-client  to get the necessary params from OpenVidu Server.", 
            "title": "openvidu-js-node"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-node-client : NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-node-client  to get this sample app working", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  node  to execute the app. You can install them with:  sudo curl -sL https://deb.nodesource.com/setup_6.x | sudo bash -\nsudo apt-get install -y nodejs  3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute  server.js  server passing two arguments: \"localhost:8443\" as the URL where  openvidu-server  will be listening and \"MY_SECRET\" as the secret share with it:  cd openvidu-tutorials/openvidu-js-node\nnpm install\nnode server.js localhost:8443 MY_SECRET  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend with  express . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  express-session  API.    Backend : node server   server.js  : single file which handles all operations of server.     Frontend : Pure JS/HTML/CSS files ( /public  folder)   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file.   app.js  : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js .   index.html  : HTML code for the form to login, the form to connect to a video-call and for the video-call itself. It has two links to both JavaScript files:  script src=\"openvidu-browser-VERSION.js\" /script  script src=\"app.js\" /script     style.css : some CSS classes to style  index.html .      Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#1-user-logs-in", 
            "text": "We have implemented a method for making HTTP requests to the backend, as we will need to    make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:  function httpRequest(method, url, body, errorMsg, callback)  Where  method  is whether \"POST\" or \"GET\",  url  the path of the REST operation,  body  the data to be passed,  errorMsg  the output error message if something goes wrong and  callback  the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.  index.html  will first show a form to log in:  \n     app.js  sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:  function logIn() {\n    var user = $( #user ).val(); // Username\n    var pass = $( #pass ).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        // HTML shows logged-in page ...\n    });\n}  server.js  at  /api-login/login  checks the params are correct and if so sets an active session for the newly logged user (adding a  loggedUser  property with its username in the  req.session  object):  app.post('/api-login/login', function (req, res) {\n\n    // Retrieve params from POST body\n    var user = req.body.user;\n    var pass = req.body.pass;\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in req.session allows us to identify the user in future requests\n        req.session.loggedUser = user;\n        res.status(200).send();\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        req.session.destroy();\n        res.status(401).send('User/Pass incorrect');\n    }\n});", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#2-user-connects-to-tutorial-video-call", 
            "text": "HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:  \n     app.js  will execute  joinSession()  method, which starts like this:  function joinSession() {\n    getSessionIdAndToken(function () { ...  So the first thing to do here is to retrieve a  sessionId  and a  token  from our backend. Only when we have them available in the browser we will continue with the  join  operation. Let's see what  getSessionIdAndToken()  looks like:  function getSessionIdAndToken(callback) {\n    sessionName = $( #sessionName ).val(); // Video-call chosen by the user ( TUTORIAL )\n    nickName = $( #participantName ).val(); // Nickname chosen by the user\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}  Here is the second time we must call our  httpRequest()  method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a  sessionId  and a  token  as response. The interesting part here is in  server.js  controller at  /api-sessions/get-sessionid-token . First of all there are some important attributes in this class we must mention:  // Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};  Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on:  tokenOptions .  app.post('/api-sessions/get-sessionid-token', function (req, res) {\n    // Check the user is logged ... \n\n    // The video-call to connect ( TUTORIAL )\n    var sessionName = req.body.session;\n\n    // Role associated to this user\n    var role = users.find(u =  (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = '{ serverData :  ' + req.session.loggedUser + ' }';\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = new TokenOptions.Builder()\n        .data(serverData)\n        .role(role)\n        .build();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exist?   if (mapSessionNameSession[sessionName]) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else { // New session: return a new sessionId and a new token\n\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return the sessionId and token to the client\n            res.status(200).send({\n                0: sessionId,\n                1: token\n            });\n        });\n    });\n}  We are almost there! Now in  app.js  we can init a new Session with  sessionId  and connect to it with  token :  // --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new  p  element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{ clientData :  ' + nickName + ' }', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute lcoal video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n// HTML shows session page ...  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  server.js  executes controller at  /api-sessions/get-sessionid-token . Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        mySession.getSessionId(function (sessionId) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return the sessionId and token to the client\n            res.status(200).send({\n                0: sessionId,\n                1: token\n            });\n        });\n    });\n}  The code executed in  app.js  would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  leaveSession()  (and therefore  session.disconnect() ) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up,  session.disconnect()  updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in  app.js  we run:  function removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}  And in  server.js  we update the collections in  /api-sessions/remove-user :  app.post('/api-sessions/remove-user', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionName;\n    var token = req.body.token;\n\n    // If the session exists\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        mySession.getSessionId(function (sessionId) {\n            var tokens = mapSessionIdTokens[sessionId];\n            if (tokens) {\n                var index = tokens.indexOf(token);\n\n                // If the token exists\n                if (index !== -1) {\n                    // Token removed!\n                    tokens.splice(index, 1);\n                } else {\n                    var msg = 'Problems in the app server: the TOKEN wasn\\'t valid';\n                    res.status(500).send(msg);\n                }\n                if (mapSessionIdTokens[sessionId].length == 0) {\n                    // Last user left: session must be removed\n                    delete mapSessionNameSession[sessionName];\n                }\n                res.status(200).send();\n            } else {\n                var msg = 'Problems in the app server: the SESSIONID wasn\\'t valid';\n                res.status(500).send(msg);\n            }\n        });\n    } else {\n        var msg = 'Problems in the app server: the SESSION does not exist';\n        res.status(500).send(msg);\n    }  When the last user leaves the session  delete mapSessionNameSession[sessionName]  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/", 
            "text": "openvidu-mvc-node\n\n\n Check it on GitHub\n\n\nA secure OpenVidu sample app with a Node backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to \nopenvidu-js-node\n. This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. \nEmbedded JavaScript\n is the template engine of choice for this tutorial.\n\n\nUnderstanding this tutorial\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-node-client\n: NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-node-client\n to get this sample app working\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need \nnode\n and \nNPM\n to execute the app. You can install them with:\n\n\nsudo apt-get install nodejs\nsudo apt-get install npm\n\n\n\n\n3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute \nserver.js\n server passing two arguments: \"localhost:8443\" as the URL where \nopenvidu-server\n will be listening and \"MY_SECRET\" as the secret share with it:\n\n\ncd openvidu-tutorials/openvidu-mvc-node\nnpm install\nnode server.js localhost:8443 MY_SECRET\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with \nexpress\n that serves HTML files with a MVC approach, building the templates with the help of \nEmbedded JavaScript\n.\n\n\nOpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nexpress-session\n API.\n\n\n\n\n\n\nBackend\n: node server\n\n\n\n\nserver.js\n : single file which handles all operations of server. It returns HTML templates as response to HTTP requests.\n\n\n\n\n\n\n\n\nFrontend templates\n: Pure JS/HTML/CSS files served by the backend, with \n.ejs\n extension to support Embedded JavaScript (\n/views\n folder)\n\n\n\n\nindex.ejs\n : template with the login form\n\n\ndashboard.ejs\n : template with the form to join a video-call\n\n\nsession.ejs\n : template of the video-call itself\n\n\n\n\n\n\n\n\nFrontend static files\n (\n/public\n folder)\n\n\n\n\nopenvidu-browser-VERSION.js\n : openvidu-browser library. You don't have to manipulate this file\n\n\nstyle.css\n : some CSS classes to style the templates\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nAt path \n/\n a login form will be displayed:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/dashboard\n whenever \"Log in\" button is clicked, passing the username and the password:\n\n\nform class=\nform-group jumbotron\n action=\n/dashboard\n method=\npost\n\n    \np\n\n        \nlabel\nUser\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nuser\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nPass\n/label\n\n        \ninput class=\nform-control\n type=\npassword\n name=\npass\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-info\n type=\nsubmit\nLog in\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nserver.js\n at \n/dashboard\n first checks if the user is already logged (maybe he has just refreshed \n/dashboard\n page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new \nexpress-session\n for the newly logged user (adding a \nloggedUser\n property with its username in the \nreq.session\n object). Finally it returns \ndashboard.ejs\n template:\n\n\napp.post('/dashboard', dashboardController);\napp.get('/dashboard', dashboardController);\n\nfunction dashboardController(req, res) {\n\n    // Check if the user is already logged in\n    if (isLogged(req.session)) {\n        // User is already logged. Immediately return dashboard\n        user = req.session.loggedUser;\n        res.render('dashboard.ejs', {\n            user: user\n        });\n    } else {\n        // User wasn't logged and wants to\n\n        // Retrieve params from POST body\n        var user = req.body.user;\n        var pass = req.body.pass;\n\n        if (login(user, pass)) { // Correct user-pass\n            // Validate session and return OK \n            // Value stored in req.session allows us to identify the user in future requests\n            req.session.loggedUser = user;\n            res.render('dashboard.ejs', {\n                user: user\n            });\n        } else { // Wrong user-pass\n            // Invalidate session and return index template\n            req.session.destroy();\n            res.redirect('/');\n        }\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\ndashboard.ejs\n template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/session\n whenever \"Join!\" button is clicked, passing the nickname and the session name:\n\n\nform class=\nform-group\n action=\n/session\n method=\npost\n\n    \np\n\n        \nlabel\nParticipant\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\ndata\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nSession\n/label\n\n        \ninput class=\nform-control\n type=\ntext\n name=\nsessionname\n required=\ntrue\n/input\n\n    \n/p\n\n    \np class=\ntext-center\n\n        \nbutton class=\nbtn btn-lg btn-success\n type=\nsubmit\nJoin!\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nWhen \nserver.js\n receives a request at \n/session\n path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:\n\n\n// Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};\n\n\n\n\nRest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: \ntokenOptions\n.\n\n\napp.post('/session', (req, res) =\n {\n    // Check the user is logged ... \n\n    // The nickname sent by the client\n    var clientData = req.body.data;\n    // The video-call to connect (\nTUTORIAL\n)\n    var sessionName = req.body.sessionname;\n\n    // Role associated to this user\n    var role = users.find(u =\n (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = '{\nserverData\n: \n' + req.session.loggedUser + '\n}';\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = new TokenOptions.Builder()\n        .data(serverData)\n        .role(role)\n        .build();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exist? \n\n\nif (mapSessionNameSession[sessionName]) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse { // New session: return a new sessionId and a new token\n\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: sessionId,\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        });\n    });\n}\n\n\n\n\nWe are almost there! Now in \nsession.ejs\n JavaScript code (preceded by a tag \nscript\n) we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// Get all the attributes from the template in EJS style\nvar sessionId = \n%- JSON.stringify(sessionId) %\n;\nvar token = \n%- JSON.stringify(token) %\n;\nvar nickName = \n%- JSON.stringify(nickName) %\n;\nvar userName = \n%- JSON.stringify(userName) %\n;\nvar sessionName = \n%- JSON.stringify(sessionName) %\n;\n\n\n\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new HTML element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{\nclientData\n: \n' + nickName + '\n}', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nserver.js\n executes controller at \n/api-sessions/get-sessionid-token\n. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        mySession.getSessionId(function (sessionId) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: sessionId,\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        });\n    });\n}\n\n\n\n\nThe code executed in \nsession.ejs\n \n script \n tag would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nsession.disconnect()\n (triggered in \nleaveSession()\n \nonclick\n method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.\n\n\nIn \nsession.ejs\n template the \"Leave session\" button actually performs a POST operation to path \n/leave-session\n with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the \nleaveSession()\n method. First updates our backend. Second updates our openvidu-server.\n\n\nform action=\n/leave-session\n method=\npost\n\n    \ninput style=\ndisplay:none\n name=\nsessionname\n value=\n%= sessionName %\n/input\n\n    \ninput style=\ndisplay:none\n name=\ntoken\n value=\n%= token %\n/input\n\n    \nbutton id=\nbuttonLeaveSession\n class=\nbtn btn-large btn-danger\n type=\nsubmit\n onclick=\nleaveSession()\n\n        Leave session\n/button\n\n\n/form\n\n\n\n\n\nIn \nserver.js\n we update the collections at \n/leave-session\n:\n\n\napp.post('/leave-session', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionname;\n    var token = req.body.token;\n\n    // If the session exists\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        mySession.getSessionId(function (sessionId) {\n            var tokens = mapSessionIdTokens[sessionId];\n            if (tokens) {\n                var index = tokens.indexOf(token);\n\n                // If the token exists\n                if (index !== -1) {\n                    // Token removed!\n                    tokens.splice(index, 1);\n                } else {\n                    var msg = 'Problems in the app server: the TOKEN wasn\\'t valid';\n                    res.redirect('/dashboard');\n                }\n                if (mapSessionIdTokens[sessionId].length == 0) {\n                    // Last user left: session must be removed\n                    console.log(sessionName + ' empty!');\n                    delete mapSessionNameSession[sessionName];\n                }\n                res.redirect('/dashboard');\n            } else {\n                var msg = 'Problems in the app server: the SESSIONID wasn\\'t valid';\n                res.redirect('/dashboard');\n            }\n        });\n    } else {\n        var msg = 'Problems in the app server: the SESSION does not exist';\n        res.redirect('/dashboard');\n    }\n\n\n\n\nWhen the last user leaves the session \ndelete mapSessionNameSession[sessionName]\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-mvc-node"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#openvidu-mvc-node", 
            "text": "Check it on GitHub  A secure OpenVidu sample app with a Node backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to  openvidu-js-node . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends.  Embedded JavaScript  is the template engine of choice for this tutorial.", 
            "title": "openvidu-mvc-node"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#understanding-this-tutorial", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-node-client : NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-node-client  to get this sample app working", 
            "title": "Understanding this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need  node  and  NPM  to execute the app. You can install them with:  sudo apt-get install nodejs\nsudo apt-get install npm  3) Run the tutorial with the following commands. They will install the NPM dependencies and will execute  server.js  server passing two arguments: \"localhost:8443\" as the URL where  openvidu-server  will be listening and \"MY_SECRET\" as the secret share with it:  cd openvidu-tutorials/openvidu-mvc-node\nnpm install\nnode server.js localhost:8443 MY_SECRET  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple JS/HTML/CSS frontend and a straightforward Node backend built with  express  that serves HTML files with a MVC approach, building the templates with the help of  Embedded JavaScript .  OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  express-session  API.    Backend : node server   server.js  : single file which handles all operations of server. It returns HTML templates as response to HTTP requests.     Frontend templates : Pure JS/HTML/CSS files served by the backend, with  .ejs  extension to support Embedded JavaScript ( /views  folder)   index.ejs  : template with the login form  dashboard.ejs  : template with the form to join a video-call  session.ejs  : template of the video-call itself     Frontend static files  ( /public  folder)   openvidu-browser-VERSION.js  : openvidu-browser library. You don't have to manipulate this file  style.css  : some CSS classes to style the templates     Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#1-user-logs-in", 
            "text": "At path  /  a login form will be displayed:  \n     The form will execute a POST operation to path  /dashboard  whenever \"Log in\" button is clicked, passing the username and the password:  form class= form-group jumbotron  action= /dashboard  method= post \n     p \n         label User /label \n         input class= form-control  type= text  name= user  required= true /input \n     /p \n     p \n         label Pass /label \n         input class= form-control  type= password  name= pass  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-info  type= submit Log in /button \n     /p  /form   server.js  at  /dashboard  first checks if the user is already logged (maybe he has just refreshed  /dashboard  page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new  express-session  for the newly logged user (adding a  loggedUser  property with its username in the  req.session  object). Finally it returns  dashboard.ejs  template:  app.post('/dashboard', dashboardController);\napp.get('/dashboard', dashboardController);\n\nfunction dashboardController(req, res) {\n\n    // Check if the user is already logged in\n    if (isLogged(req.session)) {\n        // User is already logged. Immediately return dashboard\n        user = req.session.loggedUser;\n        res.render('dashboard.ejs', {\n            user: user\n        });\n    } else {\n        // User wasn't logged and wants to\n\n        // Retrieve params from POST body\n        var user = req.body.user;\n        var pass = req.body.pass;\n\n        if (login(user, pass)) { // Correct user-pass\n            // Validate session and return OK \n            // Value stored in req.session allows us to identify the user in future requests\n            req.session.loggedUser = user;\n            res.render('dashboard.ejs', {\n                user: user\n            });\n        } else { // Wrong user-pass\n            // Invalidate session and return index template\n            req.session.destroy();\n            res.redirect('/');\n        }\n    }\n}", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#2-user-connects-to-tutorial-video-call", 
            "text": "dashboard.ejs  template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:  \n     The form will execute a POST operation to path  /session  whenever \"Join!\" button is clicked, passing the nickname and the session name:  form class= form-group  action= /session  method= post \n     p \n         label Participant /label \n         input class= form-control  type= text  name= data  required= true /input \n     /p \n     p \n         label Session /label \n         input class= form-control  type= text  name= sessionname  required= true /input \n     /p \n     p class= text-center \n         button class= btn btn-lg btn-success  type= submit Join! /button \n     /p  /form   When  server.js  receives a request at  /session  path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:  // Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};  Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on:  tokenOptions .  app.post('/session', (req, res) =  {\n    // Check the user is logged ... \n\n    // The nickname sent by the client\n    var clientData = req.body.data;\n    // The video-call to connect ( TUTORIAL )\n    var sessionName = req.body.sessionname;\n\n    // Role associated to this user\n    var role = users.find(u =  (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = '{ serverData :  ' + req.session.loggedUser + ' }';\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = new TokenOptions.Builder()\n        .data(serverData)\n        .role(role)\n        .build();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exist?   if (mapSessionNameSession[sessionName]) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else { // New session: return a new sessionId and a new token\n\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: sessionId,\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        });\n    });\n}  We are almost there! Now in  session.ejs  JavaScript code (preceded by a tag  script ) we can init a new Session with  sessionId  and connect to it with  token :  // Get all the attributes from the template in EJS style\nvar sessionId =  %- JSON.stringify(sessionId) % ;\nvar token =  %- JSON.stringify(token) % ;\nvar nickName =  %- JSON.stringify(nickName) % ;\nvar userName =  %- JSON.stringify(userName) % ;\nvar sessionName =  %- JSON.stringify(sessionName) % ;  // --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'video-container' id\n    var subscriber = session.subscribe(event.stream, 'video-container');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new HTML element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{ clientData :  ' + nickName + ' }', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('video-container', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // When our HTML video has been added to DOM...\n            publisher.on('videoElementCreated', function (event) {\n                // Init the main video with ours and append our data\n                var userData = {\n                    nickName: nickName,\n                    userName: userName\n                };\n                initMainVideo(event.element, userData);\n                appendUserData(event.element, userData);\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n            initMainVideoThumbnail(); // Show SUBSCRIBER message in main video\n        }\n    } else {\n        console.warn('There was an error connecting to the session:', error.code, error.message);\n    }\n});  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  server.js  executes controller at  /api-sessions/get-sessionid-token . Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        mySession.getSessionId(function (sessionId) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: sessionId,\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        });\n    });\n}  The code executed in  session.ejs    script   tag would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  session.disconnect()  (triggered in  leaveSession()   onclick  method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.  In  session.ejs  template the \"Leave session\" button actually performs a POST operation to path  /leave-session  with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the  leaveSession()  method. First updates our backend. Second updates our openvidu-server.  form action= /leave-session  method= post \n     input style= display:none  name= sessionname  value= %= sessionName % /input \n     input style= display:none  name= token  value= %= token % /input \n     button id= buttonLeaveSession  class= btn btn-large btn-danger  type= submit  onclick= leaveSession() \n        Leave session /button  /form   In  server.js  we update the collections at  /leave-session :  app.post('/leave-session', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionname;\n    var token = req.body.token;\n\n    // If the session exists\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        mySession.getSessionId(function (sessionId) {\n            var tokens = mapSessionIdTokens[sessionId];\n            if (tokens) {\n                var index = tokens.indexOf(token);\n\n                // If the token exists\n                if (index !== -1) {\n                    // Token removed!\n                    tokens.splice(index, 1);\n                } else {\n                    var msg = 'Problems in the app server: the TOKEN wasn\\'t valid';\n                    res.redirect('/dashboard');\n                }\n                if (mapSessionIdTokens[sessionId].length == 0) {\n                    // Last user left: session must be removed\n                    console.log(sessionName + ' empty!');\n                    delete mapSessionNameSession[sessionName];\n                }\n                res.redirect('/dashboard');\n            } else {\n                var msg = 'Problems in the app server: the SESSIONID wasn\\'t valid';\n                res.redirect('/dashboard');\n            }\n        });\n    } else {\n        var msg = 'Problems in the app server: the SESSION does not exist';\n        res.redirect('/dashboard');\n    }  When the last user leaves the session  delete mapSessionNameSession[sessionName]  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.     \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/", 
            "text": "openvidu-getaroom\n\n\n Check it on GitHub\n\n\nThis demo allows users to connect to a room and share the link with others, so they can connect to it straight away just by visiting that link. It is a pure frontend application and it makes use of OpenVidu the same way \nopenvidu-insecure-js\n does.\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flows transmission\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n to get this sample app working.\n\n\n\n\nRunning this tutorial\n\n\n1) Clone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n2) You will need an http web server installed in your development computer to execute the sample application. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n3) Run the tutorial:\n\n\nhttp-server openvidu-tutorials/openvidu-getaroom/web\n\n\n\n\n4) \nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n5) Go to \nlocalhost:8080\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nTo learn \nsome tips\n to develop with OpenVidu, check this \nFAQ\n\n\nIf you are using \nWindows\n, read this \nFAQ\n to properly run the tutorial\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n        \n\n    \n\n    \n\n        \n\n            \n\n        \n\n    \n\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nopenvidu-browser-VERSION.js\n: openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n: sample application main JavaScritp file, which makes use of \nopenvidu-browser-VERSION.js\n. You can manipulate this file to suit your needs.\n\n\n\n\nindex.html\n: HTML code for the welcome page to join a new room and for the room itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files: \n\n\nscript src=\"openvidu-browser-VERSION.js.js\"\n/script\n\n\nscript src=\"app.js\"\n/script\n\n\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n. You can manipulate this file to suit your needs. \nindex.html\n uses also Bootstrap as its main style framework.\n\n\n\n\n\n\nDown below we will describe the most important code snippets in \napp.js\n:\n\n\n\n\nDeclaration of variables\n\n\nWe will need some variables accesible from differents methods\n\n\nvar OV;                     // OpenVidu object to initialize a session\nvar session;                // Session object where the user will connect\nvar publisher;              // Publisher object which the user will publish\nvar sessionId;              // Unique identifier of the session\nvar audioEnabled = true;    // True if the audio track of publisher is active\nvar videoEnabled = true;    // True if the video track of publisher is active\nvar numOfVideos = 0;        // Keeps track of the number of videos that are being shown\n\n\n\n\n\n\nWindow callbacks\n\n\nOn \nload\n we will check if the user is connecting to an existing room or to a new one depending on the browser's location, on \nbeforeunload\n we will disconnect the user from the room\n\n\n// Check if the URL already has a room\nwindow.addEventListener('load', function () {\n    sessionId = window.location.hash; // For 'https://myurl/#roomId', sessionId would be '#roomId'\n    if (sessionId) {\n        // The URL has a session id. Join the room right away\n        showSessionHideJoin();\n        joinRoom(sessionId);\n    } else {\n        // The URL has not a session id. Show welcome page\n        showJoinHideSession();\n    }\n});\n\n// Disconnect participant on browser's window closed\nwindow.addEventListener('beforeunload', function () {\n    session.disconnect();\n});\n\n\n\n\n\n\njoinRoom\n method\n\n\nHere we initialize our session and set the events we need for the desired behaviuor. Then we connect to it and finally publish our own webcam to the session.\n\n\nfunction joinRoom(sessionId) {\n\n    if (!sessionId) {\n        // If the user is joining to a new room\n        sessionId = '#' + randomString();\n    }\n\n    // As insecure OpenVidu, the user's token can be a random string\n    var userId = randomString();\n\n    // --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n    OV = new OpenVidu();\n\n    // We will join the video-call \nsessionId\n. As there's no server, this parameter must start with the URL of \n    // OpenVidu Server (with secure websocket protocol: \nwss://\n) and must include the OpenVidu secret at the end\n    session = OV.initSession(\nwss://\n + location.hostname + \n:8443/\n + sessionId + \n?secret=MY_SECRET\n);\n\n\n    // --- 2) Specify the actions when events take place ---\n\n    // On every new Stream received...\n    session.on('streamCreated', function (event) {\n        // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id\n        var subscriber = session.subscribe(event.stream, 'videos');\n        // When the new video is added to DOM, update the page layout to fit one more participant\n        subscriber.on('videoElementCreated', function (event) {\n            numOfVideos++;\n            updateLayout();\n        });\n    });\n\n    // On every new Stream destroyed...\n    session.on('streamDestroyed', function (event) {\n        // Update the page layout\n        numOfVideos--;\n        updateLayout();\n    });\n\n\n    // --- 3) Connect to the session ---\n\n    // Remember 'userId' param (usually called 'token') is irrelevant when using the insecure version of OpenVidu\n    session.connect(userId, function (error) {\n\n        // If the connection is successful, initialize a publisher and publish to the session\n        if (!error) {\n\n            // --- 4) Get your own camera stream with the desired resolution ---\n\n            publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            publisher.on('videoElementCreated', function (event) {\n                // When your own video is added to DOM, update the page layout to fit it\n                numOfVideos++;\n                updateLayout();\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        }\n    });\n\n    // Update the URL shown in the browser's navigation bar to show the session id\n    var pathname = (location.pathname.slice(-1) === \n/\n ? location.pathname : location.pathname+\n/\n);\n    window.history.pushState(\n, \n, pathname + sessionId);\n\n    // Auxiliary methods to show the session's view\n    showSessionHideJoin();\n    initializeSessionView();\n\n    return false;\n}\n\n\n\n\n\n\nleaveRoom\n method\n\n\nfunction leaveRoom() {\n\n    // --- 6) Leave the session by calling 'disconnect' method over the Session object ---\n    session.disconnect();\n\n    // Back to welcome page\n    window.location.href = window.location.origin + window.location.pathname;\n}\n\n\n\n\n\n\n\n\n\n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "openvidu-getaroom"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/#openvidu-getaroom", 
            "text": "Check it on GitHub  This demo allows users to connect to a room and share the link with others, so they can connect to it straight away just by visiting that link. It is a pure frontend application and it makes use of OpenVidu the same way  openvidu-insecure-js  does.  \n     OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flows transmission    You will only have to make use of  openvidu-browser  to get this sample app working.", 
            "title": "openvidu-getaroom"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/#running-this-tutorial", 
            "text": "1) Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git  2) You will need an http web server installed in your development computer to execute the sample application. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server  3) Run the tutorial:  http-server openvidu-tutorials/openvidu-getaroom/web  4)  openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  5) Go to  localhost:8080  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.    To learn  some tips  to develop with OpenVidu, check this  FAQ  If you are using  Windows , read this  FAQ  to properly run the tutorial", 
            "title": "Running this tutorial"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   openvidu-browser-VERSION.js : openvidu-browser library. You don't have to manipulate this file.   app.js : sample application main JavaScritp file, which makes use of  openvidu-browser-VERSION.js . You can manipulate this file to suit your needs.   index.html : HTML code for the welcome page to join a new room and for the room itself. You can manipulate this file to suit your needs. It has two links to both JavaScript files:   script src=\"openvidu-browser-VERSION.js.js\" /script  script src=\"app.js\" /script     style.css : some CSS classes to style  index.html . You can manipulate this file to suit your needs.  index.html  uses also Bootstrap as its main style framework.    Down below we will describe the most important code snippets in  app.js :", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/#declaration-of-variables", 
            "text": "We will need some variables accesible from differents methods  var OV;                     // OpenVidu object to initialize a session\nvar session;                // Session object where the user will connect\nvar publisher;              // Publisher object which the user will publish\nvar sessionId;              // Unique identifier of the session\nvar audioEnabled = true;    // True if the audio track of publisher is active\nvar videoEnabled = true;    // True if the video track of publisher is active\nvar numOfVideos = 0;        // Keeps track of the number of videos that are being shown", 
            "title": "Declaration of variables"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/#window-callbacks", 
            "text": "On  load  we will check if the user is connecting to an existing room or to a new one depending on the browser's location, on  beforeunload  we will disconnect the user from the room  // Check if the URL already has a room\nwindow.addEventListener('load', function () {\n    sessionId = window.location.hash; // For 'https://myurl/#roomId', sessionId would be '#roomId'\n    if (sessionId) {\n        // The URL has a session id. Join the room right away\n        showSessionHideJoin();\n        joinRoom(sessionId);\n    } else {\n        // The URL has not a session id. Show welcome page\n        showJoinHideSession();\n    }\n});\n\n// Disconnect participant on browser's window closed\nwindow.addEventListener('beforeunload', function () {\n    session.disconnect();\n});", 
            "title": "Window callbacks"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/#joinroom-method", 
            "text": "Here we initialize our session and set the events we need for the desired behaviuor. Then we connect to it and finally publish our own webcam to the session.  function joinRoom(sessionId) {\n\n    if (!sessionId) {\n        // If the user is joining to a new room\n        sessionId = '#' + randomString();\n    }\n\n    // As insecure OpenVidu, the user's token can be a random string\n    var userId = randomString();\n\n    // --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n    OV = new OpenVidu();\n\n    // We will join the video-call  sessionId . As there's no server, this parameter must start with the URL of \n    // OpenVidu Server (with secure websocket protocol:  wss:// ) and must include the OpenVidu secret at the end\n    session = OV.initSession( wss://  + location.hostname +  :8443/  + sessionId +  ?secret=MY_SECRET );\n\n\n    // --- 2) Specify the actions when events take place ---\n\n    // On every new Stream received...\n    session.on('streamCreated', function (event) {\n        // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id\n        var subscriber = session.subscribe(event.stream, 'videos');\n        // When the new video is added to DOM, update the page layout to fit one more participant\n        subscriber.on('videoElementCreated', function (event) {\n            numOfVideos++;\n            updateLayout();\n        });\n    });\n\n    // On every new Stream destroyed...\n    session.on('streamDestroyed', function (event) {\n        // Update the page layout\n        numOfVideos--;\n        updateLayout();\n    });\n\n\n    // --- 3) Connect to the session ---\n\n    // Remember 'userId' param (usually called 'token') is irrelevant when using the insecure version of OpenVidu\n    session.connect(userId, function (error) {\n\n        // If the connection is successful, initialize a publisher and publish to the session\n        if (!error) {\n\n            // --- 4) Get your own camera stream with the desired resolution ---\n\n            publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            publisher.on('videoElementCreated', function (event) {\n                // When your own video is added to DOM, update the page layout to fit it\n                numOfVideos++;\n                updateLayout();\n                $(event.element).prop('muted', true); // Mute local video\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.log('There was an error connecting to the session:', error.code, error.message);\n        }\n    });\n\n    // Update the URL shown in the browser's navigation bar to show the session id\n    var pathname = (location.pathname.slice(-1) ===  /  ? location.pathname : location.pathname+ / );\n    window.history.pushState( ,  , pathname + sessionId);\n\n    // Auxiliary methods to show the session's view\n    showSessionHideJoin();\n    initializeSessionView();\n\n    return false;\n}", 
            "title": "joinRoom method"
        }, 
        {
            "location": "/tutorials/openvidu-getaroom/#leaveroom-method", 
            "text": "function leaveRoom() {\n\n    // --- 6) Leave the session by calling 'disconnect' method over the Session object ---\n    session.disconnect();\n\n    // Back to welcome page\n    window.location.href = window.location.origin + window.location.pathname;\n}    \n  $().fancybox({\n    selector : '[data-fancybox=\"gallery\"]',\n    infobar : true,\n    arrows : false,\n    loop: true,\n    protect: true,\n    transitionEffect: 'slide',\n    buttons : [\n        'close'\n    ],\n    clickOutside : 'close',\n    clickSlide   : 'close',\n  });", 
            "title": "leaveRoom method"
        }, 
        {
            "location": "/how-do-i/create-session/", 
            "text": "Create a session\n\n\nYou must get an \nOpenVidu\n object and call \ninitSession\n method. This must receive just one string parameter: the \nsessionID\n, which unambiguously identify your session:\n\n\n\n\n\n\nIf you have a server-side, you should ask for the \nsessionId\n to OpenVidu Server (thanks to the \nREST API\n, \nopenvidu-java-client\n or \nopenvidu-node-client\n) and return it to the client to use it on \ninitSession\n method.\n\n\n\n\n\n\nIf you don't have a server side, you willl have to build \nsessionId\n param by yourself with the following format (this is not recommended for production as the secret must be hardcoded in your JavaScript code):\n\n\n\n\n\n\n\"wss://\"\n + \nOPENVIDU_IP\n + \n\":8443/\"\n + \nSESSION_IDENTIFIER\n + \n\"?secret=\"\n + \nOPENVIDU_SECRET\n\n\n\n// Get sessionId by asking OpenVidu Server from your application server\n// and then returning it here or generate it by your own with the format above\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);", 
            "title": "Create a session"
        }, 
        {
            "location": "/how-do-i/create-session/#create-a-session", 
            "text": "You must get an  OpenVidu  object and call  initSession  method. This must receive just one string parameter: the  sessionID , which unambiguously identify your session:    If you have a server-side, you should ask for the  sessionId  to OpenVidu Server (thanks to the  REST API ,  openvidu-java-client  or  openvidu-node-client ) and return it to the client to use it on  initSession  method.    If you don't have a server side, you willl have to build  sessionId  param by yourself with the following format (this is not recommended for production as the secret must be hardcoded in your JavaScript code):    \"wss://\"  +  OPENVIDU_IP  +  \":8443/\"  +  SESSION_IDENTIFIER  +  \"?secret=\"  +  OPENVIDU_SECRET  // Get sessionId by asking OpenVidu Server from your application server\n// and then returning it here or generate it by your own with the format above\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);", 
            "title": "Create a session"
        }, 
        {
            "location": "/how-do-i/join-session/", 
            "text": "Join a session\n\n\nBy calling \nsession.connect\n method you can join a properly initialized session.\n\n\nsession.connect(token, function(error) {...});\n\n\n\n\n\n\n\n\nIf you have a server-side, you should ask for a user's \ntoken\n to OpenVidu Server (thanks to the \nREST API\n, \nopenvidu-java-client\n or \nopenvidu-node-client\n) and return it to the client to use it on \nconnect\n method.\n\n\n\n\n\n\nIf you don't have a server side, \ntoken\n value is completely irrelevant, so it can be undefined or null.\n\n\n\n\n\n\nYou can add an optional second parameter to pass some user metadata that will be recieved by every other user connected to the same session (check \nShare data between users\n to learn more).\n\n\nsession.connect(token, DATA, function(error) {...});", 
            "title": "Join a session"
        }, 
        {
            "location": "/how-do-i/join-session/#join-a-session", 
            "text": "By calling  session.connect  method you can join a properly initialized session.  session.connect(token, function(error) {...});    If you have a server-side, you should ask for a user's  token  to OpenVidu Server (thanks to the  REST API ,  openvidu-java-client  or  openvidu-node-client ) and return it to the client to use it on  connect  method.    If you don't have a server side,  token  value is completely irrelevant, so it can be undefined or null.    You can add an optional second parameter to pass some user metadata that will be recieved by every other user connected to the same session (check  Share data between users  to learn more).  session.connect(token, DATA, function(error) {...});", 
            "title": "Join a session"
        }, 
        {
            "location": "/how-do-i/leave-session/", 
            "text": "Leave a session\n\n\nBy calling \nsession.disconnect\n method you can leave the session.\n\n\nsession.disconnect();\n\n\n\n\nsessionDisconnected\n event will be triggered by \nsession\n object. The default behaviour is the deletion of all HTML video elements associated to this particular session. To avoid this, call \nevent.preventDefault()\n method:\n\n\nsession.on('sessionDisconnected', function (event) {\n    event.preventDefault();\n    // Do wahtever you want when the user leaves the session\n});", 
            "title": "Leave a session"
        }, 
        {
            "location": "/how-do-i/leave-session/#leave-a-session", 
            "text": "By calling  session.disconnect  method you can leave the session.  session.disconnect();  sessionDisconnected  event will be triggered by  session  object. The default behaviour is the deletion of all HTML video elements associated to this particular session. To avoid this, call  event.preventDefault()  method:  session.on('sessionDisconnected', function (event) {\n    event.preventDefault();\n    // Do wahtever you want when the user leaves the session\n});", 
            "title": "Leave a session"
        }, 
        {
            "location": "/how-do-i/subscribe-unsubscribe/", 
            "text": "Subscribe/Unsubscribe from other user's stream\n\n\nTo receive the stream of a publisher of the session:\n\n\nvar subscriber;\n\nsession.on('streamCreated', function(event) {\n    subscriber = session.subscribe(event.stream, 'html-id');\n});\n\n\n\n\nA new HTML video element will be appended to DOM inside the element with id \nhtml-id\n. If you prefer to manage the stream object by yourself, you can always get its \nMediaStream\n property to insert it on any \nHTMLMediaElement\n as its \nsrcObject\n (such as a \nvideo\n element). For example:\n\n\nsession.on('streamCreated', function(event) {\n    subscriber = session.subscribe(event.stream, ''); // Empty html id\n    var video = document.getElementById('myVideoElement'); \n    video.srcObject = event.stream.getMediaStream();\n});\n\n\n\n\nTo cancel the subscription and stop receiving media:\n\n\nsession.unsubscribe(subscriber);\n\n\n\n\nAs long as you have the Subscriber object available, you can alternately call \nSession.subscribe\n and \nSession.unsubscribe\n as many times as you want.", 
            "title": "Subscribe/Unsubscribe from a stream"
        }, 
        {
            "location": "/how-do-i/subscribe-unsubscribe/#subscribeunsubscribe-from-other-users-stream", 
            "text": "To receive the stream of a publisher of the session:  var subscriber;\n\nsession.on('streamCreated', function(event) {\n    subscriber = session.subscribe(event.stream, 'html-id');\n});  A new HTML video element will be appended to DOM inside the element with id  html-id . If you prefer to manage the stream object by yourself, you can always get its  MediaStream  property to insert it on any  HTMLMediaElement  as its  srcObject  (such as a  video  element). For example:  session.on('streamCreated', function(event) {\n    subscriber = session.subscribe(event.stream, ''); // Empty html id\n    var video = document.getElementById('myVideoElement'); \n    video.srcObject = event.stream.getMediaStream();\n});  To cancel the subscription and stop receiving media:  session.unsubscribe(subscriber);  As long as you have the Subscriber object available, you can alternately call  Session.subscribe  and  Session.unsubscribe  as many times as you want.", 
            "title": "Subscribe/Unsubscribe from other user's stream"
        }, 
        {
            "location": "/how-do-i/publish-unpublish/", 
            "text": "Publish/Unpublish a stream\n\n\nYou can publish a stream after joining a session: get a \nPublisher\n object through OpenVidu object (\nOpenVidu.initPublisher\n) and publish it with \nSession\n object.\n\n\n// After joining a session...\n\nvar publisher = OV.initPublisher('html-id');\n// Register all the events you want with 'publisher.on(...)'\nsession.publish(publisher);\n\n\n\n\ninitPublisher\n method will append to DOM a new HTML video element inside the element with id \nhtml-id\n, showing your camera. You can then publish it to the session whenever you want (perhaps you want the user to confirm that his camera is working well before publishing it).\n\n\nYou can add two more parameters to \ninitPublisher\n method: an object with properties about your publisher stream and a callback function to be executed in case any error takes places during publisher initialization:\n\n\nOV.initPublisher(\n    'html-element-id',\n    {\n        audio: true,        // Whether you want to transmit audio or not\n        video: true,        // Whether you want to transmit video or not\n        audioActive: true,  // Whether you want to start the publishing with your audio unmuted or muted\n        videoActive: true,  // Whether you want to start the publishing with your video enabled or disabled\n        quality: 'MEDIUM',  // The quality of your video ('LOW', 'MEDIUM', 'HIGH')\n        screen: false       // true to get your screen as video source instead of your camera\n                            // See 'How do I...?' -\n 'Screen share' section to learn more\n    },\n    function(error) {       // Function to be executed in case the Publisher initialization fails\n        if (error) {\n            console.log('Error while initializing publisher: ', error);\n        }\n    }\n);\n\n\n\n\nTo unpublish the stream:\n\n\nsession.unpublish(publisher);\n\n\n\n\nAs long as you have the Publisher object available, you can alternately call \nSession.publish\n and \nSession.unpublish\n as many times as you want. It is also possible to change the Publisher dynamically (for example if you want to stop transmitting your webcam and start sharing your screen, all of it without leaving the session). To do so:\n\n\nsession.unpublish(oldPubliser);\nnewPublisher = OV.initPublisher(newOptions);\n// Register all the events you want with 'newPublisher.on(...)'\nsession.publish(newPublisher);\n\n\n\n\nIn future updates one user will be able to publish more than one Publisher at once.\n\n\n\n\n\n\nNOTE\n: only users with Role \nPUBLISHER\n or \nMODERATOR\n can call \nSession.publish\n method (see \nOpenViduRole\n section)", 
            "title": "Publish/Unpublish a stream"
        }, 
        {
            "location": "/how-do-i/publish-unpublish/#publishunpublish-a-stream", 
            "text": "You can publish a stream after joining a session: get a  Publisher  object through OpenVidu object ( OpenVidu.initPublisher ) and publish it with  Session  object.  // After joining a session...\n\nvar publisher = OV.initPublisher('html-id');\n// Register all the events you want with 'publisher.on(...)'\nsession.publish(publisher);  initPublisher  method will append to DOM a new HTML video element inside the element with id  html-id , showing your camera. You can then publish it to the session whenever you want (perhaps you want the user to confirm that his camera is working well before publishing it).  You can add two more parameters to  initPublisher  method: an object with properties about your publisher stream and a callback function to be executed in case any error takes places during publisher initialization:  OV.initPublisher(\n    'html-element-id',\n    {\n        audio: true,        // Whether you want to transmit audio or not\n        video: true,        // Whether you want to transmit video or not\n        audioActive: true,  // Whether you want to start the publishing with your audio unmuted or muted\n        videoActive: true,  // Whether you want to start the publishing with your video enabled or disabled\n        quality: 'MEDIUM',  // The quality of your video ('LOW', 'MEDIUM', 'HIGH')\n        screen: false       // true to get your screen as video source instead of your camera\n                            // See 'How do I...?' -  'Screen share' section to learn more\n    },\n    function(error) {       // Function to be executed in case the Publisher initialization fails\n        if (error) {\n            console.log('Error while initializing publisher: ', error);\n        }\n    }\n);  To unpublish the stream:  session.unpublish(publisher);  As long as you have the Publisher object available, you can alternately call  Session.publish  and  Session.unpublish  as many times as you want. It is also possible to change the Publisher dynamically (for example if you want to stop transmitting your webcam and start sharing your screen, all of it without leaving the session). To do so:  session.unpublish(oldPubliser);\nnewPublisher = OV.initPublisher(newOptions);\n// Register all the events you want with 'newPublisher.on(...)'\nsession.publish(newPublisher);  In future updates one user will be able to publish more than one Publisher at once.    NOTE : only users with Role  PUBLISHER  or  MODERATOR  can call  Session.publish  method (see  OpenViduRole  section)", 
            "title": "Publish/Unpublish a stream"
        }, 
        {
            "location": "/how-do-i/mute-audio-video/", 
            "text": "Mute/Unmute audio and video\n\n\nBy calling \npublisher.publishAudio()\n or \npublisher.publishVideo()\n method you can toggle audio and video. For these methods to have effect your Publisher object must have been initialized with \naudio: true\n and \nvideo: true\n respectively (see \nPublish a stream\n section).\n\n\npublisher.publishAudio(audioEnabled);   // true to unmute the audio, false to mute it\npublisher.publishVideo(videoEnabled);   // true to enable the video, false to disable it \n                                        // (a black screen will show up instead)", 
            "title": "Mute/Unmute audio and video"
        }, 
        {
            "location": "/how-do-i/mute-audio-video/#muteunmute-audio-and-video", 
            "text": "By calling  publisher.publishAudio()  or  publisher.publishVideo()  method you can toggle audio and video. For these methods to have effect your Publisher object must have been initialized with  audio: true  and  video: true  respectively (see  Publish a stream  section).  publisher.publishAudio(audioEnabled);   // true to unmute the audio, false to mute it\npublisher.publishVideo(videoEnabled);   // true to enable the video, false to disable it \n                                        // (a black screen will show up instead)", 
            "title": "Mute/Unmute audio and video"
        }, 
        {
            "location": "/how-do-i/share-data/", 
            "text": "Share data between users\n\n\nWhatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places:\n\n\n\n\n\n\nopenvidu-browser\n: when calling \nsession.connect\n method\n\n\nsession.connect(token, DATA, function (error) { ... });\n\n\n\n\n\n\n\nAPI REST\n: when asking for a token to \n/api/tokens\n, you can pass data as third parameter in the BODY of the POST request \n\n\n{\u201csession\u201d: \u201csessionId\u201d, \u201crole\u201d: \u201crole\u201d, \u201cdata\u201d: \"DATA\"}\n\n\n\n\n\n\n\n\n\nJava and Node clients (\nopenvidu-java-client\n and \nopenvidu-node-client\n) allow you to pass data when creating a Token object: \n\n\ntokenOptions = new TokenOptions.Builder().data(\"DATA\").build();\n\n\n\n\nThe result will be that in all clients, \nConnection\n objects will have in their \ndata\n property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be:\n\n\nsession.on('streamCreated', function (event) {\n    session.subscribe(event.stream, 'subscriber');\n    console.log('USER DATA: ' + event.stream.connection.data);\n});\n\n\n\n\nSome clarifications:\n\n\n\n\n\n\nConnection.data\n will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend: \"OPENVIDUBROWSER_DATA%/%APIREST_DATA\" \n\n\n\n\n\n\nUsing only first option is not secure, as clients could modify the value of the second parameter. It is intended only in development environments. If you want total control over shared data, please use the second way.\n\n\n\n\nYou can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice.", 
            "title": "Share data between users"
        }, 
        {
            "location": "/how-do-i/share-data/#share-data-between-users", 
            "text": "Whatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places:    openvidu-browser : when calling  session.connect  method  session.connect(token, DATA, function (error) { ... });    API REST : when asking for a token to  /api/tokens , you can pass data as third parameter in the BODY of the POST request   {\u201csession\u201d: \u201csessionId\u201d, \u201crole\u201d: \u201crole\u201d, \u201cdata\u201d: \"DATA\"}     Java and Node clients ( openvidu-java-client  and  openvidu-node-client ) allow you to pass data when creating a Token object:   tokenOptions = new TokenOptions.Builder().data(\"DATA\").build();   The result will be that in all clients,  Connection  objects will have in their  data  property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be:  session.on('streamCreated', function (event) {\n    session.subscribe(event.stream, 'subscriber');\n    console.log('USER DATA: ' + event.stream.connection.data);\n});  Some clarifications:    Connection.data  will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend: \"OPENVIDUBROWSER_DATA%/%APIREST_DATA\"     Using only first option is not secure, as clients could modify the value of the second parameter. It is intended only in development environments. If you want total control over shared data, please use the second way.   You can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice.", 
            "title": "Share data between users"
        }, 
        {
            "location": "/how-do-i/send-messages/", 
            "text": "Send text messages between users\n\n\n(since \nv1.2.0\n)\n\n\nAny user connected to a session can send messages to every other participant of the session, as a broadcast message for everyone or to one or more specific participants. To do so:\n\n\n// Sender of the message (after calling 'session.connect')\n\nsession.signal({\n        data: 'My custom message',  // Any string (optional)\n        to: [],                     // Array of Connection objects (optional. Broadcast to everyone if empty)\n        type: 'my-chat'             // The type of message (optional)\n    },\n    function (error) {              // Callback for catching errors ('error' is null if success)\n        if (error) {\n            console.log('Error sending signal: ' + error);\n        }\n    }\n);\n\n\n\n\nAny user subscribed to that \ntype\n will receive the message:\n\n\n// Receiver of the message (usually before calling 'session.connect')\n\nsession.on('signal:my-chat', (event) =\n {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message (\nmy-chat\n)\n});\n\n\n\n\nYou can subscribe to \nall signals\n just by calling:\n\n\n// Receiver of all messages (usually before calling 'session.connect')\n\nsession.on('signal', (event) =\n {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message\n});\n\n\n\n\nYou can send messages to specific users adding to \nto\n array the proper Connection objects:\n\n\n// Sender of the message (after calling 'session.connect')\n\nsession.signal({\n    data: 'My private custom message',\n    to: [connection1, connection2],\n    type: 'my-private-chat'\n});\n\n\n\n\nOnly participants represented by \nconnection1\n and \nconnection2\n objects will receive the signal event (only if they are subscribed to it!). You can get Connection objects by subscribing to \nconnectionCreated\n event before connecting to a session:\n\n\nthis.session.on('connectionCreated', (event) =\n {\n    console.log(event.connection);\n});", 
            "title": "Send text messages"
        }, 
        {
            "location": "/how-do-i/send-messages/#send-text-messages-between-users", 
            "text": "(since  v1.2.0 )  Any user connected to a session can send messages to every other participant of the session, as a broadcast message for everyone or to one or more specific participants. To do so:  // Sender of the message (after calling 'session.connect')\n\nsession.signal({\n        data: 'My custom message',  // Any string (optional)\n        to: [],                     // Array of Connection objects (optional. Broadcast to everyone if empty)\n        type: 'my-chat'             // The type of message (optional)\n    },\n    function (error) {              // Callback for catching errors ('error' is null if success)\n        if (error) {\n            console.log('Error sending signal: ' + error);\n        }\n    }\n);  Any user subscribed to that  type  will receive the message:  // Receiver of the message (usually before calling 'session.connect')\n\nsession.on('signal:my-chat', (event) =  {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message ( my-chat )\n});  You can subscribe to  all signals  just by calling:  // Receiver of all messages (usually before calling 'session.connect')\n\nsession.on('signal', (event) =  {\n    console.log(event.data); // Message\n    console.log(event.from); // Connection object of the sender\n    console.log(event.type); // The type of message\n});  You can send messages to specific users adding to  to  array the proper Connection objects:  // Sender of the message (after calling 'session.connect')\n\nsession.signal({\n    data: 'My private custom message',\n    to: [connection1, connection2],\n    type: 'my-private-chat'\n});  Only participants represented by  connection1  and  connection2  objects will receive the signal event (only if they are subscribed to it!). You can get Connection objects by subscribing to  connectionCreated  event before connecting to a session:  this.session.on('connectionCreated', (event) =  {\n    console.log(event.connection);\n});", 
            "title": "Send text messages between users"
        }, 
        {
            "location": "/advanced-features/recording/", 
            "text": "Recording\n\n\n(since \nv1.7.0\n)\n\n\nOpenVidu Server can be configured to record sessions. In the current version 1.7.0, every publisher stream is composed in the same video file in a grid layout.\n\n\nFor example, in a session with two publishers the video file will look like this:\n\n\n\n    \n\n\n\n\n\n\n    \n\n\n\n    This type of grid recording is a pretty heavy consuming process. In order to record sessions and achieve good quality in the resulting videos it is strongly recommended to launch OpenVidu Server in a host with generous computing resources (Multicore >= 1GHz, 16GB of RAM)\n\n\n\n\n\n\n\n\nTo start OpenVidu Server properly configured to allow session recording it is necessary to:\n\n\n1. Have Docker CE installed in the host machine\n\n\nOpenVidu recording module consists of a Docker image that needs to be downloaded from the cloud. The process is \n100% automatic\n, but you will need \nDocker CE\n installed in your server. If you enable OpenVidu recording service but there's no Docker installed, OpenVidu Server will fail to init, throwing the following exception:\n\n\nException connecting to Docker daemon: you need Docker installed in this machine to enable OpenVidu recorder service\n\n\n\n\n\n\nOpenVidu CloudFormation\n already includes the Docker image for recording service. You don't need to install anything or wait during the first execution if you use this type of deployment for OpenVidu Server\n\n\n\n\n2. Launch OpenVidu Server with new environment variables\n\n\n(Only variables related with OpenVidu recording service are stated below. To see a complete list of available environment variables, visit \nOpenVidu Server configuration\n)\n\n\nFor OpenVidu Server JAR\n\n\njava -jar \\\n    -Dopenvidu.recording=true \\\n    -Dopenvidu.recording.path=/path/to/video/files \\\n    -Dopenvidu.recording.free-access=true \\\nopenvidu-server.jar\n\n\n\n\n\n\nopenvidu.recording\n: if \ntrue\n OpenVidu recording service is enabled and sessions can be configured to be recorded. During the first execution of \nopenvidu-server.jar\n, a Docker image (\nopenvidu/openvidu-recording\n) will be downloaded.\n\n\nopenvidu.recording.path\n: where to store the recorded video files on the host machine.\n\n\nopenvidu.recording.free-access\n: if \ntrue\n any client can connect to\nhttps://OPENVIDU_SERVER_IP:OPENVIDU_PORT/recordings/any_session_file.mp4\n and access any recorded video file. If \nfalse\n this path will be secured with \nopenvidu.secret\n param just as OpenVidu Server dashboard at \nhttps://OPENVIDU_SERVER_IP:OPENVIDU_PORT\n\n\n\n\nFor OpenVidu Server Docker image\n\n\nopenvidu/openvidu-server-kms\n\n\ndocker run -p 8443:8443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording=true \\\n    -e MY_UID=$(id -u $USER) \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording.free-access=true \\\nopenvidu/openvidu-server-kms\n\n\n\n\nopenvidu/openvidu-server\n (KMS up and running in the host machine)\n\n\ndocker run --net=\nhost\n -p 8443:8443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording=true \\\n    -e MY_UID=$(id -u $USER) \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording.free-access=true \\\nopenvidu/openvidu-server\n\n\n\n\n\n\nopenvidu.recording\n: \nsame as for OpenVidu Server JAR\n\n\nopenvidu.recording.path\n: \nsame for in OpenVidu Server JAR\n\n\nopenvidu.recording.free-access\n: \nsame as for OpenVidu Server JAR\n\n\n\n\nIt is also necessary to mount 2 volumes and pass \nMY_UID\n variable:\n\n\n\n\n-v /var/run/docker.sock:/var/run/docker.sock\n: gives openvidu-server container access to the local Docker daemon\n\n\n-v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES\n: gives access to the recorded video files through the container\n\n\n-e MY_UID=$(id -u $USER)\n: for permission reasons\n\n\n\n\n\n\n/PATH/TO/VIDEO/FILES\n must be the same in \nopenvidu.recording.path=/PATH/TO/VIDEO/FILES\n property and in\n-v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES\n option if you want to have acces to the video files from outside the container\n\n\n\n\n3. Configure your Sessions to be recorded\n\n\nSetting property \nopenvidu.recording\n to \ntrue\n only automatically enables recordings for insecure sessions (those directly created from the client side. See \nthis FAQ\n and \nthis FAQ\n).\n\n\nIn order to record a regular securized session, it is necessary to explicitly configure it through the \nREST API\n or any of the server clients (\nopenvidu-java-client\n, \nopenvidu-node-client\n). As seen in the API documentation ...\n\n\nAPI REST\n\n\nThe body of the POST request in order to generate a sessionId (\n/api/sessions\n) must be:\n\n\n{\narchiveMode\n: \nALWAYS\n, \narchiveLayout\n: \nBEST_FIT\n, \nmediaMode\n: \nROUTED\n}\n\n\n\n\nopenvidu-java-client\n\n\nCall \nOpenVidu.createSession()\n passing as optional parameter a \nSessionProperties\n object properly configured\n\n\nimport io.openvidu.java.client.ArchiveLayout;\nimport io.openvidu.java.client.ArchiveMode;\nimport io.openvidu.java.client.MediaMode;\nimport io.openvidu.java.client.OpenVidu;\nimport io.openvidu.java.client.Session;\nimport io.openvidu.java.client.SessionProperties;\n\n...\n\nOpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder()\n    .archiveMode(ArchiveMode.ALWAYS)\n    .archiveLayout(ArchiveLayout.BEST_FIT)\n    .mediaMode(MediaMode.ROUTED)\n    .build();\nSession session = openVidu.createSession(properties);\n\n\n\n\nopenvidu-node-client\n\n\nCall \nOpenVidu.createSession()\n passing as optional parameter a \nSessionProperties\n object properly configured\n\n\nvar OpenVidu = require('openvidu-node-client').OpenVidu;\nvar SessionProperties = require('openvidu-node-client').SessionProperties;\nvar ArchiveLayout = require('openvidu-node-client').ArchiveLayout;\nvar ArchiveMode = require('openvidu-node-client').ArchiveMode;\nvar MediaMode = require('openvidu-node-client').MediaMode;\n\n...\n\nvar openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = new SessionProperties.Builder()\n    .archiveLayout(ArchiveLayout.BEST_FIT)\n    .archiveMode(ArchiveMode.MANUAL)\n    .mediaMode(MediaMode.ROUTED)\n    .build();\nvar mySession = openvidu.createSession(properties);\n\n\n\n\n\n\n\nFuture updates\n\n\n\n\n\n\nSingle stream recording\n: right now only grid layout recording is supported, but in the near future it is planned to support single stream recording for each participant publishing to the session. This type of video recording is intended to be much less demanding in terms of computing resources, and will provide developers greater freedom in the later processing of their videos.\n\n\n\n\n\n\nMore grid layouts\n: only \nBEST_FIT\n layout is supported right now, but there are more layouts that will be available in next development iterations.", 
            "title": "Recording"
        }, 
        {
            "location": "/advanced-features/recording/#recording", 
            "text": "(since  v1.7.0 )  OpenVidu Server can be configured to record sessions. In the current version 1.7.0, every publisher stream is composed in the same video file in a grid layout.  For example, in a session with two publishers the video file will look like this:  \n       \n      \n    This type of grid recording is a pretty heavy consuming process. In order to record sessions and achieve good quality in the resulting videos it is strongly recommended to launch OpenVidu Server in a host with generous computing resources (Multicore >= 1GHz, 16GB of RAM)    To start OpenVidu Server properly configured to allow session recording it is necessary to:", 
            "title": "Recording"
        }, 
        {
            "location": "/advanced-features/recording/#1-have-docker-ce-installed-in-the-host-machine", 
            "text": "OpenVidu recording module consists of a Docker image that needs to be downloaded from the cloud. The process is  100% automatic , but you will need  Docker CE  installed in your server. If you enable OpenVidu recording service but there's no Docker installed, OpenVidu Server will fail to init, throwing the following exception:  Exception connecting to Docker daemon: you need Docker installed in this machine to enable OpenVidu recorder service    OpenVidu CloudFormation  already includes the Docker image for recording service. You don't need to install anything or wait during the first execution if you use this type of deployment for OpenVidu Server", 
            "title": "1. Have Docker CE installed in the host machine"
        }, 
        {
            "location": "/advanced-features/recording/#2-launch-openvidu-server-with-new-environment-variables", 
            "text": "(Only variables related with OpenVidu recording service are stated below. To see a complete list of available environment variables, visit  OpenVidu Server configuration )", 
            "title": "2. Launch OpenVidu Server with new environment variables"
        }, 
        {
            "location": "/advanced-features/recording/#for-openvidu-server-jar", 
            "text": "java -jar \\\n    -Dopenvidu.recording=true \\\n    -Dopenvidu.recording.path=/path/to/video/files \\\n    -Dopenvidu.recording.free-access=true \\\nopenvidu-server.jar   openvidu.recording : if  true  OpenVidu recording service is enabled and sessions can be configured to be recorded. During the first execution of  openvidu-server.jar , a Docker image ( openvidu/openvidu-recording ) will be downloaded.  openvidu.recording.path : where to store the recorded video files on the host machine.  openvidu.recording.free-access : if  true  any client can connect to https://OPENVIDU_SERVER_IP:OPENVIDU_PORT/recordings/any_session_file.mp4  and access any recorded video file. If  false  this path will be secured with  openvidu.secret  param just as OpenVidu Server dashboard at  https://OPENVIDU_SERVER_IP:OPENVIDU_PORT", 
            "title": "For OpenVidu Server JAR"
        }, 
        {
            "location": "/advanced-features/recording/#for-openvidu-server-docker-image", 
            "text": "openvidu/openvidu-server-kms  docker run -p 8443:8443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording=true \\\n    -e MY_UID=$(id -u $USER) \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording.free-access=true \\\nopenvidu/openvidu-server-kms  openvidu/openvidu-server  (KMS up and running in the host machine)  docker run --net= host  -p 8443:8443 --rm \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording=true \\\n    -e MY_UID=$(id -u $USER) \\\n    -e openvidu.recording.path=/PATH/TO/VIDEO/FILES \\\n    -e openvidu.recording.free-access=true \\\nopenvidu/openvidu-server   openvidu.recording :  same as for OpenVidu Server JAR  openvidu.recording.path :  same for in OpenVidu Server JAR  openvidu.recording.free-access :  same as for OpenVidu Server JAR   It is also necessary to mount 2 volumes and pass  MY_UID  variable:   -v /var/run/docker.sock:/var/run/docker.sock : gives openvidu-server container access to the local Docker daemon  -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES : gives access to the recorded video files through the container  -e MY_UID=$(id -u $USER) : for permission reasons    /PATH/TO/VIDEO/FILES  must be the same in  openvidu.recording.path=/PATH/TO/VIDEO/FILES  property and in -v /PATH/TO/VIDEO/FILES:/PATH/TO/VIDEO/FILES  option if you want to have acces to the video files from outside the container", 
            "title": "For OpenVidu Server Docker image"
        }, 
        {
            "location": "/advanced-features/recording/#3-configure-your-sessions-to-be-recorded", 
            "text": "Setting property  openvidu.recording  to  true  only automatically enables recordings for insecure sessions (those directly created from the client side. See  this FAQ  and  this FAQ ).  In order to record a regular securized session, it is necessary to explicitly configure it through the  REST API  or any of the server clients ( openvidu-java-client ,  openvidu-node-client ). As seen in the API documentation ...", 
            "title": "3. Configure your Sessions to be recorded"
        }, 
        {
            "location": "/advanced-features/recording/#api-rest", 
            "text": "The body of the POST request in order to generate a sessionId ( /api/sessions ) must be:  { archiveMode :  ALWAYS ,  archiveLayout :  BEST_FIT ,  mediaMode :  ROUTED }", 
            "title": "API REST"
        }, 
        {
            "location": "/advanced-features/recording/#openvidu-java-client", 
            "text": "Call  OpenVidu.createSession()  passing as optional parameter a  SessionProperties  object properly configured  import io.openvidu.java.client.ArchiveLayout;\nimport io.openvidu.java.client.ArchiveMode;\nimport io.openvidu.java.client.MediaMode;\nimport io.openvidu.java.client.OpenVidu;\nimport io.openvidu.java.client.Session;\nimport io.openvidu.java.client.SessionProperties;\n\n...\n\nOpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder()\n    .archiveMode(ArchiveMode.ALWAYS)\n    .archiveLayout(ArchiveLayout.BEST_FIT)\n    .mediaMode(MediaMode.ROUTED)\n    .build();\nSession session = openVidu.createSession(properties);", 
            "title": "openvidu-java-client"
        }, 
        {
            "location": "/advanced-features/recording/#openvidu-node-client", 
            "text": "Call  OpenVidu.createSession()  passing as optional parameter a  SessionProperties  object properly configured  var OpenVidu = require('openvidu-node-client').OpenVidu;\nvar SessionProperties = require('openvidu-node-client').SessionProperties;\nvar ArchiveLayout = require('openvidu-node-client').ArchiveLayout;\nvar ArchiveMode = require('openvidu-node-client').ArchiveMode;\nvar MediaMode = require('openvidu-node-client').MediaMode;\n\n...\n\nvar openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = new SessionProperties.Builder()\n    .archiveLayout(ArchiveLayout.BEST_FIT)\n    .archiveMode(ArchiveMode.MANUAL)\n    .mediaMode(MediaMode.ROUTED)\n    .build();\nvar mySession = openvidu.createSession(properties);", 
            "title": "openvidu-node-client"
        }, 
        {
            "location": "/advanced-features/recording/#future-updates", 
            "text": "Single stream recording : right now only grid layout recording is supported, but in the near future it is planned to support single stream recording for each participant publishing to the session. This type of video recording is intended to be much less demanding in terms of computing resources, and will provide developers greater freedom in the later processing of their videos.    More grid layouts : only  BEST_FIT  layout is supported right now, but there are more layouts that will be available in next development iterations.", 
            "title": "Future updates"
        }, 
        {
            "location": "/advanced-features/screen-share/", 
            "text": "Screen share\n\n\nTo share your screen instead of your webcam, the process is exactly the same as stated in \nPublish a stream\n section, but setting to \ntrue\n \nscreen\n property when initializing a Publisher object:\n\n\nOV.initPublisher('html-element-id', { screen: true });\n\n\n\n\nBoth \nChrome\n and \nFirefox\n support screen sharing.\n\n\nFor \nChrome\n, it is a necessary requirement that the user has an extension installed. If it is not, \ninitPublisher\n will return an error with \nname\n \nSCREEN_EXTENSION_NOT_INSTALLED\n and \nmessage\n the URL of Chrome Web Store where to install the extension. So, a possible approach would be:\n\n\nOV.initPublisher('html-element-id', { screen: true }, function(error) {\n    if (error.name == 'SCREEN_EXTENSION_NOT_INSTALLED') {\n        showWarning(error.message);\n        // showWarning could show a button with href 'error.message',\n        // so the user can navigate to install the extension.\n        // A browser refresh is also needed after installation\n    }\n});\n\n\n\n\nFor \nFirefox\n it is even easier, as it supports native screen capturing since version 52, so no extension is needed (a typical alert telling the user to select the window to share will pop up, similar to camera/microphone permission alert).\n\n\n\n\n\n\nNOTE\n: when testing and developing screen sharing feature, in Chrome it is possible to do so over HTTP in \nhttp://localhost:PORT\n, but in Firefox it is a mandatory requirement to serve your application over HTTPS even though you are connecting through localhost", 
            "title": "Screen share"
        }, 
        {
            "location": "/advanced-features/screen-share/#screen-share", 
            "text": "To share your screen instead of your webcam, the process is exactly the same as stated in  Publish a stream  section, but setting to  true   screen  property when initializing a Publisher object:  OV.initPublisher('html-element-id', { screen: true });  Both  Chrome  and  Firefox  support screen sharing.  For  Chrome , it is a necessary requirement that the user has an extension installed. If it is not,  initPublisher  will return an error with  name   SCREEN_EXTENSION_NOT_INSTALLED  and  message  the URL of Chrome Web Store where to install the extension. So, a possible approach would be:  OV.initPublisher('html-element-id', { screen: true }, function(error) {\n    if (error.name == 'SCREEN_EXTENSION_NOT_INSTALLED') {\n        showWarning(error.message);\n        // showWarning could show a button with href 'error.message',\n        // so the user can navigate to install the extension.\n        // A browser refresh is also needed after installation\n    }\n});  For  Firefox  it is even easier, as it supports native screen capturing since version 52, so no extension is needed (a typical alert telling the user to select the window to share will pop up, similar to camera/microphone permission alert).    NOTE : when testing and developing screen sharing feature, in Chrome it is possible to do so over HTTP in  http://localhost:PORT , but in Firefox it is a mandatory requirement to serve your application over HTTPS even though you are connecting through localhost", 
            "title": "Screen share"
        }, 
        {
            "location": "/advanced-features/speech-detection/", 
            "text": "Speech detection\n\n\n(since \nv1.3.0\n)\n\n\nA pretty common requested event is one that allows you to detect when a publisher starts and stops speaking. OpenVidu offers this ability through two events that can be configured for \nSession\n objects:\n\n\nsession.on('publisherStartSpeaking', (event) =\n {\n    console.log('Publisher ' + event.connection.connectionId + ' start speaking');\n});\n\nsession.on('publisherStopSpeaking', (event) =\n {\n    console.log('Publisher ' + event.connection.connectionId + ' stop speaking');\n});\n\n\n\n\nEvent \npublisherStopSpeaking\n for certain \nConnection\n object can only be triggered after \npublisherStartSpeaking\n has been called for that specific Connection object. In other words, none of these events can be triggered twice in a row for one Connection: they are always launched alternately.\n\n\nWith these events it is really easy to build a layout that can make the main speaker video the bigger one, and alternate the main view between the participants of a session as they take the floor. You can check the complete API reference for these events in \nSession events\n section.", 
            "title": "Speech detection"
        }, 
        {
            "location": "/advanced-features/speech-detection/#speech-detection", 
            "text": "(since  v1.3.0 )  A pretty common requested event is one that allows you to detect when a publisher starts and stops speaking. OpenVidu offers this ability through two events that can be configured for  Session  objects:  session.on('publisherStartSpeaking', (event) =  {\n    console.log('Publisher ' + event.connection.connectionId + ' start speaking');\n});\n\nsession.on('publisherStopSpeaking', (event) =  {\n    console.log('Publisher ' + event.connection.connectionId + ' stop speaking');\n});  Event  publisherStopSpeaking  for certain  Connection  object can only be triggered after  publisherStartSpeaking  has been called for that specific Connection object. In other words, none of these events can be triggered twice in a row for one Connection: they are always launched alternately.  With these events it is really easy to build a layout that can make the main speaker video the bigger one, and alternate the main view between the participants of a session as they take the floor. You can check the complete API reference for these events in  Session events  section.", 
            "title": "Speech detection"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/", 
            "text": "openvidu-browser API\n\n\n\n\n\n\n\n\nNOTE: all input parameters (\"Parameters\" columns) are listed in strict order, optional ones in \nitalics\n\n\n\n\n\n\n\n\n\n\nClass\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu\n\n\nUse it to initialize your sessions and publishers\n\n\n\n\n\n\nSession\n\n\nRepresents a video call. It can also be seen as a room where multiple users can connect. Participants who publish their videos to a session will be seen by the rest of users connected to that specific session\n\n\n\n\n\n\nPublisher\n\n\nPacks local media streams. Users can publish it to a session\n\n\n\n\n\n\nSubscriber\n\n\nPacks remote media streams. Users automatically receive them when others publish their streams\n\n\n\n\n\n\nStream\n\n\nRepresents each one of the videos send and receive by a user in a session. Therefore each Publisher and Subscriber has an attribute of type Stream\n\n\n\n\n\n\nConnection\n\n\nRepresents each one of the user's connection to the session (the local one and other user's connections). Therefore each Session and Stream object has an attribute of type Connection\n\n\n\n\n\n\nOpenViduError\n\n\nSimple object to identify errors on runtime\n\n\n\n\n\n\nOpenViduErrorName\n\n\nOpenViduError names enum\n\n\n\n\n\n\n\n\nOpenVidu\n\n\nUse it to initialize your sessions and publishers\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconstructor\n\n\nOpenVidu\n\n\n\n\nReturns a new OpenVidu object. This is the entry point to OpenVidu in the browser\n\n\n\n\n\n\ninitSession\n\n\nSession\n\n\napikey:string\nsessionId:string\n\n\nReturns a session with id \nsessionId\n\n\n\n\n\n\ninitPublisher\n\n\nPublisher\n\n\nparentId:string\ncameraOptions:any\ncallback:function\n\n\nStarts local video stream, appending it to \nparentId\n HTML element, with the specific \ncameraOptions\n settings and executing \ncallback\n function in the end. \ncameraOptions\n is an object with the following (optional) properties:\nvar cameraOptions = {\naudio: boolean,\nvideo: boolean,\naudioActive: boolean,\nvideoActive: boolean,\nquality: string,\nscreen: boolean\n}\naudio\n: whether to transmit audio or not\nvideo\n: whether to transmit video or not\naudioActive\n: whether to join the session with the audio unmuted or muted. Only makes sense if property \naudio\n is set to true. You can change audio state later during the session with \nPublisher.publishAudio(true)\nvideoActive\n: whether to join the session with the video enabled or disabled. Only makes sense if property \nvideo\n is set to true. You can change video state later during the session with \nPublisher.publishVideo(true)\nquality\n: quality of the video (\"LOW\", \"MEDIUM\", \"HIGH\")\nscreen\n: whether to use screen capturing as the video source instead of a camera or not\n\n\n\n\n\n\ncheckSystemRequirements\n\n\nnumber\n\n\n\n\nReturns 1 if the browser supports WebRTC, 0 otherwise\n\n\n\n\n\n\ngetDevices\n\n\nPromise\n\n\ncallback(error, deviceInfo):function\n\n\nCollects information about the media input and output devices available on the system, returned in \ndeviceInfo\n array\n\n\n\n\n\n\nenableProdMode\n\n\n\n\n\n\nDisable all logging except error level\n\n\n\n\n\n\n\n\nSession\n\n\nRepresents a video call. It can also be seen as a room where multiple users can connect. Participants who publish their videos to a session will be seen by the rest of users connected to that specific session\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconnect\n\n\n\n\ntoken:string\nmetadata:any\ncallback(error):function\n\n\nConnects to the session using \ntoken\n and executes \ncallback\n in the end (\nerror\n parameter null if success). \nmetadata\n parameter allows you to pass extra data to share with other users when they receive \nstreamCreated\n event. You can also add metadata through openvidu-backend-client when generating tokens (see \nTokenOptions\n). The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars\n\n\n\n\n\n\ndisconnect\n\n\n\n\n\n\nLeaves the session, destroying all streams and deleting the user as a participant\n\n\n\n\n\n\npublish\n\n\n\n\npublisher:Publisher\n\n\nPublishes the specific user's local stream contained in \npublisher\n object to the session\n\n\n\n\n\n\nunpublish\n\n\n\n\npublisher:Publisher\n\n\nUnpublishes the specific user's local stream contained in \npublisher\n object\n\n\n\n\n\n\non\n\n\n\n\neventName:string\ncallback:function\n\n\ncallback\n function will be triggered each time \neventName\n event is recieved\n\n\n\n\n\n\nonce\n\n\n\n\neventName:string\ncallback:function\n\n\ncallback\n function will be triggered once when \neventName\n event is recieved. The listener is removed immediately\n\n\n\n\n\n\noff\n\n\n\n\neventName:string\neventHandler:any\n\n\nRemoves \neventHandler\n handler for \neventName\n event\n\n\n\n\n\n\nsubscribe\n\n\nSubscriber\n\n\nstream:Stream\nhtmlId:string\nvideoOptions:any\n\n\nSubscribes to \nstream\n, appending a new HTML Video element to DOM element of \nhtmlId\n id, with \nvideoOptions\n settings. This method is usually called in the callback of \nstreamCreated\n event\n\n\n\n\n\n\nunsubscribe\n\n\n\n\nsubscriber:Subscriber\n\n\nUnsubscribes from \nsubscriber\n, automatically removing its HTML Video element\n\n\n\n\n\n\nsignal\n(since  \nv1.2.0\n)\n\n\n\n\nsignal:any\n\n\nSends one signal. \nsignal\n object has the following properties: {data:\nstring\n, to:\nConnection[]\n, type:\nstring\n} (all optional properties)\nAll users subscribed to that signal (\nsession.on('signal:type', ...)\n or \nsession.on('signal', ...)\n for all signals) and whose Connection objects are in \nto\n array will receive it\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nstring\n\n\nThe unique id of the session\n\n\n\n\n\n\nconnection\n\n\nConnection\n\n\nThe local connection to the session. Only available after \nSession.connect()\n method has been called succesfully\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nProperties of \nevent\n object\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstreamCreated\n\n\nstream:\nStream\n\n\nTriggered by Session object when a new Stream (published by other client) has been created and added to it\n\n\n\n\n\n\nstreamDestroyed\n\n\nstream:\nStream\npreventDefault():Function\n\n\nTriggered by Session object when an existing Stream (published by other client) has been destroyed. The default behaviour is the deletion of the HTML video element associated to it. To prevent it, call \npreventDefault()\n method on the event object\n\n\n\n\n\n\nconnectionCreated\n\n\nconnection:\nConnection\n\n\nTriggered by Session object whenever any client has joined the session. This includes dispatching one event for each client that joins the session when you are already connected to it, one for each existing participant the first time you connect to the session and once for your own local connection\n\n\n\n\n\n\nconnectionDestroyed\n\n\nconnection:\nConnection\n\n\nTriggered by Session object whenever a client (other than your own) leaves the session. This event can also mean that \nstreamDestroyed\n events could be dispatched, depending on the streams associated to it\n\n\n\n\n\n\nsessionDisconnected\n\n\npreventDefault():Function\n\n\nTriggered by Session object when the client disconnects from the Session. Default behaviour is the deletion of all HTML video elements. Call \npreventDefault()\n on event object to prevent it and delete them by yourself\n\n\n\n\n\n\npublisherStartSpeaking\n(since  \nv1.3.0\n)\n\n\nconnection:\nConnection\nstreamId:string\n\n\nTriggered by Session object when any Publisher starts speaking. \nconnection\n property identifies the participant who is speaking, and \nstreamId\n identifies the specific Stream for which the event has been triggered\n\n\n\n\n\n\npublisherStopSpeaking\n(since  \nv1.3.0\n)\n\n\nconnection:\nConnection\nstreamId:string\n\n\nTriggered by Session object when any Publisher stops speaking. \nconnection\n property identifies the participant who is has stopped speaking, and \nstreamId\n identifies the specific Stream for which the event has been triggered. For this event to be triggered, \npublisherStartSpeaking\n event must have been previously triggered\n\n\n\n\n\n\n\n\nPublisher\n\n\nPacks local media streams. Users can publish it to a session\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npublishAudio\n\n\n\n\nvalue:boolean\n\n\nEnable or disable the audio track depending on whether value is \ntrue\n or \nfalse\n\n\n\n\n\n\npublishVideo\n\n\n\n\nvalue:boolean\n\n\nEnable or disable the video track depending on whether value is \ntrue\n or \nfalse\n\n\n\n\n\n\ndestroy\n\n\nPublisher\n\n\n\n\nDelets the publisher object and removes it from DOM. The rest of users will trigger a \nstreamDestroyed\n event\n\n\n\n\n\n\nsubscribeToRemote\n\n\n\n\n\n\nLocal video will be replaced by your remote video (same stream as other clients will receive from you)\n\n\n\n\n\n\non\n\n\n\n\neventName:string\ncallback:function\n\n\ncallback\n function will be triggered each time \neventName\n event is recieved\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccessAllowed\n\n\nboolean\n\n\ntrue\n if the user has granted access to the camera, \nfalse\n otherwise\n\n\n\n\n\n\nelement\n\n\nElement\n\n\nThe parent HTML Element which contains the publisher\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe id of the HTML Video element of the publisher\n\n\n\n\n\n\nstream\n\n\nStream\n\n\nThe stream object of the publisher\n\n\n\n\n\n\nsession\n\n\nSession\n\n\nThe session to which the publisher belongs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nProperties of \nevent\n object\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccessAllowed\n\n\n\n\nTriggered by Publisher object when the user has granted access to the camera/microphone\n\n\n\n\n\n\naccessDenied\n\n\n\n\nTriggered by Publisher object when the user has rejected access to the camera/microphone\n\n\n\n\n\n\nvideoElementCreated\n\n\nelement:HTMLVideoElement\n\n\nTriggered by Publisher object inmediately after a new video element has been added to DOM\n\n\n\n\n\n\nvideoPlaying\n\n\nelement:HTMLVideoElement\n\n\nTriggered by Subscriber object when the video (same as \nvideoElementCreated\n) starts playing. Only triggered for those Publisher objects which have NOT called their method \nsubscribeToRemote\n\n\n\n\n\n\nremoteVideoPlaying\n\n\nelement:HTMLVideoElement\n\n\nTriggered by Publisher object when your looped remote video starts playing. Only triggered for those Publisher objects which have called their method \nsubscribeToRemote\n\n\n\n\n\n\n\n\nSubscriber\n\n\nPacks remote media streams. Users automatically receive them when others publish their streams\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nelement\n\n\nElement\n\n\nThe parent HTML Element which contains the subscriber\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe id of the HTML Video element of the subscriber\n\n\n\n\n\n\nstream\n\n\nStream\n\n\nThe stream object of the subscriber\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nProperties of \nevent\n object\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvideoElementCreated\n\n\nelement:HTMLVideoElement\n\n\nTriggered by Subscriber object inmediately after a new video element has been added to DOM\n\n\n\n\n\n\nvideoPlaying\n\n\nelement:HTMLVideoElement\n\n\nTriggered by Subscriber object when the video (same as \nvideoElementCreated\n) starts playing\n\n\n\n\n\n\n\n\nStream\n\n\nRepresents each one of the videos send and receive by a user in a session. Therefore each Publisher and Subscriber has an attribute of type Stream\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconnection\n\n\nConnection\n\n\nThe Connection object to which the Stream belongs\n\n\n\n\n\n\nstreamId\n(since  \nv1.3.0\n)\n\n\nstring\n\n\nThe unique id of the stream\n\n\n\n\n\n\nhasAudio\n(since  \nv1.3.0\n)\n\n\nboolean\n\n\ntrue\n if there's an audio stream, \nfalse\n otherwise\n\n\n\n\n\n\nhasVideo\n(since  \nv1.3.0\n)\n\n\nboolean\n\n\ntrue\n if there's a video stream, \nfalse\n otherwise\n\n\n\n\n\n\ntypeOfVideo\n(since  \nv1.3.0\n)\n\n\nstring\n\n\n\"CAMERA\"\n, \n\"SCREEN\"\n or \n\"\"\n (empty string) for a Stream publishing the video of a camera (with or without audio), doing screen sharing (with or without audio) or sending only audio respectively\n\n\n\n\n\n\n\n\nConnection\n\n\nRepresents each one of the user's connection to the session (the local one and other user's connections). Therefore each Session and Stream object has an attribute of type Connection\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconnectionId\n\n\nstring\n\n\nUnique identifier of the connection\n\n\n\n\n\n\ndata\n\n\nstring\n\n\nData associated to this connection (and therefore to certain user). This is an important field: it allows you to broadcast all the information you want for each user (a username, for example)\n\n\n\n\n\n\ncreationTime\n\n\nnumber\n\n\nTime when this connection was created\n\n\n\n\n\n\n\n\nOpenViduError\n\n\nSimple object to identify errors on runtime\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconstructor\n\n\nOpenViduError\n\n\nname:OpenViduErrorName\nmessage:string\n\n\nReturns a new OpenViduError object\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nOpenViduErrorName\n\n\nThe name and unique identifier of the error\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\nFurther information about the error\n\n\n\n\n\n\n\n\nOpenViduErrorName\n\n\n(enum)\n\n\nOpenViduError names enum\n\n\n\n\n\n\n\n\nConstant\n\n\n\n\n\n\n\n\n\n\n\n\nCAMERA_ACCESS_DENIED\n\n\n\n\n\n\n\n\nMICROPHONE_ACCESS_DENIED\n\n\n\n\n\n\n\n\nSCREEN_CAPTURE_DENIED\n\n\n\n\n\n\n\n\nNO_VIDEO_DEVICE\n\n\n\n\n\n\n\n\nNO_INPUT_DEVICE\n\n\n\n\n\n\n\n\nSCREEN_EXTENSION_NOT_INSTALLED\n\n\n\n\n\n\n\n\nGENERIC_ERROR", 
            "title": "openvidu-browser API"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#openvidu", 
            "text": "Use it to initialize your sessions and publishers     Method  Returns  Parameters  Description      constructor  OpenVidu   Returns a new OpenVidu object. This is the entry point to OpenVidu in the browser    initSession  Session  apikey:string sessionId:string  Returns a session with id  sessionId    initPublisher  Publisher  parentId:string cameraOptions:any callback:function  Starts local video stream, appending it to  parentId  HTML element, with the specific  cameraOptions  settings and executing  callback  function in the end.  cameraOptions  is an object with the following (optional) properties: var cameraOptions = { audio: boolean, video: boolean, audioActive: boolean, videoActive: boolean, quality: string, screen: boolean } audio : whether to transmit audio or not video : whether to transmit video or not audioActive : whether to join the session with the audio unmuted or muted. Only makes sense if property  audio  is set to true. You can change audio state later during the session with  Publisher.publishAudio(true) videoActive : whether to join the session with the video enabled or disabled. Only makes sense if property  video  is set to true. You can change video state later during the session with  Publisher.publishVideo(true) quality : quality of the video (\"LOW\", \"MEDIUM\", \"HIGH\") screen : whether to use screen capturing as the video source instead of a camera or not    checkSystemRequirements  number   Returns 1 if the browser supports WebRTC, 0 otherwise    getDevices  Promise  callback(error, deviceInfo):function  Collects information about the media input and output devices available on the system, returned in  deviceInfo  array    enableProdMode    Disable all logging except error level", 
            "title": "OpenVidu"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#session", 
            "text": "Represents a video call. It can also be seen as a room where multiple users can connect. Participants who publish their videos to a session will be seen by the rest of users connected to that specific session     Method  Returns  Parameters  Description      connect   token:string metadata:any callback(error):function  Connects to the session using  token  and executes  callback  in the end ( error  parameter null if success).  metadata  parameter allows you to pass extra data to share with other users when they receive  streamCreated  event. You can also add metadata through openvidu-backend-client when generating tokens (see  TokenOptions ). The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars    disconnect    Leaves the session, destroying all streams and deleting the user as a participant    publish   publisher:Publisher  Publishes the specific user's local stream contained in  publisher  object to the session    unpublish   publisher:Publisher  Unpublishes the specific user's local stream contained in  publisher  object    on   eventName:string callback:function  callback  function will be triggered each time  eventName  event is recieved    once   eventName:string callback:function  callback  function will be triggered once when  eventName  event is recieved. The listener is removed immediately    off   eventName:string eventHandler:any  Removes  eventHandler  handler for  eventName  event    subscribe  Subscriber  stream:Stream htmlId:string videoOptions:any  Subscribes to  stream , appending a new HTML Video element to DOM element of  htmlId  id, with  videoOptions  settings. This method is usually called in the callback of  streamCreated  event    unsubscribe   subscriber:Subscriber  Unsubscribes from  subscriber , automatically removing its HTML Video element    signal (since   v1.2.0 )   signal:any  Sends one signal.  signal  object has the following properties: {data: string , to: Connection[] , type: string } (all optional properties) All users subscribed to that signal ( session.on('signal:type', ...)  or  session.on('signal', ...)  for all signals) and whose Connection objects are in  to  array will receive it        Property  Type  Description      sessionId  string  The unique id of the session    connection  Connection  The local connection to the session. Only available after  Session.connect()  method has been called succesfully        Event  Properties of  event  object  Description      streamCreated  stream: Stream  Triggered by Session object when a new Stream (published by other client) has been created and added to it    streamDestroyed  stream: Stream preventDefault():Function  Triggered by Session object when an existing Stream (published by other client) has been destroyed. The default behaviour is the deletion of the HTML video element associated to it. To prevent it, call  preventDefault()  method on the event object    connectionCreated  connection: Connection  Triggered by Session object whenever any client has joined the session. This includes dispatching one event for each client that joins the session when you are already connected to it, one for each existing participant the first time you connect to the session and once for your own local connection    connectionDestroyed  connection: Connection  Triggered by Session object whenever a client (other than your own) leaves the session. This event can also mean that  streamDestroyed  events could be dispatched, depending on the streams associated to it    sessionDisconnected  preventDefault():Function  Triggered by Session object when the client disconnects from the Session. Default behaviour is the deletion of all HTML video elements. Call  preventDefault()  on event object to prevent it and delete them by yourself    publisherStartSpeaking (since   v1.3.0 )  connection: Connection streamId:string  Triggered by Session object when any Publisher starts speaking.  connection  property identifies the participant who is speaking, and  streamId  identifies the specific Stream for which the event has been triggered    publisherStopSpeaking (since   v1.3.0 )  connection: Connection streamId:string  Triggered by Session object when any Publisher stops speaking.  connection  property identifies the participant who is has stopped speaking, and  streamId  identifies the specific Stream for which the event has been triggered. For this event to be triggered,  publisherStartSpeaking  event must have been previously triggered", 
            "title": "Session"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#publisher", 
            "text": "Packs local media streams. Users can publish it to a session     Method  Returns  Parameters  Description      publishAudio   value:boolean  Enable or disable the audio track depending on whether value is  true  or  false    publishVideo   value:boolean  Enable or disable the video track depending on whether value is  true  or  false    destroy  Publisher   Delets the publisher object and removes it from DOM. The rest of users will trigger a  streamDestroyed  event    subscribeToRemote    Local video will be replaced by your remote video (same stream as other clients will receive from you)    on   eventName:string callback:function  callback  function will be triggered each time  eventName  event is recieved        Property  Type  Description      accessAllowed  boolean  true  if the user has granted access to the camera,  false  otherwise    element  Element  The parent HTML Element which contains the publisher    id  string  The id of the HTML Video element of the publisher    stream  Stream  The stream object of the publisher    session  Session  The session to which the publisher belongs        Event  Properties of  event  object  Description      accessAllowed   Triggered by Publisher object when the user has granted access to the camera/microphone    accessDenied   Triggered by Publisher object when the user has rejected access to the camera/microphone    videoElementCreated  element:HTMLVideoElement  Triggered by Publisher object inmediately after a new video element has been added to DOM    videoPlaying  element:HTMLVideoElement  Triggered by Subscriber object when the video (same as  videoElementCreated ) starts playing. Only triggered for those Publisher objects which have NOT called their method  subscribeToRemote    remoteVideoPlaying  element:HTMLVideoElement  Triggered by Publisher object when your looped remote video starts playing. Only triggered for those Publisher objects which have called their method  subscribeToRemote", 
            "title": "Publisher"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#subscriber", 
            "text": "Packs remote media streams. Users automatically receive them when others publish their streams     Method  Returns  Parameters  Description                Property  Type  Description      element  Element  The parent HTML Element which contains the subscriber    id  string  The id of the HTML Video element of the subscriber    stream  Stream  The stream object of the subscriber        Event  Properties of  event  object  Description      videoElementCreated  element:HTMLVideoElement  Triggered by Subscriber object inmediately after a new video element has been added to DOM    videoPlaying  element:HTMLVideoElement  Triggered by Subscriber object when the video (same as  videoElementCreated ) starts playing", 
            "title": "Subscriber"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#stream", 
            "text": "Represents each one of the videos send and receive by a user in a session. Therefore each Publisher and Subscriber has an attribute of type Stream     Property  Type  Description      connection  Connection  The Connection object to which the Stream belongs    streamId (since   v1.3.0 )  string  The unique id of the stream    hasAudio (since   v1.3.0 )  boolean  true  if there's an audio stream,  false  otherwise    hasVideo (since   v1.3.0 )  boolean  true  if there's a video stream,  false  otherwise    typeOfVideo (since   v1.3.0 )  string  \"CAMERA\" ,  \"SCREEN\"  or  \"\"  (empty string) for a Stream publishing the video of a camera (with or without audio), doing screen sharing (with or without audio) or sending only audio respectively", 
            "title": "Stream"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#connection", 
            "text": "Represents each one of the user's connection to the session (the local one and other user's connections). Therefore each Session and Stream object has an attribute of type Connection     Property  Type  Description      connectionId  string  Unique identifier of the connection    data  string  Data associated to this connection (and therefore to certain user). This is an important field: it allows you to broadcast all the information you want for each user (a username, for example)    creationTime  number  Time when this connection was created", 
            "title": "Connection"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#openviduerror", 
            "text": "Simple object to identify errors on runtime     Method  Returns  Parameters  Description      constructor  OpenViduError  name:OpenViduErrorName message:string  Returns a new OpenViduError object        Property  Type  Description      name  OpenViduErrorName  The name and unique identifier of the error    message  string  Further information about the error", 
            "title": "OpenViduError"
        }, 
        {
            "location": "/reference-docs/openvidu-browser/#openviduerrorname", 
            "text": "(enum)  OpenViduError names enum     Constant       CAMERA_ACCESS_DENIED     MICROPHONE_ACCESS_DENIED     SCREEN_CAPTURE_DENIED     NO_VIDEO_DEVICE     NO_INPUT_DEVICE     SCREEN_EXTENSION_NOT_INSTALLED     GENERIC_ERROR", 
            "title": "OpenViduErrorName"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/", 
            "text": "openvidu-java-client API\n\n\n\n\n\n\nCode sample\n\n\n(\n= v1.7.0)\n\n\nOpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder().build();\nSession session = openVidu.createSession(properties);\n\n// Getting a sessionId\nString sessionId = session.getSessionId();\n\n// Getting a token\nTokenOptions tokenOptions = new TokenOptions.Builder().build();\nString token = session.generateToken(tokenOptions);\n\n// Store all the objects you need for later use and return 'sessionId' and 'token' to the client\n\n\n\n\n\n\n\n\nAPI\n\n\n\n\n\n\nNOTE: all input parameters (\"Parameters\" columns) are listed in strict order, optional ones in \nitalics\n\n\n\n\n\n\n\n\n\n\nClass\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu\n\n\nUse it to create all the sessions you need\n\n\n\n\n\n\nSession\n\n\nAllows for the creation of tokens\n\n\n\n\n\n\nTokenOptions\n\n\nCustomize each token with this class when generating them\n\n\n\n\n\n\nOpenViduRole\n\n\nEnum that defines the values accepted by \nTokenOptions.Builder.role(OpenViduRole role)\n method\n\n\n\n\n\n\nSessionProperties\n\n\nCustomize each session with this class when creating them\n\n\n\n\n\n\nMediaMode\n\n\nEnum that defines the type of connections in a session: p2p or through OpenVidu Server\n\n\n\n\n\n\nArchiveMode\n\n\nEnum that defines if automatically start the recording of a session or if it must be explicitly invoked\n\n\n\n\n\n\nArchiveLayout\n\n\nEnum that defines the layout for a session recording\n\n\n\n\n\n\n\n\nOpenVidu\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu()\n\n\n\n\nString:urlOpenViduServer\nString:secret\n\n\nThe constructor receives the URL of your OpenVidu Server and the secret shared with it\n\n\n\n\n\n\ncreateSession()\n\n\nSession\n\n\nSessionProperties:properties\n\n\nGet a Session object by calling this method (optionally configured with \nproperties\n parameter). You can then store it as you want for later use\n\n\n\n\n\n\n\n\nSession\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngenerateToken()\n\n\nString\n\n\nTokenOptions:tokenOptions\n\n\nThe value returned is required in the client side just as the sessionId in order to connect to a session. It is a single-use-only token\n\n\n\n\n\n\ngetSessionId()\n\n\nString\n\n\n\n\nReturns the unique identifier of the session. You will need to return this parameter to the client side to pass it during the connection process to the session\n\n\n\n\n\n\ngetProperties()\n\n\nSessionProperties\n\n\n\n\nReturns the properties of the session. These define if the media streams will pass through OpenVidu Server or not and the configuration for the sessin recording (if desired)\n\n\n\n\n\n\n\n\nTokenOptions\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetData()\n\n\nString\n\n\n\n\nReturns the metadata associated to the token\n\n\n\n\n\n\ngetRole()\n\n\nOpenViduRole\n\n\n\n\nReturns the role associated to the token\n\n\n\n\n\n\n\n\nTokenOptions.Builder\n\n\n(inner static class)\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTokenOptions.Builder()\n\n\n\n\n\n\nConstructor\n\n\n\n\n\n\nbuild()\n\n\nTokenOptions\n\n\n\n\nReturns a new \nTokenOptions\n object with the stablished properties. Default values if methods \ndata()\n and \nrole()\n are not called are an empty string and OpenViduRole.PUBLISHER, respectively\n\n\n\n\n\n\ndata()\n\n\nTokenOptions.Builder\n\n\nString:data\n\n\nSome extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars\n\n\n\n\n\n\nrole()\n\n\nTokenOptions.Builder\n\n\nOpenViduRole:role\n\n\nThe role associated to this token\n\n\n\n\n\n\n\n\nOpenViduRole\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSUBSCRIBER\n\n\nThey can subscribe to published streams of other users\n\n\n\n\n\n\nPUBLISHER\n\n\nThey can subscribe to published streams of other users and publish their own streams\n\n\n\n\n\n\nMODERATOR\n\n\nThey can subscribe to published streams of other users, publish their own streams and force \nunpublish()\n and \ndisconnect()\n over a third-party stream or user\n\n\n\n\n\n\n\n\nSessionProperties\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narchiveLayout()\n\n\nArchiveLayout\n\n\n\n\nReturns the ArchiveLayout associated to the session\n\n\n\n\n\n\narchiveMode()\n\n\nArchiveMode\n\n\n\n\nReturns the ArchiveMode associated to the session\n\n\n\n\n\n\nmediaMode()\n\n\nMediaMode\n\n\n\n\nReturns the MediaMode associated to the session\n\n\n\n\n\n\n\n\nSessionProperties.Builder\n\n\n(inner static class)\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSessionProperties.Builder()\n\n\n\n\n\n\nConstructor\n\n\n\n\n\n\narchiveLayout()\n\n\nSessionProperties.Builder\n\n\nArchiveLayout:archiveLayout\n\n\nSome extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars\n\n\n\n\n\n\narchiveMode()\n\n\nSessionProperties.Builder\n\n\nArchiveMode:archiveMode\n\n\nThe role associated to this token\n\n\n\n\n\n\nmediaMode()\n\n\nSessionProperties.Builder\n\n\nMediaMode:mediaMode\n\n\nThe role associated to this token\n\n\n\n\n\n\nbuild()\n\n\nSessionProperties\n\n\n\n\nReturns a new \nTokenOptions\n object with the stablished properties. Default values if methods \ndata()\n and \nrole()\n are not called are an empty string and OpenViduRole.PUBLISHER, respectively\n\n\n\n\n\n\n\n\nMediaMode\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nRELAYED\n\n\nThe session will attempt to transmit streams directly between clients (P2P)\n(feature not available yet)\n\n\n\n\n\n\nROUTED\n\n\nThe session will transmit streams using OpenVidu Media Server. This is the mandatory option for session recording\n\n\n\n\n\n\n\n\nArchiveMode\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nALWAYS\n\n\nThe session recording will start automatically as soon as the first participant publishes a stream. It will end automatically when the last participant leaves the session\n\n\n\n\n\n\nMANUAL\n\n\nThe session recording only starts when \nOpenVidu.startRecording()\n method is called and stops only when \nOpenVidu.stopRecording()\n is called\n(feature not available yet. MANUAL mode means no recording at all in the current version)\n\n\n\n\n\n\n\n\nArchiveLayout\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBEST_FIT\n\n\nGrid layout where all the videos are evenly distributed, taking up as much space as possible", 
            "title": "openvidu-java-client API"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#code-sample", 
            "text": "( = v1.7.0)  OpenVidu openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nSessionProperties properties = new SessionProperties.Builder().build();\nSession session = openVidu.createSession(properties);\n\n// Getting a sessionId\nString sessionId = session.getSessionId();\n\n// Getting a token\nTokenOptions tokenOptions = new TokenOptions.Builder().build();\nString token = session.generateToken(tokenOptions);\n\n// Store all the objects you need for later use and return 'sessionId' and 'token' to the client", 
            "title": "Code sample"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#api", 
            "text": "NOTE: all input parameters (\"Parameters\" columns) are listed in strict order, optional ones in  italics      Class  Description      OpenVidu  Use it to create all the sessions you need    Session  Allows for the creation of tokens    TokenOptions  Customize each token with this class when generating them    OpenViduRole  Enum that defines the values accepted by  TokenOptions.Builder.role(OpenViduRole role)  method    SessionProperties  Customize each session with this class when creating them    MediaMode  Enum that defines the type of connections in a session: p2p or through OpenVidu Server    ArchiveMode  Enum that defines if automatically start the recording of a session or if it must be explicitly invoked    ArchiveLayout  Enum that defines the layout for a session recording", 
            "title": "API"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#openvidu", 
            "text": "Method  Returns  Parameters  Description      OpenVidu()   String:urlOpenViduServer String:secret  The constructor receives the URL of your OpenVidu Server and the secret shared with it    createSession()  Session  SessionProperties:properties  Get a Session object by calling this method (optionally configured with  properties  parameter). You can then store it as you want for later use", 
            "title": "OpenVidu"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#session", 
            "text": "Method  Returns  Parameters  Description      generateToken()  String  TokenOptions:tokenOptions  The value returned is required in the client side just as the sessionId in order to connect to a session. It is a single-use-only token    getSessionId()  String   Returns the unique identifier of the session. You will need to return this parameter to the client side to pass it during the connection process to the session    getProperties()  SessionProperties   Returns the properties of the session. These define if the media streams will pass through OpenVidu Server or not and the configuration for the sessin recording (if desired)", 
            "title": "Session"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#tokenoptions", 
            "text": "Method  Returns  Parameters  Description      getData()  String   Returns the metadata associated to the token    getRole()  OpenViduRole   Returns the role associated to the token", 
            "title": "TokenOptions"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#tokenoptionsbuilder", 
            "text": "(inner static class)     Method  Returns  Parameters  Description      TokenOptions.Builder()    Constructor    build()  TokenOptions   Returns a new  TokenOptions  object with the stablished properties. Default values if methods  data()  and  role()  are not called are an empty string and OpenViduRole.PUBLISHER, respectively    data()  TokenOptions.Builder  String:data  Some extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars    role()  TokenOptions.Builder  OpenViduRole:role  The role associated to this token", 
            "title": "TokenOptions.Builder"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#openvidurole", 
            "text": "Enum  Description      SUBSCRIBER  They can subscribe to published streams of other users    PUBLISHER  They can subscribe to published streams of other users and publish their own streams    MODERATOR  They can subscribe to published streams of other users, publish their own streams and force  unpublish()  and  disconnect()  over a third-party stream or user", 
            "title": "OpenViduRole"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#sessionproperties", 
            "text": "Method  Returns  Parameters  Description      archiveLayout()  ArchiveLayout   Returns the ArchiveLayout associated to the session    archiveMode()  ArchiveMode   Returns the ArchiveMode associated to the session    mediaMode()  MediaMode   Returns the MediaMode associated to the session", 
            "title": "SessionProperties"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#sessionpropertiesbuilder", 
            "text": "(inner static class)     Method  Returns  Parameters  Description      SessionProperties.Builder()    Constructor    archiveLayout()  SessionProperties.Builder  ArchiveLayout:archiveLayout  Some extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars    archiveMode()  SessionProperties.Builder  ArchiveMode:archiveMode  The role associated to this token    mediaMode()  SessionProperties.Builder  MediaMode:mediaMode  The role associated to this token    build()  SessionProperties   Returns a new  TokenOptions  object with the stablished properties. Default values if methods  data()  and  role()  are not called are an empty string and OpenViduRole.PUBLISHER, respectively", 
            "title": "SessionProperties.Builder"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#mediamode", 
            "text": "Enum  Description      RELAYED  The session will attempt to transmit streams directly between clients (P2P) (feature not available yet)    ROUTED  The session will transmit streams using OpenVidu Media Server. This is the mandatory option for session recording", 
            "title": "MediaMode"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#archivemode", 
            "text": "Enum  Description      ALWAYS  The session recording will start automatically as soon as the first participant publishes a stream. It will end automatically when the last participant leaves the session    MANUAL  The session recording only starts when  OpenVidu.startRecording()  method is called and stops only when  OpenVidu.stopRecording()  is called (feature not available yet. MANUAL mode means no recording at all in the current version)", 
            "title": "ArchiveMode"
        }, 
        {
            "location": "/reference-docs/openvidu-java-client/#archivelayout", 
            "text": "Enum  Description      BEST_FIT  Grid layout where all the videos are evenly distributed, taking up as much space as possible", 
            "title": "ArchiveLayout"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/", 
            "text": "openvidu-node-client API\n\n\n\n\n\n\nCode sample\n\n\n(\n= v1.7.0)\n\n\nvar openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = new SessionProperties.Builder().build();\nvar session = openVidu.createSession(properties);\n\n// Getting a sessionId\nsession.getSessionId(function(sessionId) {\n    // Getting a token\n    var tokenOptions = new TokenOptions.Builder().build();\n    session.generateToken(tokenOptions, function(token){\n        // Store all the objects you need for later use and return 'sessionId' and 'token' to the client\n    });\n});\n\n\n\n\n\n\n\n\nAPI\n\n\n\n\n\n\nNOTE: all input parameters (\"Parameters\" columns) are listed in strict order, optional ones in \nitalics\n\n\n\n\n\n\n\n\n\n\nClass\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu\n\n\nUse it to create all the sessions you need\n\n\n\n\n\n\nSession\n\n\nAllows for the creation of tokens\n\n\n\n\n\n\nTokenOptions\n\n\nCustomize each token with this object when generating them\n\n\n\n\n\n\nOpenViduRole\n\n\nEnum that defines the values accepted by \nTokenOptions.Builder.role(OpenViduRole role)\n method\n\n\n\n\n\n\nSessionProperties\n\n\nCustomize each session with this object when creating them\n\n\n\n\n\n\nMediaMode\n\n\nEnum that defines the type of connections in a session: p2p or through OpenVidu Server\n\n\n\n\n\n\nArchiveMode\n\n\nEnum that defines if automatically start the recording of a session or if it must be explicitly invoked\n\n\n\n\n\n\nArchiveLayout\n\n\nEnum that defines the layout for a session recording\n\n\n\n\n\n\n\n\nOpenVidu\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu()\n\n\n\n\nurlOpenViduServer:string\nsecret:string\n\n\nThe constructor receives the URL of your OpenVidu Server and the secret shared with it\n\n\n\n\n\n\ncreateSession()\n\n\nSession\n\n\nSessionProperties:properties\n\n\nGet a Session object by calling this method (optionally configured with \nproperties\n parameter). You can then store it as you want for later use\n\n\n\n\n\n\n\n\nSession\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetSessionId()\n\n\n\n\ncallback(sessionId:string):function\n\n\nReturns the unique identifier of the session as the only parameter (\nsessionId\n) in your \ncallback\n function. You will need to return this parameter to the client side to pass it during the connection process to the session\n\n\n\n\n\n\ngenerateToken()\n\n\n\n\ntokenOptions:TokenOptions\ncallback(token:string):function\n\n\nReturns the token as the only parameter (\ntoken\n) in your \ncallback\n function. This single-use-only token is required in the client side just as the sessionId in order to connect to a session\n\n\n\n\n\n\ngetProperties()\n\n\nSessionProperties\n\n\n\n\nReturns the properties of the session. These define if the media streams will pass through OpenVidu Server or not and the configuration for the sessin recording (if desired)\n\n\n\n\n\n\n\n\nTokenOptions\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetData()\n\n\nstring\n\n\n\n\nReturns the metadata associated to the token\n\n\n\n\n\n\ngetRole()\n\n\nOpenViduRole\n\n\n\n\nReturns the role associated to the token\n\n\n\n\n\n\n\n\nTokenOptions.Builder\n\n\n(inner static class)\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTokenOptions.Builder()\n\n\n\n\n\n\nConstructor\n\n\n\n\n\n\nbuild()\n\n\nTokenOptions\n\n\n\n\nReturns a new \nTokenOptions\n object with the stablished properties. Default values if methods \ndata()\n and \nrole()\n are not called are an empty string and OpenViduRole.PUBLISHER, respectively\n\n\n\n\n\n\ndata()\n\n\nTokenOptions.Builder\n\n\ndata:string\n\n\nSome extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars\n\n\n\n\n\n\nrole()\n\n\nTokenOptions.Builder\n\n\nrole:OpenViduRole\n\n\nThe role associated to this token\n\n\n\n\n\n\n\n\nOpenViduRole\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSUBSCRIBER\n\n\nThey can subscribe to published streams of other users\n\n\n\n\n\n\nPUBLISHER\n\n\nThey can subscribe to published streams of other users and publish their own streams\n\n\n\n\n\n\nMODERATOR\n\n\nThey can subscribe to published streams of other users, publish their own streams and force \nunpublish()\n and \ndisconnect()\n over a third-party stream or user\n\n\n\n\n\n\n\n\nSessionProperties\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narchiveLayout()\n\n\nArchiveLayout\n\n\n\n\nReturns the ArchiveLayout associated to the session\n\n\n\n\n\n\narchiveMode()\n\n\nArchiveMode\n\n\n\n\nReturns the ArchiveMode associated to the session\n\n\n\n\n\n\nmediaMode()\n\n\nMediaMode\n\n\n\n\nReturns the MediaMode associated to the session\n\n\n\n\n\n\n\n\nSessionProperties.Builder\n\n\n(inner static class)\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSessionProperties.Builder()\n\n\n\n\n\n\nConstructor\n\n\n\n\n\n\narchiveLayout()\n\n\nSessionProperties.Builder\n\n\nArchiveLayout:archiveLayout\n\n\nSome extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars\n\n\n\n\n\n\narchiveMode()\n\n\nSessionProperties.Builder\n\n\nArchiveMode:archiveMode\n\n\nThe role associated to this token\n\n\n\n\n\n\nmediaMode()\n\n\nSessionProperties.Builder\n\n\nMediaMode:mediaMode\n\n\nThe role associated to this token\n\n\n\n\n\n\nbuild()\n\n\nSessionProperties\n\n\n\n\nReturns a new \nTokenOptions\n object with the stablished properties. Default values if methods \ndata()\n and \nrole()\n are not called are an empty string and OpenViduRole.PUBLISHER, respectively\n\n\n\n\n\n\n\n\nMediaMode\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nRELAYED\n\n\nThe session will attempt to transmit streams directly between clients (P2P)\n(feature not available yet)\n\n\n\n\n\n\nROUTED\n\n\nThe session will transmit streams using OpenVidu Media Server. This is the mandatory option for session recording\n\n\n\n\n\n\n\n\nArchiveMode\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nALWAYS\n\n\nThe session recording will start automatically as soon as the first participant publishes a stream. It will end automatically when the last participant leaves the session\n\n\n\n\n\n\nMANUAL\n\n\nThe session recording only starts when \nOpenVidu.startRecording()\n method is called and stops only when \nOpenVidu.stopRecording()\n is called\n(feature not available yet. MANUAL mode means no recording at all in the current version)\n\n\n\n\n\n\n\n\nArchiveLayout\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBEST_FIT\n\n\nGrid layout where all the videos are evenly distributed, taking up as much space as possible", 
            "title": "openvidu-node-client API"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#code-sample", 
            "text": "( = v1.7.0)  var openvidu = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\nvar properties = new SessionProperties.Builder().build();\nvar session = openVidu.createSession(properties);\n\n// Getting a sessionId\nsession.getSessionId(function(sessionId) {\n    // Getting a token\n    var tokenOptions = new TokenOptions.Builder().build();\n    session.generateToken(tokenOptions, function(token){\n        // Store all the objects you need for later use and return 'sessionId' and 'token' to the client\n    });\n});", 
            "title": "Code sample"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#api", 
            "text": "NOTE: all input parameters (\"Parameters\" columns) are listed in strict order, optional ones in  italics      Class  Description      OpenVidu  Use it to create all the sessions you need    Session  Allows for the creation of tokens    TokenOptions  Customize each token with this object when generating them    OpenViduRole  Enum that defines the values accepted by  TokenOptions.Builder.role(OpenViduRole role)  method    SessionProperties  Customize each session with this object when creating them    MediaMode  Enum that defines the type of connections in a session: p2p or through OpenVidu Server    ArchiveMode  Enum that defines if automatically start the recording of a session or if it must be explicitly invoked    ArchiveLayout  Enum that defines the layout for a session recording", 
            "title": "API"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#openvidu", 
            "text": "Method  Returns  Parameters  Description      OpenVidu()   urlOpenViduServer:string secret:string  The constructor receives the URL of your OpenVidu Server and the secret shared with it    createSession()  Session  SessionProperties:properties  Get a Session object by calling this method (optionally configured with  properties  parameter). You can then store it as you want for later use", 
            "title": "OpenVidu"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#session", 
            "text": "Method  Returns  Parameters  Description      getSessionId()   callback(sessionId:string):function  Returns the unique identifier of the session as the only parameter ( sessionId ) in your  callback  function. You will need to return this parameter to the client side to pass it during the connection process to the session    generateToken()   tokenOptions:TokenOptions callback(token:string):function  Returns the token as the only parameter ( token ) in your  callback  function. This single-use-only token is required in the client side just as the sessionId in order to connect to a session    getProperties()  SessionProperties   Returns the properties of the session. These define if the media streams will pass through OpenVidu Server or not and the configuration for the sessin recording (if desired)", 
            "title": "Session"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#tokenoptions", 
            "text": "Method  Returns  Parameters  Description      getData()  string   Returns the metadata associated to the token    getRole()  OpenViduRole   Returns the role associated to the token", 
            "title": "TokenOptions"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#tokenoptionsbuilder", 
            "text": "(inner static class)     Method  Returns  Parameters  Description      TokenOptions.Builder()    Constructor    build()  TokenOptions   Returns a new  TokenOptions  object with the stablished properties. Default values if methods  data()  and  role()  are not called are an empty string and OpenViduRole.PUBLISHER, respectively    data()  TokenOptions.Builder  data:string  Some extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars    role()  TokenOptions.Builder  role:OpenViduRole  The role associated to this token", 
            "title": "TokenOptions.Builder"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#openvidurole", 
            "text": "Enum  Description      SUBSCRIBER  They can subscribe to published streams of other users    PUBLISHER  They can subscribe to published streams of other users and publish their own streams    MODERATOR  They can subscribe to published streams of other users, publish their own streams and force  unpublish()  and  disconnect()  over a third-party stream or user", 
            "title": "OpenViduRole"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#sessionproperties", 
            "text": "Method  Returns  Parameters  Description      archiveLayout()  ArchiveLayout   Returns the ArchiveLayout associated to the session    archiveMode()  ArchiveMode   Returns the ArchiveMode associated to the session    mediaMode()  MediaMode   Returns the MediaMode associated to the session", 
            "title": "SessionProperties"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#sessionpropertiesbuilder", 
            "text": "(inner static class)     Method  Returns  Parameters  Description      SessionProperties.Builder()    Constructor    archiveLayout()  SessionProperties.Builder  ArchiveLayout:archiveLayout  Some extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars    archiveMode()  SessionProperties.Builder  ArchiveMode:archiveMode  The role associated to this token    mediaMode()  SessionProperties.Builder  MediaMode:mediaMode  The role associated to this token    build()  SessionProperties   Returns a new  TokenOptions  object with the stablished properties. Default values if methods  data()  and  role()  are not called are an empty string and OpenViduRole.PUBLISHER, respectively", 
            "title": "SessionProperties.Builder"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#mediamode", 
            "text": "Enum  Description      RELAYED  The session will attempt to transmit streams directly between clients (P2P) (feature not available yet)    ROUTED  The session will transmit streams using OpenVidu Media Server. This is the mandatory option for session recording", 
            "title": "MediaMode"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#archivemode", 
            "text": "Enum  Description      ALWAYS  The session recording will start automatically as soon as the first participant publishes a stream. It will end automatically when the last participant leaves the session    MANUAL  The session recording only starts when  OpenVidu.startRecording()  method is called and stops only when  OpenVidu.stopRecording()  is called (feature not available yet. MANUAL mode means no recording at all in the current version)", 
            "title": "ArchiveMode"
        }, 
        {
            "location": "/reference-docs/openvidu-node-client/#archivelayout", 
            "text": "Enum  Description      BEST_FIT  Grid layout where all the videos are evenly distributed, taking up as much space as possible", 
            "title": "ArchiveLayout"
        }, 
        {
            "location": "/reference-docs/REST-API/", 
            "text": "REST API\n\n\n\n\n\n\nThis is the straightforward way to get \nsessionId\n and \ntoken\n params from openvidu-server without using \nopenvidu-java-client\n or \nopenvidu-node-client\n.\n\n\nTwo REST operations are provided: \n/api/sessions\n and \n/api/tokens\n.\nBoth operations have in common the header referred to authorization. It is implemented via Basic Auth, and it is as simple as applying Base64 encoding to the username (always \"OPENVIDUAPP\") and the password (your \nsecret\n shared with openvidu-server). An example is shown below:\n\n\nFor secret \"MY_SECRET\", the final header would be\n\n\n\n\nAuthorization:Basic T1BFTlZJRFVBUFA6TVlfU0VDUkVU\n\n\n\n\n/api/sessions\n\n\n\n\n\n\n\n\nNEW SESSIONID\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nPOST\n\n\n\n\n\n\nURL\n\n\nhttps://[YOUR_OPENVIDUSERVER_IP]/api/sessions\n\n\n\n\n\n\nHeaders\n\n\nAuthorization:Basic \nEncodeBase64(OPENVIDUAPP:[YOUR_SECRET])\n\n\n\n\n\n\nBody\n \n*see notes below\n\n\n{\"archiveMode\": \"ARCHIVE_MODE\", \"archiveLayout\": \"ARCHIVE_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"}\n\n\n\n\n\n\nReturns\n\n\n{\"id\": \"SESSIONID\"}\n\n\n\n\n\n\n\n\n\n\nBody parameters\n\n\n\n\nAll of them are optional (the Body of the POST operation may be empty)\n\n\nARCHIVE_MODE\n\n\nALWAYS\n: Automatic recording from the first user publishing until the last participant leaves the session\n\n\nMANUAL\n (\ndefault\n) : If you want to manage when start and stop the recording. \nNOT AVAILABLE YET: no recording at all if this Archive Mode is set\n\n\n\n\n\n\nARCHIVE_LAYOUT\n\n\nBEST_FIT\n(\ndefault\n) : A grid layout where all the videos are evenly distributed\n\n\nNot available yet: \nPICTURE_IN_PICTURE\n, \nVERTICAL_PRESENTATION\n, \nHORIZONTAL_PRESENTATION\n\n\n\n\n\n\nMEDIA_MODE\n\n\nROUTED\n (\ndefault\n) : Media streams will be routed through OpenVidu Server. This Media Mode is mandatory for session recording\n\n\nNot available yet: \nRELAYED\n\n\n\n\n\n\n\n\n\n\n/api/tokens\n\n\n\n\n\n\n\n\nNEW TOKEN\n\n\nPARAMETERS\n\n\n\n\n\n\n\n\n\n\nOperation\n\n\nPOST\n\n\n\n\n\n\nURL\n\n\nhttps://[YOUR_OPENVIDUSERVER_IP]/api/tokens\n\n\n\n\n\n\nHeaders\n\n\nAuthorization:Basic \nEncodeBase64(OPENVIDUAPP:[YOUR_SECRET])\nContent-Type:application/json\n\n\n\n\n\n\nBody\n\n\n{\"session\": \"SESSIONID\", \"role\": \"ROLE\", \"data\": \"DATA\"}\n\n\n\n\n\n\nReturns\n\n\n{\"token\": \"TOKEN\", \"session\": \"SESSIONID\", \"role\": \"ROLE\", \"data\": \"DATA\", \"id\": \"TOKEN\"}\n\n\n\n\n\n\n\n\n\n\nBody parameters\n\n\n\n\nSESSIONID: the sessionId for which the token should be associated\n\n\nROLE \n(See \nOpenViduRole\n section)\n\n\nSUBSCRIBER\n\n\nPUBLISHER\n\n\nMODERATOR\n (not available yet)\n\n\n\n\n\n\nDATA: an optional string to associate any metadata to this token (usually participant's information)", 
            "title": "REST  API"
        }, 
        {
            "location": "/reference-docs/REST-API/#apisessions", 
            "text": "NEW SESSIONID  PARAMETERS      Operation  POST    URL  https://[YOUR_OPENVIDUSERVER_IP]/api/sessions    Headers  Authorization:Basic  EncodeBase64(OPENVIDUAPP:[YOUR_SECRET])    Body   *see notes below  {\"archiveMode\": \"ARCHIVE_MODE\", \"archiveLayout\": \"ARCHIVE_LAYOUT\", \"mediaMode\": \"MEDIA_MODE\"}    Returns  {\"id\": \"SESSIONID\"}      Body parameters   All of them are optional (the Body of the POST operation may be empty)  ARCHIVE_MODE  ALWAYS : Automatic recording from the first user publishing until the last participant leaves the session  MANUAL  ( default ) : If you want to manage when start and stop the recording.  NOT AVAILABLE YET: no recording at all if this Archive Mode is set    ARCHIVE_LAYOUT  BEST_FIT ( default ) : A grid layout where all the videos are evenly distributed  Not available yet:  PICTURE_IN_PICTURE ,  VERTICAL_PRESENTATION ,  HORIZONTAL_PRESENTATION    MEDIA_MODE  ROUTED  ( default ) : Media streams will be routed through OpenVidu Server. This Media Mode is mandatory for session recording  Not available yet:  RELAYED", 
            "title": "/api/sessions"
        }, 
        {
            "location": "/reference-docs/REST-API/#apitokens", 
            "text": "NEW TOKEN  PARAMETERS      Operation  POST    URL  https://[YOUR_OPENVIDUSERVER_IP]/api/tokens    Headers  Authorization:Basic  EncodeBase64(OPENVIDUAPP:[YOUR_SECRET]) Content-Type:application/json    Body  {\"session\": \"SESSIONID\", \"role\": \"ROLE\", \"data\": \"DATA\"}    Returns  {\"token\": \"TOKEN\", \"session\": \"SESSIONID\", \"role\": \"ROLE\", \"data\": \"DATA\", \"id\": \"TOKEN\"}      Body parameters   SESSIONID: the sessionId for which the token should be associated  ROLE  (See  OpenViduRole  section)  SUBSCRIBER  PUBLISHER  MODERATOR  (not available yet)    DATA: an optional string to associate any metadata to this token (usually participant's information)", 
            "title": "/api/tokens"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/", 
            "text": "OpenVidu Server configuration parameters\n\n\n\n\n\n\nList of configuration parameters when launching openvidu-server:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nserver.port\n\n\nPort where OpenVidu Server will listen to client's connections\n\n\n8443\n\n\n\n\n\n\nkms.uris\n\n\nKMS URL's to which OpenVidu Server will try to connect. They are tested in order until a valid one is found\n\n\n[\\\"ws://localhost:8888/kurento\\\"]\n(default value for a KMS running in the same machine as OpenVidu Server)\n\n\n\n\n\n\nopenvidu.secret\n\n\nSecret used to connect to OpenVidu Server. This value is required when using the \nREST API\n or any server client (\nopenvidu-java-client\n, \nopenvidu-node-client\n), as well as when connecting to openvidu-server dashboard\n\n\nMY_SECRET\n\n\n\n\n\n\nopenvidu.publicurl\n\n\nURL to connect clients to OpenVidu Server. This must be the full IP of your OpenVidu Server, including \nprotocol\n, \nhost\n and \nport\n (for example: \nhttps://my.openvidu.server.ip:8443\n). If no \nport\n argument is provided, \nserver.port\n param will be appended to it\n\n\nlocal\n(with default value \nlocal\n this parameter will be set to \nlocalhost:PORT\n, being \nPORT\n the param \nserver.port\n)\n\n\n\n\n\n\nopenvidu.cdr\n\n\nWhether to enable Call Detail Record or not (check \nCall Detail Record\n)\n\n\nfalse\n\n\n\n\n\n\nopenvidu.recording\n\n\nWhether to enable recording module or not (check \nRecording\n)\n\n\nfalse\n\n\n\n\n\n\nopenvidu.recording.path\n\n\nSystem path where to store the video files of recorded sessions\n\n\n/opt/openvidu/recordings\n\n\n\n\n\n\nopenvidu.recording.free-access\n\n\nWhether to allow free http access to recorded sessions or not.\nIf \ntrue\n path \nhttps://OPENVIDU_SERVER_IP:[server.port]/[openvidu.recording.path]\n will be publicly accessible through \nhttps://OPENVIDU_SERVER_IP:[server.port]/recordings\n path. For example, for OpenVidu Server launched in \nmy-domain.com\n and configured with \nserver.port=5000\n, \nopenvidu.recording=true\n, \nopenvidu.recording-path=/my/path\n and \nopenvidu.recording.free-access=true\n : A session with id \nfoo\n that has been recorded will generate a video file locally stored under \n/my/path/foo.mp4\n and accesible by any client connecting to \nhttps://my-domain.com:5000/recordings/foo.mp4\n.\nIf \nfalse\n HTTP basic authentication will be required to access any video file stored under that route (as requested when connecting to OpenVidu dashboard on \nhttps://OPENVIDU_SERVER_IP:[server.port]\n)\n\n\nfalse\n\n\n\n\n\n\n\n\nExample:\n\n\njava -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://my.openvidu.server.ip:3333 -Dopenvidu.cdr=true -Dserver.port=3333 -Dkms.uris=[\\\nws://my.kms.ip:8888/kurento\\\n] -jar openvidu-server.jar\n\n\n\n\nList of additional configuration parameters when launching \nopenvidu-server-kms\n Docker container:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nSample value\n\n\n\n\n\n\n\n\n\n\nKMS_STUN_IP\n\n\nIP of STUN server used by KMS\n\n\nstun.l.google.com\n (free STUN server from Google)\n\n\n\n\n\n\nKMS_STUN_PORT\n\n\nPORT of STUN server used by KMS\n\n\n19302\n (free STUN server from Google)\n\n\n\n\n\n\nKMS_TURN_URL\n\n\nConfiguration for TURN server used by KMS\n\n\nuser:pass@turn_public_ip:turn_port\n (\nuser\n and \npass\n of the TURN server, \nturn_public_ip\n its publicly accessible url and \nturn_port\n the port the TURN server listens to\n\n\n\n\n\n\n\n\nExample:\n\n\ndocker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333 -e openvidu.cdr=true -e server.port=3333 -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e KMS_TURN_URL=myuser:mypass@54.54.54.54:3478 openvidu/openvidu-server-kms\n\n\n\n\nCall Detail Record\n\n\nOpenVidu Server offers a CDR logging system, so you can easily keep record of every session, every user connecting to them and every connection established by each one of the users. To start OpenVidu Server with CDR enabled, launch it with option \nopenvidu.cdr=true\n. The CDR file will be located under \nlog/\n folder in the same path as your Java executable.\n\n\nThe record is a plain text file containing one standard JSON entry for each line. All JSON entries have the following structure:\n\n\n{\"[EVENT_NAME]\": {\"sessionId\": \"[SESSION_ID]\", \"timestamp\": \"[TIMESTAMP]\", \"[CUSTOM_PROPERTY_1]\": \"[CUSTOM_VALUE_1]\",\"[CUSTOM_PROPERTY_2]\": \"[CUSTOM_VALUE_2]\", ... }}\n\n\nSo every entry is a JSON object identified by a specific event name, and all of them have as properties the \nsessionId\n identifying the video-session for which this event was registered and the \ntimestamp\n. Besides this two common properties, there are custom properties for every specific event with useful information. The complete list of possible JSON entries is available below:\n\n\n\n\n\nsessionCreated\n\n\nRecorded when a new session has been created.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nsessionCreated\n:{\nsessionId\n:\nfds4e07mdug1ga3hlrfh3sdf6d\n,\ntimestamp\n:1516292370848}}\n\n\n\n\n\n\n\nsessionDestroyed\n\n\nRecored when a session has finished.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nstartTime\n\n\nTime when the session started\n\n\nUTC milliseconds\n\n\n\n\n\n\nendTime\n\n\nTime when the session finished\n\n\nUTC milliseconds\n\n\n\n\n\n\nduration\n\n\nTotal duration of the session\n\n\nSeconds\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nsessionDestroyed\n:{\nduration\n:4,\nstartTime\n:1516292370848,\nsessionId\n:\nfds4e07mdug1ga3hlrfh3sdf6d\n,\nendTime\n:1516292375176,\ntimestamp\n:1516292375176}}\n\n\n\n\n\n\n\nparticipantJoined\n\n\nRecorded when a user has connected to a session.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\n\n\nExample: \n\n\n{\nparticipantJoined\n:{\nparticipantId\n:\nogjud06fhgkck4id5a8p4a6ejp\n,\nsessionId\n:\nfds4e07mdug1ga3hlrfh3sdf6d\n,\ntimestamp\n:1516292370885}}\n\n\n\n\n\n\n\nparticipantLeft\n\n\nRecorded when a user has left a session.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\nstartTime\n\n\nTime when the participant joined the session\n\n\nUTC milliseconds\n\n\n\n\n\n\nendTime\n\n\nTime when the participant left the session\n\n\nUTC milliseconds\n\n\n\n\n\n\nduration\n\n\nTotal duration of the participant's connection to the session\n\n\nSeconds\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nparticipantLeft\n:{\nparticipantId\n:\nogjud06fhgkck4id5a8p4a6ejp\n,\nduration\n:4,\nstartTime\n:1516292370885,\nsessionId\n:\nfds4e07mdug1ga3hlrfh3sdf6d\n,\nendTime\n:1516292375195,\ntimestamp\n:1516292375195}}\n\n\n\n\n\n\n\nwebrtcConnectionCreated\n\n\nRecorded when a new media stream has been established. Can be an \"INBOUND\" connection (the user is receiving a stream from a publisher of the session) or an \"OUTBOUND\" connection (the user is a publishing a stream to the session).\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\nconnection\n\n\nWhether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)\n\n\n[\n\"INBOUND\"\n,\n\"OUTBOUND\"\n]\n\n\n\n\n\n\nreceivingFrom\n\n\nIf \nconnection\n is \n\"INBOUND\"\n, the participant from whom the media stream is being received\n\n\nA string with the participant (sender) unique identifier\n\n\n\n\n\n\naudioEnabled\n\n\nWhether the media connection is sending audio or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoEnabled\n\n\nWhether the media connection is sending video or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoSource\n\n\nIf \nvideoEnabled\n is \ntrue\n, the type of video that is being transmitted\n\n\n[\n\"CAMERA\"\n,\n\"SCREEN\"\n]\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nwebrtcConnectionCreated\n:{\nparticipantId\n:\nogjud06fhgkck4id5a8p4a6ejp\n,\nvideoSource\n:\nCAMERA\n,\nconnection\n:\nOUTBOUND\n,\naudioEnabled\n:true,\nsessionId\n:\nfds4e07mdug1ga3hlrfh3sdf6d\n,\nvideoEnabled\n:true,\ntimestamp\n:1516292371499}}\n\n\n\n\n\n\n\nwebrtcConnectionDestroyed\n\n\nRecorded when any media stream connection is closed.\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nSession for which the event was triggered\n\n\nA string with the session unique identifier\n\n\n\n\n\n\ntimestamp\n\n\nTime when the event was triggered\n\n\nUTC milliseconds\n\n\n\n\n\n\nparticipantId\n\n\nIdentifier of the participant\n\n\nA string with the participant unique identifier\n\n\n\n\n\n\nconnection\n\n\nWhether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)\n\n\n[\n\"INBOUND\"\n,\n\"OUTBOUND\"\n]\n\n\n\n\n\n\nreceivingFrom\n\n\nIf \nconnection\n is \n\"INBOUND\"\n, the participant from whom the media stream is being received\n\n\nA string with the participant (sender) unique identifier\n\n\n\n\n\n\naudioEnabled\n\n\nWhether the media connection is sending audio or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoEnabled\n\n\nWhether the media connection is sending video or not\n\n\n[\ntrue\n,\nfalse\n]\n\n\n\n\n\n\nvideoSource\n\n\nIf \nvideoEnabled\n is \ntrue\n, the type of video that is being transmitted\n\n\n[\n\"CAMERA\"\n,\n\"SCREEN\"\n]\n\n\n\n\n\n\nstartTime\n\n\nTime when the media connection was established\n\n\nUTC milliseconds\n\n\n\n\n\n\nendTime\n\n\nTime when the media connection closed\n\n\nUTC milliseconds\n\n\n\n\n\n\nduration\n\n\nTotal duration of the media connection\n\n\nSeconds\n\n\n\n\n\n\n\n\nExample:\n\n\n{\nwebrtcConnectionDestroyed\n:{\nparticipantId\n:\nogjud06fhgkck4id5a8p4a6ejp\n,\nduration\n:3,\nvideoSource\n:\nCAMERA\n,\nconnection\n:\nOUTBOUND\n,\naudioEnabled\n:true,\nstartTime\n:1516292371499,\nsessionId\n:\nfds4e07mdug1ga3hlrfh3sdf6d\n,\nendTime\n:1516292375180,\nvideoEnabled\n:true,\ntimestamp\n:1516292375180}}", 
            "title": "OpenVidu Server configuration"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#list-of-configuration-parameters-when-launching-openvidu-server", 
            "text": "Parameter  Description  Default value      server.port  Port where OpenVidu Server will listen to client's connections  8443    kms.uris  KMS URL's to which OpenVidu Server will try to connect. They are tested in order until a valid one is found  [\\\"ws://localhost:8888/kurento\\\"] (default value for a KMS running in the same machine as OpenVidu Server)    openvidu.secret  Secret used to connect to OpenVidu Server. This value is required when using the  REST API  or any server client ( openvidu-java-client ,  openvidu-node-client ), as well as when connecting to openvidu-server dashboard  MY_SECRET    openvidu.publicurl  URL to connect clients to OpenVidu Server. This must be the full IP of your OpenVidu Server, including  protocol ,  host  and  port  (for example:  https://my.openvidu.server.ip:8443 ). If no  port  argument is provided,  server.port  param will be appended to it  local (with default value  local  this parameter will be set to  localhost:PORT , being  PORT  the param  server.port )    openvidu.cdr  Whether to enable Call Detail Record or not (check  Call Detail Record )  false    openvidu.recording  Whether to enable recording module or not (check  Recording )  false    openvidu.recording.path  System path where to store the video files of recorded sessions  /opt/openvidu/recordings    openvidu.recording.free-access  Whether to allow free http access to recorded sessions or not. If  true  path  https://OPENVIDU_SERVER_IP:[server.port]/[openvidu.recording.path]  will be publicly accessible through  https://OPENVIDU_SERVER_IP:[server.port]/recordings  path. For example, for OpenVidu Server launched in  my-domain.com  and configured with  server.port=5000 ,  openvidu.recording=true ,  openvidu.recording-path=/my/path  and  openvidu.recording.free-access=true  : A session with id  foo  that has been recorded will generate a video file locally stored under  /my/path/foo.mp4  and accesible by any client connecting to  https://my-domain.com:5000/recordings/foo.mp4 . If  false  HTTP basic authentication will be required to access any video file stored under that route (as requested when connecting to OpenVidu dashboard on  https://OPENVIDU_SERVER_IP:[server.port] )  false     Example:  java -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://my.openvidu.server.ip:3333 -Dopenvidu.cdr=true -Dserver.port=3333 -Dkms.uris=[\\ ws://my.kms.ip:8888/kurento\\ ] -jar openvidu-server.jar", 
            "title": "List of configuration parameters when launching openvidu-server:"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#list-of-additional-configuration-parameters-when-launching-openvidu-server-kms-docker-container", 
            "text": "Parameter  Description  Sample value      KMS_STUN_IP  IP of STUN server used by KMS  stun.l.google.com  (free STUN server from Google)    KMS_STUN_PORT  PORT of STUN server used by KMS  19302  (free STUN server from Google)    KMS_TURN_URL  Configuration for TURN server used by KMS  user:pass@turn_public_ip:turn_port  ( user  and  pass  of the TURN server,  turn_public_ip  its publicly accessible url and  turn_port  the port the TURN server listens to     Example:  docker run -d -p 3333:3333 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://my.openvidu.server.ip:3333 -e openvidu.cdr=true -e server.port=3333 -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e KMS_TURN_URL=myuser:mypass@54.54.54.54:3478 openvidu/openvidu-server-kms", 
            "title": "List of additional configuration parameters when launching openvidu-server-kms Docker container:"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#call-detail-record", 
            "text": "OpenVidu Server offers a CDR logging system, so you can easily keep record of every session, every user connecting to them and every connection established by each one of the users. To start OpenVidu Server with CDR enabled, launch it with option  openvidu.cdr=true . The CDR file will be located under  log/  folder in the same path as your Java executable.  The record is a plain text file containing one standard JSON entry for each line. All JSON entries have the following structure:  {\"[EVENT_NAME]\": {\"sessionId\": \"[SESSION_ID]\", \"timestamp\": \"[TIMESTAMP]\", \"[CUSTOM_PROPERTY_1]\": \"[CUSTOM_VALUE_1]\",\"[CUSTOM_PROPERTY_2]\": \"[CUSTOM_VALUE_2]\", ... }}  So every entry is a JSON object identified by a specific event name, and all of them have as properties the  sessionId  identifying the video-session for which this event was registered and the  timestamp . Besides this two common properties, there are custom properties for every specific event with useful information. The complete list of possible JSON entries is available below:", 
            "title": "Call Detail Record"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#sessioncreated", 
            "text": "Recorded when a new session has been created.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds     Example:  { sessionCreated :{ sessionId : fds4e07mdug1ga3hlrfh3sdf6d , timestamp :1516292370848}}", 
            "title": "sessionCreated"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#sessiondestroyed", 
            "text": "Recored when a session has finished.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    startTime  Time when the session started  UTC milliseconds    endTime  Time when the session finished  UTC milliseconds    duration  Total duration of the session  Seconds     Example:  { sessionDestroyed :{ duration :4, startTime :1516292370848, sessionId : fds4e07mdug1ga3hlrfh3sdf6d , endTime :1516292375176, timestamp :1516292375176}}", 
            "title": "sessionDestroyed"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#participantjoined", 
            "text": "Recorded when a user has connected to a session.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier     Example:   { participantJoined :{ participantId : ogjud06fhgkck4id5a8p4a6ejp , sessionId : fds4e07mdug1ga3hlrfh3sdf6d , timestamp :1516292370885}}", 
            "title": "participantJoined"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#participantleft", 
            "text": "Recorded when a user has left a session.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier    startTime  Time when the participant joined the session  UTC milliseconds    endTime  Time when the participant left the session  UTC milliseconds    duration  Total duration of the participant's connection to the session  Seconds     Example:  { participantLeft :{ participantId : ogjud06fhgkck4id5a8p4a6ejp , duration :4, startTime :1516292370885, sessionId : fds4e07mdug1ga3hlrfh3sdf6d , endTime :1516292375195, timestamp :1516292375195}}", 
            "title": "participantLeft"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#webrtcconnectioncreated", 
            "text": "Recorded when a new media stream has been established. Can be an \"INBOUND\" connection (the user is receiving a stream from a publisher of the session) or an \"OUTBOUND\" connection (the user is a publishing a stream to the session).     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier    connection  Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)  [ \"INBOUND\" , \"OUTBOUND\" ]    receivingFrom  If  connection  is  \"INBOUND\" , the participant from whom the media stream is being received  A string with the participant (sender) unique identifier    audioEnabled  Whether the media connection is sending audio or not  [ true , false ]    videoEnabled  Whether the media connection is sending video or not  [ true , false ]    videoSource  If  videoEnabled  is  true , the type of video that is being transmitted  [ \"CAMERA\" , \"SCREEN\" ]     Example:  { webrtcConnectionCreated :{ participantId : ogjud06fhgkck4id5a8p4a6ejp , videoSource : CAMERA , connection : OUTBOUND , audioEnabled :true, sessionId : fds4e07mdug1ga3hlrfh3sdf6d , videoEnabled :true, timestamp :1516292371499}}", 
            "title": "webrtcConnectionCreated"
        }, 
        {
            "location": "/reference-docs/openvidu-server-params/#webrtcconnectiondestroyed", 
            "text": "Recorded when any media stream connection is closed.     Property  Description  Value      sessionId  Session for which the event was triggered  A string with the session unique identifier    timestamp  Time when the event was triggered  UTC milliseconds    participantId  Identifier of the participant  A string with the participant unique identifier    connection  Whether the media connection is an inbound connection (the participant is receiving media from OpenVidu) or an outbound connection (the participant is sending media to OpenVidu)  [ \"INBOUND\" , \"OUTBOUND\" ]    receivingFrom  If  connection  is  \"INBOUND\" , the participant from whom the media stream is being received  A string with the participant (sender) unique identifier    audioEnabled  Whether the media connection is sending audio or not  [ true , false ]    videoEnabled  Whether the media connection is sending video or not  [ true , false ]    videoSource  If  videoEnabled  is  true , the type of video that is being transmitted  [ \"CAMERA\" , \"SCREEN\" ]    startTime  Time when the media connection was established  UTC milliseconds    endTime  Time when the media connection closed  UTC milliseconds    duration  Total duration of the media connection  Seconds     Example:  { webrtcConnectionDestroyed :{ participantId : ogjud06fhgkck4id5a8p4a6ejp , duration :3, videoSource : CAMERA , connection : OUTBOUND , audioEnabled :true, startTime :1516292371499, sessionId : fds4e07mdug1ga3hlrfh3sdf6d , endTime :1516292375180, videoEnabled :true, timestamp :1516292375180}}", 
            "title": "webrtcConnectionDestroyed"
        }, 
        {
            "location": "/reference-docs/openvidu-artifacts/", 
            "text": "OpenVidu Artifacts\n\n\n\n\n\n\n\n\nMain artifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nLatest version\n\n    \nLink\n\n    \nInfo\n\n  \n\n\n  \n\n    \nopenvidu-browser\n\n    \nNPM package\n\n    \n1.7.0\n\n    \nNPM\n\n    \n\n  \n\n  \n\n    \nJS file\n\n    \n1.7.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nopenvidu-server\n\n    \nJAR\n\n    \n1.7.0\n\n    \nGitHub\n\n    \n\n  \n\n  \n\n    \nDocker container\n\n    \n1.7.0\n\n    \nDockerHub\n\n  \n\n    \n\n    \nDocker container (+KMS)\n\n    \n1.7.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-java-client\n\n    \nMVN package\n\n    \n1.7.0\n\n    \nMVN Repository\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-node-client\n\n    \nNPM package\n\n    \n1.7.0\n\n    \nNPM\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-cloud-devops\n\n    \nJSON files\n\n    \n1.1.0\n\n    \nGitHub\n\n    \n\n  \n\n\n  \n\n    \nopenvidu-parent\n\n    \nPOM\n\n    \n1.1.0\n\n        \nMVN Repository\n\n    \n\n  \n\n\n\n\n\n\n\n\nDemos and tutorials artifacts\n\n\n\n\n  \n\n    \nArtifact\n\n    \nType\n\n    \nLatest version\n\n    \nLink\n\n  \n\n\n  \n\n    \nopenvidu-js-java\n\n    \nJAR\n\n    \n1.1.0\n\n    \nGitHub\n\n  \n\n  \n\n    \nDocker container\n(basic-webinar-demo)\n\n    \n1.1.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nopenvidu-mvc-java\n\n    \nJAR\n\n    \n1.1.0\n\n    \nGitHub\n\n  \n\n\n  \n\n    \nbasic-videoconference-demo\n\n    \nDocker container\n\n    \n1.1.0\n\n    \nDockerHub\n\n  \n\n\n  \n\n    \nclassroom-demo\n\n    \nDocker container\n\n    \n1.1.0\n\n    \nDockerHub\n\n  \n\n  \n\n    \nWAR\n\n    \n1.1.0\n\n    \nGitHub\n\n  \n\n\n\n\n\n\n\n\nTutorials artifacts without a binary distribution\n\n\n\n\n  \n\n    \nArtifact\n\n    \nHow to run it\n\n  \n\n\n  \n\n    \nopenvidu-js-node\n\n    \nGo\n\n  \n\n\n  \n\n    \nopenvidu-mvc-node\n\n    \nGo\n\n  \n\n\n  \n\n    \nopenvidu-insecure-js\n(basic-videoconference-demo)\n\n    \nGo\n\n  \n\n\n  \n\n    \nopenvidu-insecure-angular\n\n    \nGo\n\n  \n\n\n  \n\n    \nopenvidu-getaroom\n\n    \nGo\n\n  \n\n\n\n\n\n\n\nvar mobileWidth = 767;\n  var width = window.innerWidth\n  || document.documentElement.clientWidth\n  || document.body.clientWidth;\n  if (width <= mobileWidth) {\n    function changePlacement(tooltip) {\n        tooltip.setAttribute('data-placement', 'left');\n    }\n    var tooltips = document.getElementsByClassName('ion-information-circled');\n    for(i = 0; i < tooltips.length; i++) {\n        changePlacement(tooltips[i]);\n    }\n  }", 
            "title": "OpenVidu Artifacts"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/", 
            "text": "Deploying OpenVidu Demos on AWS (TUTORIAL)\n\n\n\n\n\n\nDeploying on AWS with Cloud Formation\n\n\nWe have packed all our demos in one single template for AWS CloudFormation. You can follow these steps and see how easy it is to deploy OpenVidu in the cloud.\n\n\n1. Access to the console of AWS Cloud Formation\n\n\nGo to CloudFormation\n\n\n2. Click on \nCreate Stack\n\n\n\n    \n\n  \n\n\n3. Option \nSpecify an Amazon S3 template URL\n with the following URL\n\n\nhttps://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-Demos-latest.json\n\n  \nCopy\n\n\n\n    \n\n  \n\n\n4. Complete the configuration fields\n\n\nWe provide 3 different scenarios: you can use the default \nSELF-SIGNED CERTIFICATE\n stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow \nLET'S ENCRYPT\n to automatically generate a valid and free certificate for your domain or use your own \nCUSTOM CERTIFICATE\n if you already have one.\n\n\n\n  \n\n    \n\n      \n\n      \nSelf-Signed certificate\n\n      \nLet's Encrypt\n certificate\n\n      \nCustom certificate\n\n    \n\n    \n\n      \nStack name\n\n      \nYour choice\n\n      \nYour choice\n\n      \nYour choice\n\n    \n\n    \n\n      \nType of SSL Certificate\n\n      \nselfsigned\n\n      \nletsencrypt\n\n      \nowncert\n\n    \n\n    \n\n      \nEmail\n\n      \n\n      \nYour choice\n\n      \n\n    \n\n    \n\n      \nFully qualified domain name\n\n      \n\n      \nYour custom domain\n(for example: \nopenvidu.io\n)\n\n      \nYour custom domain\n(for example: \nopenvidu.io\n)\n\n    \n\n    \n\n      \nElastic IP\n\n      \n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n    \n\n    \n\n      \nCRT File\n\n      \n\n      \n\n      \nContent of your \n.crt\n file\n-----BEGIN CERTIFICATE-----\nfooFOOfooFOOfooFOOfoo...\n-----END CERTIFICATE-----\n\n    \n\n    \n\n      \nKEY File\n\n      \n\n      \n\n      \nContent of your \n.key\n file\n-----BEGIN RSA PRIVATE KEY-----\nfooFOOfooFOOfooFOOfoo...\n-----END RSA PRIVATE KEY-----\n\n    \n\n    \n\n      \nInstance Type\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n    \n\n    \n\n      \nKeyName\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n    \n\n  \n\n\n\n\n\n5. Create your Stack\n\n\nNo extra options are necessary. Click on  \nNext\n \u279e \nNext\n \u279e \nCreate\n\n\nCREATE_IN_PROGRESS\n status will show up. You will now have to wait for a few minutes.\n\n\nDespite saying \nCREATE_COMPLETE\n, it can take up to 7 minutes to fully deploy the Demo Software, so please be patient.\n\n\n6. Access the demos through your new IP\n\n\nGo to \nOutputs\n tab to get your brand new IP and click on it (or if you have deployed the demos with Let's Encrypt under your own custom domain, then you should access through it).\n\n\n\n    \n\n  \n\n\n\n\nIMPORTANT\n: Even though the Status of your new Stack shows \"CREATE_COMPLETE\", \nit will take a bit longer until you can access your demos. Be patient.", 
            "title": "Deploying OpenVidu Demos on AWS (TUTORIAL)"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#deploying-on-aws-with-cloud-formation", 
            "text": "We have packed all our demos in one single template for AWS CloudFormation. You can follow these steps and see how easy it is to deploy OpenVidu in the cloud.", 
            "title": "Deploying on AWS with Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#1-access-to-the-console-of-aws-cloud-formation", 
            "text": "Go to CloudFormation", 
            "title": "1. Access to the console of AWS Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#2-click-on-create-stack", 
            "text": "", 
            "title": "2. Click on Create Stack"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#3-option-specify-an-amazon-s3-template-url-with-the-following-url", 
            "text": "https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-Demos-latest.json \n   Copy", 
            "title": "3. Option Specify an Amazon S3 template URL with the following URL"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#4-complete-the-configuration-fields", 
            "text": "We provide 3 different scenarios: you can use the default  SELF-SIGNED CERTIFICATE  stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow  LET'S ENCRYPT  to automatically generate a valid and free certificate for your domain or use your own  CUSTOM CERTIFICATE  if you already have one.  \n   \n     \n       \n       Self-Signed certificate \n       Let's Encrypt  certificate \n       Custom certificate \n     \n     \n       Stack name \n       Your choice \n       Your choice \n       Your choice \n     \n     \n       Type of SSL Certificate \n       selfsigned \n       letsencrypt \n       owncert \n     \n     \n       Email \n       \n       Your choice \n       \n     \n     \n       Fully qualified domain name \n       \n       Your custom domain (for example:  openvidu.io ) \n       Your custom domain (for example:  openvidu.io ) \n     \n     \n       Elastic IP \n       \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n     \n     \n       CRT File \n       \n       \n       Content of your  .crt  file -----BEGIN CERTIFICATE----- fooFOOfooFOOfooFOOfoo... -----END CERTIFICATE----- \n     \n     \n       KEY File \n       \n       \n       Content of your  .key  file -----BEGIN RSA PRIVATE KEY----- fooFOOfooFOOfooFOOfoo... -----END RSA PRIVATE KEY----- \n     \n     \n       Instance Type \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n     \n     \n       KeyName \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one)", 
            "title": "4. Complete the configuration fields"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#5-create-your-stack", 
            "text": "No extra options are necessary. Click on   Next  \u279e  Next  \u279e  Create  CREATE_IN_PROGRESS  status will show up. You will now have to wait for a few minutes.  Despite saying  CREATE_COMPLETE , it can take up to 7 minutes to fully deploy the Demo Software, so please be patient.", 
            "title": "5. Create your Stack"
        }, 
        {
            "location": "/deployment/deploying-demos-aws/#6-access-the-demos-through-your-new-ip", 
            "text": "Go to  Outputs  tab to get your brand new IP and click on it (or if you have deployed the demos with Let's Encrypt under your own custom domain, then you should access through it).  \n     \n     IMPORTANT : Even though the Status of your new Stack shows \"CREATE_COMPLETE\", \nit will take a bit longer until you can access your demos. Be patient.", 
            "title": "6. Access the demos through your new IP"
        }, 
        {
            "location": "/deployment/deploying-aws/", 
            "text": "Deploying OpenVidu Server and your app on AWS\n\n\n\n\n\n\nDeploying OpenVidu Server on AWS with Cloud Formation\n\n\nThe deployment of OpenVidu can be a piece of cake if you have an AWS account. Just follow these steps:\n\n\n1. Access to the console of AWS Cloud Formation\n\n\nGo to CloudFormation\n\n\n2. Click on \nCreate Stack\n\n\n\n    \n\n  \n\n\n3. Option \nSpecify an Amazon S3 template URL\n with the following URL\n\n\nhttps://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.json\n\n  \nCopy\n\n\n\n    \n\n  \n\n\n4. Complete the configuration fields\n\n\nWe provide 3 different scenarios: you can use the default \nSELF-SIGNED CERTIFICATE\n stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow \nLET'S ENCRYPT\n to automatically generate a valid and free certificate for your domain or use your own \nCUSTOM CERTIFICATE\n if you already have one.\n\n\n\n  \n\n    \n\n      \n\n      \nSelf-Signed certificate\n\n      \nLet's Encrypt\n certificate\n\n      \nCustom certificate\n\n    \n\n    \n\n      \nStack name\n\n      \nYour choice\n\n      \nYour choice\n\n      \nYour choice\n\n    \n\n    \n\n      \nType of SSL Certificate\n\n      \nselfsigned\n\n      \nletsencrypt\n\n      \nowncert\n\n    \n\n    \n\n      \nEmail\n\n      \n\n      \nYour choice\n\n      \n\n    \n\n    \n\n      \nFully qualified domain name\n\n      \n\n      \nYour custom domain\n(for example: \nopenvidu.io\n)\n\n      \nYour custom domain\n(for example: \nopenvidu.io\n)\n\n    \n\n    \n\n      \nElastic IP\n\n      \n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n      \nOne AWS Elastic IP you generated\n(check \nAWS Docs\n to generate a new one)\n\n    \n\n    \n\n      \nCRT File\n\n      \n\n      \n\n      \nContent of your \n.crt\n file\n-----BEGIN CERTIFICATE-----\nfooFOOfooFOOfooFOOfoo...\n-----END CERTIFICATE-----\n\n    \n\n    \n\n      \nKEY File\n\n      \n\n      \n\n      \nContent of your \n.key\n file\n-----BEGIN RSA PRIVATE KEY-----\nfooFOOfooFOOfooFOOfoo...\n-----END RSA PRIVATE KEY-----\n\n    \n\n    \n\n      \nOpenVidu Secret\n\n      \nYour choice\n\n      \nYour choice\n\n      \nYour choice\n\n    \n\n    \n\n      \nInstance Type\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n      \nYour choice\n(at least \nt2.medium\n recommended)\n\n    \n\n    \n\n      \nKeyName\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n      \nYour choice\n(check \nAWS Docs\n to create a new one)\n\n    \n\n  \n\n\n\n\n\n5. Create your Stack\n\n\nNo extra options are necessary. Click on  \nNext\n \u279e \nNext\n \u279e \nCreate\n\n\nCREATE_IN_PROGRESS\n status will show up. You will now have to wait for a few minutes until it shows \nCREATE_COMPLETE\n.\n\n\n6. Access and test your OpenVidu Server through your new IP\n\n\nAfter status changes to \nCREATE_COMPLETE\n, go to \nOutputs\n tab to get your brand new IP and click on it (or if you have deployed under your own custom domain, then you should access through it).\n\n\n\n    \n\n  \n\n\nYou will connect to your OpenVidu dashboard. To access to it use:\n\n\n\n\nOPENVIDUAPP\n as username\n\n\nThe secret you chose on \nStep 4\n as password (field \nOpenVidu Secret\n in the table). \n\n\n\n\nAt OpenVidu dashboard you can test the video transmission. You can now add your own application to your instance. To learn how check the \nnext section\n.\n\n\nAdding your own app to CloudFormation OpenVidu Server\n\n\nOnce you have deployed your CloudFormation OpenVidu Server and checked that it is up and running, you can easily add your own application to the instance. Follow these steps:\n\n\n1. Upload your app to your EC2 instance\n\n\nIn Linux/Mac you can use \nscp\n command. In Windows (or If you prefer a more friendly GUI) you can use \nFileZilla\n. Furthermore, if your app is stored in a GitHub repo, you can directly clone it once you connect to your instance.\n\n\nRemember that the key will be the same you indicated when configuring the \nCloudFormation fields\n. \n\n\n2. Connect to your EC2 instance through SSH\n\n\nRemember that the key will be the same you indicated when configuring the \nCloudFormation fields\n. In case of doubt, check \nAWS docs\n.\n\n\n3. Configure your app\n\n\nDepending on the framework of your app:\n\n\n\n\nPlain HTML/CSS/JS\n\n\n\n\n\n\nIf your app doesn't have a server-side and it is plain HTML, CSS and JavaScript, you just have to add your web files into \n/var/www/html/\n. You will have instant access to it through \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/\n\n\n\n\nIf you want to test the deployment of a plain HTML/CSS/JS app, you can use \nopenvidu-insecure-js\n\n\n\n\n\n\n\n\n\n\nJava\n\n\n\n\n\n\nCopy your JAR or WAR into \n/opt/\n\n\n\n\n\n\nWrite a script to launch your app with all the parameters it needs, and store it under \n/opt/\n. For example, a file \n/opt/YOUR_LAUNCHER.sh\n containing:\n\n\ncd /opt\njava -jar -Dserver.port=4040 myapp.jar\n\n\n\n\n\nIMPORTANT 1\n: It is crucial to navigate to \n/opt\n before the launching command. Otherwise, the system will surely have some problems for finding your files\n\n\nIMPORTANT 2\n: Obviously your app will need Java to run. You must install the correct version of Java in your machine (check version: \njava -version\n)\n\n\nIMPORTANT 3\n: Make sure the script you made is executable.(For Linux you could do like this \nchmod +x YOUR_LAUNCHER.sh\n)\n\n\n\n\n\n\n\n\nConfigure Nginx: add a new \nlocation\n directive to the file \n/etc/nginx/sites-enabled/default\n, inside the \nserver { }\n group:\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }\n\n\n\nFor example\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }\n\n\n\n\n\n\n\nConfigure Supervisor: add the script you wrote in the second step to the file \n/etc/supervisor/conf.d/openvidu.conf\n like this:\n\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\nNow your \n/etc/supervisor/conf.d/openvidu.conf\n must looks like this:\n\n\n  [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\n\n\nTo connect your Java app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the \nREST API\n or \nopenvidu-java-client\n), you will need to use the URL \nhttps://localhost:8443\n. \nlocalhost\n because both your app and OpenVidu Server run in the same machine. \n8443\n because there's where OpenVidu Server listens for petitions. For example, our tutorial \nopenvidu-js-java\n sets this parameter as an environment variable \nright here\n.\n\n\n\n\n\n\n\n\nRestart Nginx: \nsystemctl restart nginx\n\n\n\n\n\n\nRestart Supervisor: \nsystemctl restart supervisor\n\n\n\n\n\n\nYou will have access to your app through \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/\n\n\n\n\n\n\nTroubleshooting: If your app is not working as expected, there are a few files you should check for debugging: \n/var/log/nginx/\n (info about the proxy), \n/var/log/supervisor/\n (output of your app). You can also try to connect to your app directly through the port like \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT\n\n\n\n\nIf you want to test the deployment of a Java app, you can use \nopenvidu-js-java\n or \nopenvidu-mvc-java\n (\nrelease here\n)\n\n\n\n\n\n\n\n\n\n\nNode\n\n\n\n\n\n\nAdd your web files into \n/opt/\n\n\n\n\n\n\nWrite a script to launch your app with all the parameters it needs, and store it under \n/opt/\n. For example, a file \n/opt/YOUR_LAUNCHER.sh\n containing:\n\n\ncd /opt\nnode myserver.js 4040\n\n\n\n\n\nIMPORTANT 1\n: It is crucial to navigate to \n/opt\n before the launching command. Otherwise, the system will surely have some problems for finding your files\n\n\nIMPORTANT 2\n: Obviously your app will need Node to run. You must install the correct version of Node in your machine (check version: \nnodejs -v\n)\n\n\nIMPORTANT 3\n: Make sure the script you made is executable.(For Linux you could do like this \nchmod +x YOUR_LAUNCHER.sh\n)\n\n\n\n\n\n\n\n\nConfigure Nginx: add a new \nlocation\n directive to the file \n/etc/nginx/sites-enabled/default\n, inside the \nserver { }\n group::\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }\n\n\n\nFor example\n\n\n  location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }\n\n\n\n\n\n\n\nRestart Nginx: \nsystemctl restart nginx\n\n\n\n\n\n\nConfigure Supervisor: add the script you wrote in the second step to \n/etc/supervisor/conf.d/openvidu.conf\n like this:\n\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\nNow your \n/etc/supervisor/conf.d/openvidu.conf\n must looks like this:\n\n\n  [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true\n\n\n\n\n\nTo connect your Node app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the \nREST API\n or \nopenvidu-node-client\n), you will need to use the URL \nhttps://localhost:8443\n. \nlocalhost\n because both your app and OpenVidu Server run in the same machine. \n8443\n because there's where OpenVidu Server listens for petitions. For example, our tutorial \nopenvidu-js-node\n expects this parameter as the first argument on launch command \nright here\n.\n\n\n\n\n\n\n\n\nRestart Supervisor: \nsystemctl restart supervisor\n\n\n\n\n\n\nYou will have access to your app through \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/\n\n\n\n\n\n\nTroubleshooting: If your app is not working as expected, there are a few files you should check for debugging: \n/var/log/nginx/\n (info about the proxy), \n/var/log/supervisor/\n (output of your app). You can also try to connect to your app directly through the port like \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT\n\n\n\n\nIf you want to test the deployment of a Node app, you can use \nopenvidu-js-node\n\n\n\n\n\n\n\n\n\n\nPHP, Ruby, Python, .NET...\n\n\nWe are not going to spell out in detail what is to be done with the rest of backend technologies, but you can get the idea from the Java and Node steps above. It is always the same process: take your app to your instance, place it under \n/opt/\n, configure Nginx and Supervisor (this last with the necessary launching script depending on your technology) and relaunch both services. Be sure that your machine has all the necessary dependencies and technologies to execute your application, depending on the framework (Java for a Java app, Node for a Node app, Ruby for a Ruby app...)\n\n\nVoil\u00e0! It is really this simple.\n\n\nPS: Multiple apps in the same instance\n\n\nTo launch multiple apps in the same instance, just store each one of them inside its own folder under \n/opt/\n. For example:\n\n\n\n\n/opt/YOUR_APP_1\n : will be available at \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_1/\n\n\n/opt/YOUR_APP_2\n : will be available at \nhttps://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_2/\n\n\n\n\nThe other steps explained above also need some adjustments related to paths:\n\n\n\n\n\n\nConfigure Nginx: now it would be...\n\n\nlocation /YOUR_APP_1 {\n  rewrite /YOUR_APP_1(.*) /$1 break;\n  proxy_pass https://localhost:PORT1;\n}\n\nlocation /YOUR_APP_2 {\n  rewrite /YOUR_APP_2(.*) /$1 break;\n  proxy_pass https://localhost:PORT2;\n}\n\n\n\n\n\n\n\nConfigure Supervisor: now...\n\n\n  [program:YOUR_APP_1]\n  command=/bin/bash /opt/YOUR_APP_1/YOUR_LAUNCHER_1.sh YOUR_APP1_PARAM_1 YOUR_APP1_PARAM_2 ...\n  redirect_stderr=true\n\n  [program:YOUR_APP_2]\n  command=/bin/bash /opt/YOUR_APP_2/YOUR_LAUNCHER_2.sh YOUR_APP2_PARAM_1 YOUR_APP2_PARAM_2 ...\n  redirect_stderr=true\n\n\n\n\n\n\n\n\n\n\nConnecting your external app to CloudFormation OpenVidu Server\n\n\nThe best production setup for OpenVidu is having your application deployed in a different dedicated server. That is, not being included in the same host as OpenVidu Server, which is the scenario explained in the \nprevious section\n (that all-in-one scenario is easier for the first approach to the deployment of your OpenVidu app. Try it if you want detailed instructions on how to deploy your app).\n\n\nOnce you have deployed your CloudFormation OpenVidu Server and checked that it is up and running, and after setting up your own application in its dedicated server:\n\n\n\n\nMake sure you know your \nOpenVidu Server public IP\n. That includes the protocol (\nhttps\n), the location and the port. For example: \nhttps://YOUR_SERVER_IP:8443/\n\n\nUse it in your application server to perform the \nREST\n operations, or to initialize your OpenVidu object if you are making use of \nopenvdiu-java-client\n or \nopenvidu-node-client\n :\n\n\nREST\n operations to \nhttps://OPENVIDUSERVER_PUBLIC_IP/api/METHOD\n \n\n\nopenvidu-java-client\n entrypoint is \nnew OpenVidu(OPENVIDUSERVER_PUBLIC_IP, OPENVIDU_SECRET)\n\n\nopenvidu-node-client\n entrypoint is \nnew OpenVidu(OPENVIDUSERVER_PUBLIC_IP, OPENVIDU_SECRET)\n \n\n\n\n\n\n\n\n\n\n\n\n\nIn the one-server-scenario of the \nprevious section\n the OpenVidu Server public IP would be \nhttps://localhost:8443\n, as both OpenVidu Server and your app live in the same host.", 
            "title": "Deploying OpenVidu Server and your app on AWS"
        }, 
        {
            "location": "/deployment/deploying-aws/#deploying-openvidu-server-on-aws-with-cloud-formation", 
            "text": "The deployment of OpenVidu can be a piece of cake if you have an AWS account. Just follow these steps:", 
            "title": "Deploying OpenVidu Server on AWS with Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-aws/#1-access-to-the-console-of-aws-cloud-formation", 
            "text": "Go to CloudFormation", 
            "title": "1. Access to the console of AWS Cloud Formation"
        }, 
        {
            "location": "/deployment/deploying-aws/#2-click-on-create-stack", 
            "text": "", 
            "title": "2. Click on Create Stack"
        }, 
        {
            "location": "/deployment/deploying-aws/#3-option-specify-an-amazon-s3-template-url-with-the-following-url", 
            "text": "https://s3-eu-west-1.amazonaws.com/aws.openvidu.io/CF-OpenVidu-latest.json \n   Copy", 
            "title": "3. Option Specify an Amazon S3 template URL with the following URL"
        }, 
        {
            "location": "/deployment/deploying-aws/#4-complete-the-configuration-fields", 
            "text": "We provide 3 different scenarios: you can use the default  SELF-SIGNED CERTIFICATE  stored in the application (users will need to accept the security alert) or if you have a custom domain, either allow  LET'S ENCRYPT  to automatically generate a valid and free certificate for your domain or use your own  CUSTOM CERTIFICATE  if you already have one.  \n   \n     \n       \n       Self-Signed certificate \n       Let's Encrypt  certificate \n       Custom certificate \n     \n     \n       Stack name \n       Your choice \n       Your choice \n       Your choice \n     \n     \n       Type of SSL Certificate \n       selfsigned \n       letsencrypt \n       owncert \n     \n     \n       Email \n       \n       Your choice \n       \n     \n     \n       Fully qualified domain name \n       \n       Your custom domain (for example:  openvidu.io ) \n       Your custom domain (for example:  openvidu.io ) \n     \n     \n       Elastic IP \n       \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n       One AWS Elastic IP you generated (check  AWS Docs  to generate a new one) \n     \n     \n       CRT File \n       \n       \n       Content of your  .crt  file -----BEGIN CERTIFICATE----- fooFOOfooFOOfooFOOfoo... -----END CERTIFICATE----- \n     \n     \n       KEY File \n       \n       \n       Content of your  .key  file -----BEGIN RSA PRIVATE KEY----- fooFOOfooFOOfooFOOfoo... -----END RSA PRIVATE KEY----- \n     \n     \n       OpenVidu Secret \n       Your choice \n       Your choice \n       Your choice \n     \n     \n       Instance Type \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n       Your choice (at least  t2.medium  recommended) \n     \n     \n       KeyName \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one) \n       Your choice (check  AWS Docs  to create a new one)", 
            "title": "4. Complete the configuration fields"
        }, 
        {
            "location": "/deployment/deploying-aws/#5-create-your-stack", 
            "text": "No extra options are necessary. Click on   Next  \u279e  Next  \u279e  Create  CREATE_IN_PROGRESS  status will show up. You will now have to wait for a few minutes until it shows  CREATE_COMPLETE .", 
            "title": "5. Create your Stack"
        }, 
        {
            "location": "/deployment/deploying-aws/#6-access-and-test-your-openvidu-server-through-your-new-ip", 
            "text": "After status changes to  CREATE_COMPLETE , go to  Outputs  tab to get your brand new IP and click on it (or if you have deployed under your own custom domain, then you should access through it).  \n     \n    You will connect to your OpenVidu dashboard. To access to it use:   OPENVIDUAPP  as username  The secret you chose on  Step 4  as password (field  OpenVidu Secret  in the table).    At OpenVidu dashboard you can test the video transmission. You can now add your own application to your instance. To learn how check the  next section .", 
            "title": "6. Access and test your OpenVidu Server through your new IP"
        }, 
        {
            "location": "/deployment/deploying-aws/#adding-your-own-app-to-cloudformation-openvidu-server", 
            "text": "Once you have deployed your CloudFormation OpenVidu Server and checked that it is up and running, you can easily add your own application to the instance. Follow these steps:", 
            "title": "Adding your own app to CloudFormation OpenVidu Server"
        }, 
        {
            "location": "/deployment/deploying-aws/#1-upload-your-app-to-your-ec2-instance", 
            "text": "In Linux/Mac you can use  scp  command. In Windows (or If you prefer a more friendly GUI) you can use  FileZilla . Furthermore, if your app is stored in a GitHub repo, you can directly clone it once you connect to your instance.  Remember that the key will be the same you indicated when configuring the  CloudFormation fields .", 
            "title": "1. Upload your app to your EC2 instance"
        }, 
        {
            "location": "/deployment/deploying-aws/#2-connect-to-your-ec2-instance-through-ssh", 
            "text": "Remember that the key will be the same you indicated when configuring the  CloudFormation fields . In case of doubt, check  AWS docs .", 
            "title": "2. Connect to your EC2 instance through SSH"
        }, 
        {
            "location": "/deployment/deploying-aws/#3-configure-your-app", 
            "text": "Depending on the framework of your app:", 
            "title": "3. Configure your app"
        }, 
        {
            "location": "/deployment/deploying-aws/#plain-htmlcssjs", 
            "text": "If your app doesn't have a server-side and it is plain HTML, CSS and JavaScript, you just have to add your web files into  /var/www/html/ . You will have instant access to it through  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/   If you want to test the deployment of a plain HTML/CSS/JS app, you can use  openvidu-insecure-js", 
            "title": "Plain HTML/CSS/JS"
        }, 
        {
            "location": "/deployment/deploying-aws/#java", 
            "text": "Copy your JAR or WAR into  /opt/    Write a script to launch your app with all the parameters it needs, and store it under  /opt/ . For example, a file  /opt/YOUR_LAUNCHER.sh  containing:  cd /opt\njava -jar -Dserver.port=4040 myapp.jar   IMPORTANT 1 : It is crucial to navigate to  /opt  before the launching command. Otherwise, the system will surely have some problems for finding your files  IMPORTANT 2 : Obviously your app will need Java to run. You must install the correct version of Java in your machine (check version:  java -version )  IMPORTANT 3 : Make sure the script you made is executable.(For Linux you could do like this  chmod +x YOUR_LAUNCHER.sh )     Configure Nginx: add a new  location  directive to the file  /etc/nginx/sites-enabled/default , inside the  server { }  group:    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }  For example    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }    Configure Supervisor: add the script you wrote in the second step to the file  /etc/supervisor/conf.d/openvidu.conf  like this:    [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true  Now your  /etc/supervisor/conf.d/openvidu.conf  must looks like this:    [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true   To connect your Java app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the  REST API  or  openvidu-java-client ), you will need to use the URL  https://localhost:8443 .  localhost  because both your app and OpenVidu Server run in the same machine.  8443  because there's where OpenVidu Server listens for petitions. For example, our tutorial  openvidu-js-java  sets this parameter as an environment variable  right here .     Restart Nginx:  systemctl restart nginx    Restart Supervisor:  systemctl restart supervisor    You will have access to your app through  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/    Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging:  /var/log/nginx/  (info about the proxy),  /var/log/supervisor/  (output of your app). You can also try to connect to your app directly through the port like  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT   If you want to test the deployment of a Java app, you can use  openvidu-js-java  or  openvidu-mvc-java  ( release here )", 
            "title": "Java"
        }, 
        {
            "location": "/deployment/deploying-aws/#node", 
            "text": "Add your web files into  /opt/    Write a script to launch your app with all the parameters it needs, and store it under  /opt/ . For example, a file  /opt/YOUR_LAUNCHER.sh  containing:  cd /opt\nnode myserver.js 4040   IMPORTANT 1 : It is crucial to navigate to  /opt  before the launching command. Otherwise, the system will surely have some problems for finding your files  IMPORTANT 2 : Obviously your app will need Node to run. You must install the correct version of Node in your machine (check version:  nodejs -v )  IMPORTANT 3 : Make sure the script you made is executable.(For Linux you could do like this  chmod +x YOUR_LAUNCHER.sh )     Configure Nginx: add a new  location  directive to the file  /etc/nginx/sites-enabled/default , inside the  server { }  group::    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:PORT;\n  }  For example    location / {\n    rewrite /(.*) /$1 break;\n    proxy_pass https://localhost:4040;\n  }    Restart Nginx:  systemctl restart nginx    Configure Supervisor: add the script you wrote in the second step to  /etc/supervisor/conf.d/openvidu.conf  like this:    [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true  Now your  /etc/supervisor/conf.d/openvidu.conf  must looks like this:    [supervisord]\n  nodaemon=true\n  logfile=/var/log/supervisor/supervisord.log\n  pidfile=/var/run/supervisord.pid\n  loglevel=debug\n\n  [program:openvidu-server]\n  command=java -jar -Dopenvidu.secret=\"MY_SECRET\" -Dserver.ssl.enabled=false -Dopenvidu.pu$\n\n  [program:YOUR_APP]\n  command=/bin/bash /opt/YOUR_LAUNCHER.sh YOUR_APP_PARAM_1 YOUR_APP_PARAM_2 ...\n  redirect_stderr=true   To connect your Node app to OpenVidu Server in order to get your sessionIds and tokens (whether you use the  REST API  or  openvidu-node-client ), you will need to use the URL  https://localhost:8443 .  localhost  because both your app and OpenVidu Server run in the same machine.  8443  because there's where OpenVidu Server listens for petitions. For example, our tutorial  openvidu-js-node  expects this parameter as the first argument on launch command  right here .     Restart Supervisor:  systemctl restart supervisor    You will have access to your app through  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/    Troubleshooting: If your app is not working as expected, there are a few files you should check for debugging:  /var/log/nginx/  (info about the proxy),  /var/log/supervisor/  (output of your app). You can also try to connect to your app directly through the port like  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN:YOUR_APP_PORT   If you want to test the deployment of a Node app, you can use  openvidu-js-node", 
            "title": "Node"
        }, 
        {
            "location": "/deployment/deploying-aws/#php-ruby-python-net", 
            "text": "We are not going to spell out in detail what is to be done with the rest of backend technologies, but you can get the idea from the Java and Node steps above. It is always the same process: take your app to your instance, place it under  /opt/ , configure Nginx and Supervisor (this last with the necessary launching script depending on your technology) and relaunch both services. Be sure that your machine has all the necessary dependencies and technologies to execute your application, depending on the framework (Java for a Java app, Node for a Node app, Ruby for a Ruby app...)  Voil\u00e0! It is really this simple.", 
            "title": "PHP, Ruby, Python, .NET..."
        }, 
        {
            "location": "/deployment/deploying-aws/#ps-multiple-apps-in-the-same-instance", 
            "text": "To launch multiple apps in the same instance, just store each one of them inside its own folder under  /opt/ . For example:   /opt/YOUR_APP_1  : will be available at  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_1/  /opt/YOUR_APP_2  : will be available at  https://AMAZON_URL_OR_YOUR_CUSTOM_DOMAIN/YOUR_APP_2/   The other steps explained above also need some adjustments related to paths:    Configure Nginx: now it would be...  location /YOUR_APP_1 {\n  rewrite /YOUR_APP_1(.*) /$1 break;\n  proxy_pass https://localhost:PORT1;\n}\n\nlocation /YOUR_APP_2 {\n  rewrite /YOUR_APP_2(.*) /$1 break;\n  proxy_pass https://localhost:PORT2;\n}    Configure Supervisor: now...    [program:YOUR_APP_1]\n  command=/bin/bash /opt/YOUR_APP_1/YOUR_LAUNCHER_1.sh YOUR_APP1_PARAM_1 YOUR_APP1_PARAM_2 ...\n  redirect_stderr=true\n\n  [program:YOUR_APP_2]\n  command=/bin/bash /opt/YOUR_APP_2/YOUR_LAUNCHER_2.sh YOUR_APP2_PARAM_1 YOUR_APP2_PARAM_2 ...\n  redirect_stderr=true", 
            "title": "PS: Multiple apps in the same instance"
        }, 
        {
            "location": "/deployment/deploying-aws/#connecting-your-external-app-to-cloudformation-openvidu-server", 
            "text": "The best production setup for OpenVidu is having your application deployed in a different dedicated server. That is, not being included in the same host as OpenVidu Server, which is the scenario explained in the  previous section  (that all-in-one scenario is easier for the first approach to the deployment of your OpenVidu app. Try it if you want detailed instructions on how to deploy your app).  Once you have deployed your CloudFormation OpenVidu Server and checked that it is up and running, and after setting up your own application in its dedicated server:   Make sure you know your  OpenVidu Server public IP . That includes the protocol ( https ), the location and the port. For example:  https://YOUR_SERVER_IP:8443/  Use it in your application server to perform the  REST  operations, or to initialize your OpenVidu object if you are making use of  openvdiu-java-client  or  openvidu-node-client  :  REST  operations to  https://OPENVIDUSERVER_PUBLIC_IP/api/METHOD    openvidu-java-client  entrypoint is  new OpenVidu(OPENVIDUSERVER_PUBLIC_IP, OPENVIDU_SECRET)  openvidu-node-client  entrypoint is  new OpenVidu(OPENVIDUSERVER_PUBLIC_IP, OPENVIDU_SECRET)         In the one-server-scenario of the  previous section  the OpenVidu Server public IP would be  https://localhost:8443 , as both OpenVidu Server and your app live in the same host.", 
            "title": "Connecting your external app to CloudFormation OpenVidu Server"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/", 
            "text": "Deploying on Ubuntu with native services and executables\n\n\n\n\n\n\nInstallation process\n\n\nIf you prefer having KMS installed in your EC2 machine and your own version of openvidu-server, follow these few steps. \nUbuntu xenial 14.04\n and \nUbuntu trusty 16.04\n are supported.\n\n\n1. Install KMS (in first command: \nxenial\n for 16.04, \ntrusty\n for 14.04)\n\n\necho \ndeb http://ubuntu.kurento.org xenial kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get -y install kurento-media-server-6.0\n\n\n\n\n2. Install COTURN\n\n\nsudo apt-get -y install coturn\n\n\n\n\n\n\nThis is a great implementation of a STUN/TURN server, necessary for connecting your users under some complicated circumstances. You can check its documentation \nhere\n.\nIf there's any problem with the installation on \nUbuntu trusty 14.04\n:\n\n\nwget -c http://ftp.us.debian.org/debian/pool/main/c/coturn/coturn_4.2.1.2-1_amd64.deb\n\n\nsudo dpkg -i coturn_4.2.1.2-1_amd64.deb\n\n\nsudo apt-get -f -y install\n\n\nsudo dpkg -i coturn_4.2.1.2-1_amd64.deb\n\n\n\n\n3. File \n/etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini\n\n\nstunServerAddress=YOUR_MACHINE_PUBLIC_IP\nstunServerPort=3478\nturnURL=USER:PASS@YOUR_MACHINE_PUBLIC_IP:3478\n\n\n\n\n4. File \n/etc/turnserver.conf\n\n\nexternal-ip=YOUR_MACHINE_PUBLIC_IP\nfingerprint\nuser=USER:PASS\nlt-cred-mech\nrealm=kurento.org\nlog-file=/var/log/turnserver/turnserver.log\nsimple-log\n\n\n\n\n5. File \n/etc/default/coturn\n\n\nTURNSERVER_ENABLED=1\n\n\n\n\n6. Init services\n\n\nsudo service coturn restart\nsudo service kurento-media-server-6.0 restart\n\n\n\n\n7A. Init openvidu-server Docker container...\n\n\nsudo docker run -d -p 8443:8443 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ --net=\nhost\n openvidu/openvidu-server\n\n\n\n\n\n\nTo quickly install the latest official stable version of \nDocker CE\n:\n\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n\n\nsudo apt-get update\n\n\nsudo apt-get -y install docker-ce\n\n\n\n\n\n\nGo to \nUsing your own certificate\n to add your certificate to the container instead of using the self-signed default one (which will launch a security warning on the user's browser).\n\n\n7B. ...or init your own openvidu-server executable\n\n\njava -jar -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ openvidu-server.jar \n\n\n\n\n\nGo to \nUsing your own certificate\n to add your certificate to the JAR instead of using the self-signed default one (which will launch a security warning on the user's browser).\n\n\n8. Finally check your server\n\n\nYou can connect to OpenVidu dashboard through \nhttps://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:8443\n (authorization is \nOPENVIDUAPP:YOUR_SECRET\n). Make sure you allow TCP and UDP inbound connections to your machine!\n\n\nTo connect your application to OpenVidu Server, use the same URL \nhttps://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:8443\n. To learn more, this scenario is exactly the same as portrayed \nhere\n.\n\n\nServer network requirements\n\n\nIn order for this deployment to work, you will have to meet 2 sets of needs in the machine hosting your services:\n\n\n\n\n\n\nFirst of all, you certainly need the machine to have a \npublic, reachable IP\n. The reason is pretty simple: we are precisely installing \nCOTURN\n service to cover those situations where the final users are hidden behind NATs or complex networks (\nlearn more\n). If the \nCOTURN\n itself is running inside an unreachable machine, your video transmission could fail in certain cases.\n\n\n\n\n\n\nBesides, the server needs some \nports\n opened in the firewall:\n\n\n\n\n3478 TCP \n UDP\n (\nCOTURN\n listens on port 3478 by default)\n\n\n49152 - 65535 UDP\n (WebRTC exchanges media through any of these ports)\n\n\n\n\n\n\n\n\n\n\nIf you were still in trouble, we provide a ready-to-use Amazon CloudFormation Stack to easily deploy OpenVidu in a few minutes \nhere\n.\n\n\n\n\nArchitectures\n\n\nYou can have the following scenarios depending on how many machines you have and what architecture you prefer. What are the advantages and disadvantages of each one of them? Well, it really depends on the power of the machine, the nature of your application and the load expected. In general, having all the services running in one machine will reduce its performance and scalability, but on the other hand, makes it easier the process of installation, configuration and launching.\n\n\nIf you are deploying with these instructions for the first time, we recommend using only one machine. When you verify that everything is working as expected, you can try different configurations to compare overall performance and load capacity.\n\n\n\n  \n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \nApp, OpenVidu Server and KMS run in the same machine\n\n      \nApp runs in its own machine. OpenVidu Server and KMS run in the same machine\n\n      \nApp, OpenVidu Server and KMS all run in different machines\n\n    \n\n    \n\n  \n\n\n\n\n\nThe instructions above portray scenarios 1 and 2 in the image. In other words, we are supposing that OpenVidu Server and KMS will be hosted in the same machine. The only difference between options 1-2 and option 3 is that for steps 7A and 7B, another parameter is required when launching your openvidu-server:\n\n\n7A\n\n\ndocker run -d -p 8443:8443 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ -e kms.uris=[\\\nws://YOUR_KMS_MACHINE_IP:8888/kurento\\\n] openvidu/openvidu-server\n\n\n\n\n7B\n\n\njava -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ -Dkms.uris=[\\\nws://YOUR_KMS_MACHINE_IP:8888/kurento\\\n] -jar openvidu-server.jar", 
            "title": "Deploying OpenVidu in Ubuntu"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#installation-process", 
            "text": "If you prefer having KMS installed in your EC2 machine and your own version of openvidu-server, follow these few steps.  Ubuntu xenial 14.04  and  Ubuntu trusty 16.04  are supported.", 
            "title": "Installation process"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#1-install-kms-in-first-command-xenial-for-1604-trusty-for-1404", 
            "text": "echo  deb http://ubuntu.kurento.org xenial kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get -y install kurento-media-server-6.0", 
            "title": "1. Install KMS (in first command: xenial for 16.04, trusty for 14.04)"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#2-install-coturn", 
            "text": "sudo apt-get -y install coturn   This is a great implementation of a STUN/TURN server, necessary for connecting your users under some complicated circumstances. You can check its documentation  here .\nIf there's any problem with the installation on  Ubuntu trusty 14.04 :  wget -c http://ftp.us.debian.org/debian/pool/main/c/coturn/coturn_4.2.1.2-1_amd64.deb  sudo dpkg -i coturn_4.2.1.2-1_amd64.deb  sudo apt-get -f -y install  sudo dpkg -i coturn_4.2.1.2-1_amd64.deb", 
            "title": "2. Install COTURN"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#3-file-etckurentomoduleskurentowebrtcendpointconfini", 
            "text": "stunServerAddress=YOUR_MACHINE_PUBLIC_IP\nstunServerPort=3478\nturnURL=USER:PASS@YOUR_MACHINE_PUBLIC_IP:3478", 
            "title": "3. File /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#4-file-etcturnserverconf", 
            "text": "external-ip=YOUR_MACHINE_PUBLIC_IP\nfingerprint\nuser=USER:PASS\nlt-cred-mech\nrealm=kurento.org\nlog-file=/var/log/turnserver/turnserver.log\nsimple-log", 
            "title": "4. File /etc/turnserver.conf"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#5-file-etcdefaultcoturn", 
            "text": "TURNSERVER_ENABLED=1", 
            "title": "5. File /etc/default/coturn"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#6-init-services", 
            "text": "sudo service coturn restart\nsudo service kurento-media-server-6.0 restart", 
            "title": "6. Init services"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#7a-init-openvidu-server-docker-container", 
            "text": "sudo docker run -d -p 8443:8443 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ --net= host  openvidu/openvidu-server   To quickly install the latest official stable version of  Docker CE :  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -  sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"  sudo apt-get update  sudo apt-get -y install docker-ce    Go to  Using your own certificate  to add your certificate to the container instead of using the self-signed default one (which will launch a security warning on the user's browser).", 
            "title": "7A. Init openvidu-server Docker container..."
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#7b-or-init-your-own-openvidu-server-executable", 
            "text": "java -jar -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ openvidu-server.jar    Go to  Using your own certificate  to add your certificate to the JAR instead of using the self-signed default one (which will launch a security warning on the user's browser).", 
            "title": "7B. ...or init your own openvidu-server executable"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#8-finally-check-your-server", 
            "text": "You can connect to OpenVidu dashboard through  https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:8443  (authorization is  OPENVIDUAPP:YOUR_SECRET ). Make sure you allow TCP and UDP inbound connections to your machine!  To connect your application to OpenVidu Server, use the same URL  https://YOUR_OPENVIDU_SERVER_MACHINE_PUBLIC_IP:8443 . To learn more, this scenario is exactly the same as portrayed  here .", 
            "title": "8. Finally check your server"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#server-network-requirements", 
            "text": "In order for this deployment to work, you will have to meet 2 sets of needs in the machine hosting your services:    First of all, you certainly need the machine to have a  public, reachable IP . The reason is pretty simple: we are precisely installing  COTURN  service to cover those situations where the final users are hidden behind NATs or complex networks ( learn more ). If the  COTURN  itself is running inside an unreachable machine, your video transmission could fail in certain cases.    Besides, the server needs some  ports  opened in the firewall:   3478 TCP   UDP  ( COTURN  listens on port 3478 by default)  49152 - 65535 UDP  (WebRTC exchanges media through any of these ports)      If you were still in trouble, we provide a ready-to-use Amazon CloudFormation Stack to easily deploy OpenVidu in a few minutes  here .", 
            "title": "Server network requirements"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#architectures", 
            "text": "You can have the following scenarios depending on how many machines you have and what architecture you prefer. What are the advantages and disadvantages of each one of them? Well, it really depends on the power of the machine, the nature of your application and the load expected. In general, having all the services running in one machine will reduce its performance and scalability, but on the other hand, makes it easier the process of installation, configuration and launching.  If you are deploying with these instructions for the first time, we recommend using only one machine. When you verify that everything is working as expected, you can try different configurations to compare overall performance and load capacity.  \n   \n     \n   \n   \n   \n     \n       App, OpenVidu Server and KMS run in the same machine \n       App runs in its own machine. OpenVidu Server and KMS run in the same machine \n       App, OpenVidu Server and KMS all run in different machines \n     \n     \n     The instructions above portray scenarios 1 and 2 in the image. In other words, we are supposing that OpenVidu Server and KMS will be hosted in the same machine. The only difference between options 1-2 and option 3 is that for steps 7A and 7B, another parameter is required when launching your openvidu-server:", 
            "title": "Architectures"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#7a", 
            "text": "docker run -d -p 8443:8443 -e openvidu.secret=YOUR_SECRET -e openvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ -e kms.uris=[\\ ws://YOUR_KMS_MACHINE_IP:8888/kurento\\ ] openvidu/openvidu-server", 
            "title": "7A"
        }, 
        {
            "location": "/deployment/deploying-ubuntu/#7b", 
            "text": "java -Dopenvidu.secret=YOUR_SECRET -Dopenvidu.publicurl=https://YOUR_MACHINE_PUBLIC_IP:8443/ -Dkms.uris=[\\ ws://YOUR_KMS_MACHINE_IP:8888/kurento\\ ] -jar openvidu-server.jar", 
            "title": "7B"
        }, 
        {
            "location": "/deployment/custom-certificate/", 
            "text": "Using your own certificate\n\n\n\n\n\n\nFor a JAR binary of OpenVidu Server\n\n\nYou will need a Java keystore (\n.jks\n). Check \nGet JKS from CRT and KEY\n section to see how to get it from your certificate's files.\nIn order to use your JKS, just set the following values for these properties on launch:\n\n\n\n\nserver.ssl.key-store\n\n\nserver.ssl.key-store-password\n\n\nserver.ssl.key-alias\n\n\n\n\n\n\nExample\n\n\njava -jar -Dopenvidu.secret=YOUR_SECRET -Dserver.ssl.key-store=PATH/TO/YOUR/KEYSTORE.jks -Dserver.ssl.key-store-password=YOUR_KEYSTORE_PASSWORD -Dserver.ssl.key-alias=YOUR_KEYSTORE_ALIAS openvidu-server.jar\n\n\n\n\n\n\nFor the Docker container of OpenVidu Server\n\n\nYou will need a Java keystore (\n.jks\n). Check \nGet JKS from CRT and KEY\n section to see how to get it from your certificate's files.\nIn order to use your JKS, just set the following values for these properties on launch:\n\n\n\n\nserver.ssl.key-store\n\n\nserver.ssl.key-store-password\n\n\nserver.ssl.key-alias\n\n\n\n\nYou must also indicate the \nvolume\n flag (-v) to mount your keystore file, letting know Docker the location of the file and that it should be only readable:\n\n\n\n\n-v /ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:/ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:ro\n\n\n\n\n\n\nExample\n\n\ndocker run -d -p 8443:8443 --rm -v /ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:/ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:ro -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=YOUR_SECRET -e server.ssl.key-store=/ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks -e server.ssl.key-store-password=YOUR_KEYSTORE_PASSWORD -e server.ssl.key-alias=YOUR_KEYSTORE_ALIAS openvidu/openvidu-server-kms\n\n\n\n\n\n\nFor the CloudFormation of OpenVidu Server\n\n\nFirst of all, remember we provide a super simple way of using a \nFREE\n, \nAUTOMATIC\n and 100% \nVALID\n certificate thanks to Let's Encrypt technology: when deploying your CloudFormation Stack, just fill in the form fields with the values from the column \nLET'S ENCRYPT CERTIFICATE\n.\n\n\nIf, however, you have already purchased your own certificate and you are determined to use it, you can easily add it to your CloudFormation stack. Just fill in the form fields with the values from the column \nCUSTOM CERTIFICATE\n.\n\n\n\n\nGet JKS from CRT and KEY\n\n\nOpenVidu Server is a Java application and therefore needs a Java keystore (.jks) for providing security certificates. If you don't have it, you can easily obtain a \n.jks\n file from your certificate (\n.crt\n) and private key (\n.key\n) files by using \nopenssl\n and \nkeytool\n :\n\n\nopenssl pkcs12 -export -name YOUR_CERT_NAME -in YOUR_CRT.crt -inkey YOUR_PRIVATE_KEY.key -out p12keystore.p12\n\n\n\n\nkeytool -importkeystore -destkeystore YOUR_KEYSTORE_NAME.jks -srckeystore p12keystore.p12 -srcstoretype pkcs12 -alias YOUR_JKS_ALIAS", 
            "title": "Using your own certificate"
        }, 
        {
            "location": "/deployment/custom-certificate/#for-a-jar-binary-of-openvidu-server", 
            "text": "You will need a Java keystore ( .jks ). Check  Get JKS from CRT and KEY  section to see how to get it from your certificate's files.\nIn order to use your JKS, just set the following values for these properties on launch:   server.ssl.key-store  server.ssl.key-store-password  server.ssl.key-alias", 
            "title": "For a JAR binary of OpenVidu Server"
        }, 
        {
            "location": "/deployment/custom-certificate/#example", 
            "text": "java -jar -Dopenvidu.secret=YOUR_SECRET -Dserver.ssl.key-store=PATH/TO/YOUR/KEYSTORE.jks -Dserver.ssl.key-store-password=YOUR_KEYSTORE_PASSWORD -Dserver.ssl.key-alias=YOUR_KEYSTORE_ALIAS openvidu-server.jar", 
            "title": "Example"
        }, 
        {
            "location": "/deployment/custom-certificate/#for-the-docker-container-of-openvidu-server", 
            "text": "You will need a Java keystore ( .jks ). Check  Get JKS from CRT and KEY  section to see how to get it from your certificate's files.\nIn order to use your JKS, just set the following values for these properties on launch:   server.ssl.key-store  server.ssl.key-store-password  server.ssl.key-alias   You must also indicate the  volume  flag (-v) to mount your keystore file, letting know Docker the location of the file and that it should be only readable:   -v /ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:/ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:ro", 
            "title": "For the Docker container of OpenVidu Server"
        }, 
        {
            "location": "/deployment/custom-certificate/#example_1", 
            "text": "docker run -d -p 8443:8443 --rm -v /ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:/ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks:ro -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=YOUR_SECRET -e server.ssl.key-store=/ABSOLUTE/PATH/TO/YOUR/KEYSTORE.jks -e server.ssl.key-store-password=YOUR_KEYSTORE_PASSWORD -e server.ssl.key-alias=YOUR_KEYSTORE_ALIAS openvidu/openvidu-server-kms", 
            "title": "Example"
        }, 
        {
            "location": "/deployment/custom-certificate/#for-the-cloudformation-of-openvidu-server", 
            "text": "First of all, remember we provide a super simple way of using a  FREE ,  AUTOMATIC  and 100%  VALID  certificate thanks to Let's Encrypt technology: when deploying your CloudFormation Stack, just fill in the form fields with the values from the column  LET'S ENCRYPT CERTIFICATE .  If, however, you have already purchased your own certificate and you are determined to use it, you can easily add it to your CloudFormation stack. Just fill in the form fields with the values from the column  CUSTOM CERTIFICATE .", 
            "title": "For the CloudFormation of OpenVidu Server"
        }, 
        {
            "location": "/deployment/custom-certificate/#get-jks-from-crt-and-key", 
            "text": "OpenVidu Server is a Java application and therefore needs a Java keystore (.jks) for providing security certificates. If you don't have it, you can easily obtain a  .jks  file from your certificate ( .crt ) and private key ( .key ) files by using  openssl  and  keytool  :  openssl pkcs12 -export -name YOUR_CERT_NAME -in YOUR_CRT.crt -inkey YOUR_PRIVATE_KEY.key -out p12keystore.p12  keytool -importkeystore -destkeystore YOUR_KEYSTORE_NAME.jks -srckeystore p12keystore.p12 -srcstoretype pkcs12 -alias YOUR_JKS_ALIAS", 
            "title": "Get JKS from CRT and KEY"
        }, 
        {
            "location": "/developing/", 
            "text": "Developing OpenVidu\n\n\nThis documentation is suitable for \nUbuntu 14.04\n or \nUbuntu 16.04\n. Packages required:\n\n\n\n\n\n\n\n\nDependecy\n\n\nCheck version\n\n\nInstall\n\n\n\n\n\n\n\n\n\n\njava 8 JDK\n\n\njava -version\n\n\nsudo apt-get install -y default-jdk\n\n\n\n\n\n\nnode\n\n\nnode -v\n\n\nsudo curl -sL https://deb.nodesource.com/setup_6.x | sudo bash -\nsudo apt-get install -y nodejs\n\n\n\n\n\n\nmaven\n\n\nmvn -v\n\n\nsudo apt-get install -y maven\n\n\n\n\n\n\nangular-cli\n\n\nng -v\n\n\nsudo npm install -g @angular/cli\n\n\n\n\n\n\n\n\nSetup for development\n\n\nHere we show how to develop an Angular app (\nopenvidu-testapp\n) with \nopenvidu-browser\n and \nopenvidu-server\n as local dependencies, waiting to be modified as you want.\n\n\n1) \nInstall KMS\n\n\n2) \nAdd Kurento parent Maven dependency to your local repo\n\n\n3) Clone repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu.git\n\n\n\n\n4) \nopenvidu/openvidu-browser/\n\n\nnpm install\nnpm run updatetsc\nsudo npm link\n\n\n\n\n5) \nopenvidu/\n\n\nmvn -DskipTests=true compile \n mvn -DskipTests=true install\n\n\n\n\n6) \nopenvidu/openvidu-testapp/\n\n\nnpm install\nnpm link openvidu-browser\nng serve\n\n\n\n\n7) Start KMS in your machine:\n\n\nsudo service kurento-media-server-6.0 restart\n\n\n\n\n8) \nopenvidu/openvidu-server/\n\n\nmvn exec:java\n\n\n\n\n(or if you prefer you can just run the Java application in your favourite IDE)\n\n\n\n\nAt these point, you can start modifying \nopenvidu-ng-testapp\n, \nopenvidu-browser\n or \nopenvidu-server\n.\n\n\n\n\n\n\nopenvidu-testapp\n :  the previous \"ng serve\" command will take care of refreshing the browser's page whenever any change takes place.\n\n\n\n\n\n\nopenvidu-browser\n : after modifying any typescript file, you will need to run the following command to update your changes:\n\n\n/openvidu/openvidu-browser\n \n\n\nnpm run updatetsc\n\n\n\n\n\n\nopenvidu-server\n : after modifying any file, there is no other alternative but to re-launch the java application if you want to update your changes.\n\n\n/openvidu/openvidu-server\n\n\nmvn clean exec:java\n\n\n(or re-launch the Java application in your IDE. Some IDE's support automatic re-launch in response to changes)\n\n\n\n\n\n\n\n\nSetup for advanced development: share the app through your network\n\n\nYou can also use \ndifferent machines\n in the \nsame network\n to build a more advanced development environment, so you can test the application in different devices at the same time. It's very similar to the process outlined above:\n\n\nYou will need a server for the built app (if you don't have any, we recommend \nhttp-server\n):\n\nnpm install -g http-server\n\n\nRun exactly the same commands as the process above, but on step \n6)\n skip \nng serve\n. We don't want Angular-CLI to serve our app. Instead, these commands will be the ones which you should launch (and relaunch to update your changes):\n\n\nopenvidu/openvidu-testapp/\n\n\nng build -op ./dist\ncd dist\nopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem\nhttp-server -S\n\n\n\n\nThis builds the Angular project, generate a self-signed certificate (which unfortunately is a mandatory requirement for http-server SSL) and serves the content with http-server.\n\n\nFinally, to launch the app connect to \nhttps://localhost:8080\n in the machine running the http-server and to \nhttps://[HOST]:8080\n in other devices of the same network (\n[HOST]\n being the IP of the machine running the http-server).\n\n\n\n\nInstalling KMS\n\n\nHow to \ninstall\n and \nrun\n KMS in your development machine:\n\n\nUbuntu 14.04 LTS Trusty (64 bits)\n\n\necho \ndeb http://ubuntu.kurento.org trusty kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install -y kurento-media-server-6.0\n\n\n\n\nUbuntu 16.04 LTS Xenial (64 bits)\n\n\necho \ndeb http://ubuntu.kurento.org xenial kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install -y kurento-media-server-6.0\n\n\n\n\nStart and stop the service\n\n\nsudo service kurento-media-server-6.0 start\nsudo service kurento-media-server-6.0 stop\n\n\n\n\nHere\n you can check Kurento's official documentation.\n\n\n\n\nAdding Kurento parent POM to your local respository\n\n\nYou will need development version of Kurento's parent POM in your local repository in order to compile the development version of \nopenvidu-server\n. To achieve this, add a file \n~/.m2/settings.xml\n with the following content (if it doesn't exist, create it on that exact path):\n\n\nsettings xmlns=\nhttp://maven.apache.org/SETTINGS/1.0.0\n\n  xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n  xsi:schemaLocation=\nhttp://maven.apache.org/SETTINGS/1.0.0\n                      http://maven.apache.org/xsd/settings-1.0.0.xsd\n\n    \nlocalRepository/\n\n    \ninteractiveMode/\n\n    \nusePluginRegistry/\n\n    \noffline/\n\n    \npluginGroups/\n\n    \nmirrors/\n\n    \nproxies/\n\n\n   \nprofiles\n\n        \nprofile\n\n            \nid\nkurento-develop\n/id\n\n            \nactivation\n\n              \nactiveByDefault\ntrue\n/activeByDefault\n\n            \n/activation\n\n\n            \nrepositories\n\n              \nrepository\n\n                  \nid\nkurento-snapshots\n/id\n\n                  \nname\nKurento Snapshot Repository\n/name\n\n                  \nurl\nhttp://maven.kurento.org/snapshots/\n/url\n\n                  \nreleases\n\n                      \nenabled\nfalse\n/enabled\n\n                  \n/releases\n\n                  \nsnapshots\n\n                      \nenabled\ntrue\n/enabled\n\n                  \n/snapshots\n\n              \n/repository\n\n            \n/repositories\n\n            \npluginRepositories\n\n              \npluginRepository\n\n                  \nid\nkurento-snapshots\n/id\n\n                  \nname\nKurento Snapshot Repository\n/name\n\n                  \nurl\nhttp://maven.kurento.org/snapshots/\n/url\n\n                  \nreleases\n\n                    \nenabled\nfalse\n/enabled\n\n                  \n/releases\n\n                  \nsnapshots\n\n                    \nenabled\ntrue\n/enabled\n\n                  \n/snapshots\n\n              \n/pluginRepository\n\n            \n/pluginRepositories\n\n\n       \n/profile\n\n    \n/profiles\n\n    \nactiveProfiles/\n\n\n/settings", 
            "title": "Developing OpenVidu"
        }, 
        {
            "location": "/developing/#developing-openvidu", 
            "text": "This documentation is suitable for  Ubuntu 14.04  or  Ubuntu 16.04 . Packages required:     Dependecy  Check version  Install      java 8 JDK  java -version  sudo apt-get install -y default-jdk    node  node -v  sudo curl -sL https://deb.nodesource.com/setup_6.x | sudo bash - sudo apt-get install -y nodejs    maven  mvn -v  sudo apt-get install -y maven    angular-cli  ng -v  sudo npm install -g @angular/cli", 
            "title": "Developing OpenVidu"
        }, 
        {
            "location": "/developing/#setup-for-development", 
            "text": "Here we show how to develop an Angular app ( openvidu-testapp ) with  openvidu-browser  and  openvidu-server  as local dependencies, waiting to be modified as you want.  1)  Install KMS  2)  Add Kurento parent Maven dependency to your local repo  3) Clone repo:  git clone https://github.com/OpenVidu/openvidu.git  4)  openvidu/openvidu-browser/  npm install\nnpm run updatetsc\nsudo npm link  5)  openvidu/  mvn -DskipTests=true compile   mvn -DskipTests=true install  6)  openvidu/openvidu-testapp/  npm install\nnpm link openvidu-browser\nng serve  7) Start KMS in your machine:  sudo service kurento-media-server-6.0 restart  8)  openvidu/openvidu-server/  mvn exec:java  (or if you prefer you can just run the Java application in your favourite IDE)   At these point, you can start modifying  openvidu-ng-testapp ,  openvidu-browser  or  openvidu-server .    openvidu-testapp  :  the previous \"ng serve\" command will take care of refreshing the browser's page whenever any change takes place.    openvidu-browser  : after modifying any typescript file, you will need to run the following command to update your changes:  /openvidu/openvidu-browser    npm run updatetsc    openvidu-server  : after modifying any file, there is no other alternative but to re-launch the java application if you want to update your changes.  /openvidu/openvidu-server  mvn clean exec:java  (or re-launch the Java application in your IDE. Some IDE's support automatic re-launch in response to changes)", 
            "title": "Setup for development"
        }, 
        {
            "location": "/developing/#setup-for-advanced-development-share-the-app-through-your-network", 
            "text": "You can also use  different machines  in the  same network  to build a more advanced development environment, so you can test the application in different devices at the same time. It's very similar to the process outlined above:  You will need a server for the built app (if you don't have any, we recommend  http-server ): npm install -g http-server  Run exactly the same commands as the process above, but on step  6)  skip  ng serve . We don't want Angular-CLI to serve our app. Instead, these commands will be the ones which you should launch (and relaunch to update your changes):  openvidu/openvidu-testapp/  ng build -op ./dist\ncd dist\nopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem\nhttp-server -S  This builds the Angular project, generate a self-signed certificate (which unfortunately is a mandatory requirement for http-server SSL) and serves the content with http-server.  Finally, to launch the app connect to  https://localhost:8080  in the machine running the http-server and to  https://[HOST]:8080  in other devices of the same network ( [HOST]  being the IP of the machine running the http-server).", 
            "title": "Setup for advanced development: share the app through your network"
        }, 
        {
            "location": "/developing/#installing-kms", 
            "text": "How to  install  and  run  KMS in your development machine:  Ubuntu 14.04 LTS Trusty (64 bits)  echo  deb http://ubuntu.kurento.org trusty kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install -y kurento-media-server-6.0  Ubuntu 16.04 LTS Xenial (64 bits)  echo  deb http://ubuntu.kurento.org xenial kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install -y kurento-media-server-6.0  Start and stop the service  sudo service kurento-media-server-6.0 start\nsudo service kurento-media-server-6.0 stop  Here  you can check Kurento's official documentation.", 
            "title": "Installing KMS"
        }, 
        {
            "location": "/developing/#adding-kurento-parent-pom-to-your-local-respository", 
            "text": "You will need development version of Kurento's parent POM in your local repository in order to compile the development version of  openvidu-server . To achieve this, add a file  ~/.m2/settings.xml  with the following content (if it doesn't exist, create it on that exact path):  settings xmlns= http://maven.apache.org/SETTINGS/1.0.0 \n  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n  xsi:schemaLocation= http://maven.apache.org/SETTINGS/1.0.0\n                      http://maven.apache.org/xsd/settings-1.0.0.xsd \n     localRepository/ \n     interactiveMode/ \n     usePluginRegistry/ \n     offline/ \n     pluginGroups/ \n     mirrors/ \n     proxies/ \n\n    profiles \n         profile \n             id kurento-develop /id \n             activation \n               activeByDefault true /activeByDefault \n             /activation \n\n             repositories \n               repository \n                   id kurento-snapshots /id \n                   name Kurento Snapshot Repository /name \n                   url http://maven.kurento.org/snapshots/ /url \n                   releases \n                       enabled false /enabled \n                   /releases \n                   snapshots \n                       enabled true /enabled \n                   /snapshots \n               /repository \n             /repositories \n             pluginRepositories \n               pluginRepository \n                   id kurento-snapshots /id \n                   name Kurento Snapshot Repository /name \n                   url http://maven.kurento.org/snapshots/ /url \n                   releases \n                     enabled false /enabled \n                   /releases \n                   snapshots \n                     enabled true /enabled \n                   /snapshots \n               /pluginRepository \n             /pluginRepositories \n\n        /profile \n     /profiles \n     activeProfiles/  /settings", 
            "title": "Adding Kurento parent POM to your local respository"
        }, 
        {
            "location": "/troubleshooting/", 
            "text": "Troubleshooting and FAQ\n\n\n\n\n\n\n1. Everything looks alright, but I cannot see any remote video\n\n\nYou have an app that uses OpenVidu to stream some video user-to-user, and the process looks perfectly okey. No errors on the console and all the OpenVidu events you are subscribed to are correctly triggered. So what's happening?\n\n\n99% of the time this is a problem related with \nOPENVIDU SERVER NOT HAVING A PUBLIC IP\n. To learn more about it, you can check \nthis FAQ\n. The quickest solution to this problem is to deploy in Amazon our ready-to-use OpenVidu Server with \nCloudFormation\n.\n\n\nIf you are a bit reluctant to this quick solution with Amazon CloudFormation, you can always deploy OpenVidu by yourself in Ubuntu 14.04 and 16.04. Check \nDeploying OpenVidu as a native service\n section to learn how to properly do it.\n\n\nBesides that, these are the recommended steps to follow when videos are not received:\n\n\n\n\nAccess your OpenVidu dashboard (\nhttps://YOUR_OPENVIDU_IP:8443\n) to quickly test the video transmission.\n\n\nPlease be sure that your OpenVidu Server host meets the \nnetwork requirements\n.\n\n\n\n\nThe other 1% of the time this can be an attempt of \naccessing the same camera from two different browsers at the same time\n. Remember that Chrome, Firefox, Opera, Safari and Edge are distinct processes which cannot generally access the same physical resource (as a webcam) at the same time on your computer. On the other hand, accessing the camera from different tabs of the same browser is tipically possible.\n\n\n2. Any tips to make easier the development of my app with OpenVidu?\n\n\nYou can do some things to improve your efficiency while using OpenVidu:\n\n\n\n\nMultiple tabs to test the video transmission\n\n\nYou can use multiple tabs in the same browser to test your video streams.\n\n\nWARNING\n: you may have trouble for testing with tabs from different browsers at the same time, as they compete for the camera access.\n\n\n\n\nBe very aware of the browser's console\n\n\nThere you can find logs reporting important stuff. Error messages can help you to solve many issues.\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n  \n\n  \n\n    \n\n      OpenVidu Browser is developed with both \nChrome\n (first image) and \nFirefox\n (second image) in mind in terms of logging. By default the browser's console displays OpenVidu's high-level messages (that's when the option 'Info' is enabled, as seen in the images). This means logs about OpenVidu objects being created and destroyed and logs for each triggered event (only for those you are subscribed to).\n    \n\n    \n\n    \n\n      Warn and Error messages are specifically reserved for unwanted situations, and you should check your code in case you spot one of them.\n    \n\n    \n\n    \n\n      If you enable the lowest level of logging you can see all the messages concerning the WebRTC negotiation process (generally not very interesting for an OpenVidu user).\n    \n\n  \n\n\n\n\n\n\n\nRemember the browser's cache\n\n\nIf you have changed your HTML, JavaScript or CSS code, refreshed the page and cannot see the changes on the browser, probably the cache is still serving the old files. To perform a hard reload of your page on the browser, press \nCtrl + Shift + R\n\n\n\n\nUse \nNgrok\n to share your app\n\n\nDo you want to be able to publish your development app over your network or even the Internet, without really having to deploy it in a server? This can be very helpful, as you can test with different devices and browsers at the same time. To achieve this, you can use \nNgrok\n. The set up for Ubuntu is quite simple:\n\n\n\n\nDownload \nNgrok\n with this link [\nLINK\n] and unzip it.\n\n\nDownload this \nNgrok\n configuration file (named \nngrok.yml\n) from our GitHub repo \n[\nLINK\n]\n and place it in the same path as \nNgrok\n binary.\n\n\nRun \nNgrok\n with this command: \n./ngrok start --all -config=ngrok.yml\n. You will get two public IPs (ended with \n.ngrok.io\n) publishing your local address \nlocalhost:5000\n and \nlocalhost:3000\n.\n\n\nYou just have to run you app at port \n3000\n and run OpenVidu Server locally adding this parameter:\n\n\nWhen running OpenVidu Server as a Docker container: \n-Dspring.profiles.active=ngrok\n\n\nWhen running OpenVidu Server as a JAR: \n-e spring.profiles.active=ngrok\n\n\n\n\n\n\nThat's it! Now you can connect to your app through the \nNgrok\n public IP and the connection to OpenVidu Server will work just fine. You have \"deployed\" your app on your own computer, and cross-device testing through your own network is now possible. Connecting to your app over the Internet is also possible, but the video transmission may not work (check \nthis FAQ\n to learn why).\n\n\n\n\n3. I am using Windows to run the tutorials / develop my app. Anything I should know?\n\n\nYes, some little changes are needed because of the way Docker runs on Windows. In Linux/Mac, Docker containers are easily accesible through \nlocalhost\n, but in Windows you will have to use the specific IP allocated to your container (usually \n192.168.99.100\n). When running any tutorial or developing any application, depending if it is \nClient-Side Only\n or \nClient-Side + Server-Side\n:\n\n\nClient-Side Only\n\n\n(Tutorials \nopenvidu-hello-world\n, \nopenvidu-insecure-js\n, \nopenvidu-insecure-angular\n, \nopenvidu-getaroom\n)\n\n\nWhen initializing your Session object, change \nlocation.hostname\n to the IP of the Docker container running openvidu-server (usually \n192.168.99.100\n). For example:\n\n\nOV.initSession('wss://' + location.hostname + ':8443/' + ...\n\n\n\nin Windows is...\n\n\nOV.initSession('wss://192.168.99.100:8443/' + ...\n\n\n\n\n\nAlso you will need to serve your apps over \nhttps\n. Browsers only accept camera usage on http when the address is \nlocalhost\n, and here it will be \n192.168.99.100\n or the one that Docker picks up for you. To serve over https with \nhttp-server\n, generate a self-signed certificate and run with \n-S\n flag on the root path of your app:\n\n\nGenerate a selfsigned certificate (run in  your Docker console)\n\n\nopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem\n\n\nRun with SSL flag\n\n\nhttp-server -S\n\n\n\n\nClient-Side + Server-Side\n\n\nJust need to add a new parameter when launching you openvidu-server container and your tutorial/app:\n\n\n\n\n\n\nopenvidu/openvidu-server-kms Docker container\n (See \nDockerHub\n): override the default value of the property \nopenvidu.publicurl\n:\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\nin Windows is...\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET -e openvidu.publicurl=https://192.168.99.100:8443/ openvidu/openvidu-server-kms\n\n\n\n\n\n\n\nJava tutorials\n (tutorials \nopenvidu-js-java\n, \nopenvidu-mvc-java\n): override the default value of the property \nopenvidu.url\n:\n\n\nmvn package exec:java\n\n\n\nin Windows is...\n\n\nmvn -Dopenvidu.url=https://192.168.99.100:8443/ package exec:java\n\n\n\n\n\nHere we are simply changing the param \nurlOpenViduServer\n that our OpenVidu object from \nopenvidu-java-client\n will receive in \nits constructor\n. This change is something related to these specific applications.\n\n\n\n\n\n\n\n\nNode tutorials\n (tutorials \nopenvidu-js-node\n, \nopenvidu-mvc-node\n): change the URL param passed on launch:\n\n\nnode server.js https://localhost:8443/ MY_SECRET\n\n\n\nin Windows is...\n\n\nnode server.js https://192.168.99.100:8443/ MY_SECRET\n\n\n\n\n\nHere we are simply changing the param \nurlOpenViduServer\n that our OpenVidu object from \nopenvidu-node-client\n will receive in \nits constructor\n. This change is something related to these specific applications.\n\n\n\n\n\n\n\n\n4. Why does my app need a server-side?\n\n\nFirst of all, let's differentiate between OpenVidu server-side and your application's server-side. \n\n\n\n\nYou will always need OpenVidu Server deployed at some place on the Internet (check the \nDeployment section\n to learn how to do it in 5 minutes). For now, OpenVidu doesn't support p2p direct connections between two users, so all the traffic must flow to OpenVidu Server or from OpenVidu Server.\n\n\nYou will generally want your application to have its own server-side. Why?\n\n\n\n\nWell, it is really not necessary. You can have a pure client-side application if you want. Just check any of these tutorials:\nopenvidu-hello-world\n, \nopenvidu-insecure-js\n, \nopenvidu-getaroom\n\n\nThe problem here is pretty evident: if you don't have any kind of server side to control your users, anyone can use your app. In fact, you can respectively see \nhere\n, \nhere\n and \nhere\n that when initializing the Session object, the SECRET is hardcoded in the JavaScript file. That means that any user with basic knowledge can get your SECRET just by looking at the source code in the browser.\n\n\n\n\nIMPORTANT\n: Do NOT include your SECRET in your JavaScript or HTML files in a production environment!\n\n\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \n\n  \n\n  \n\n    \n\n      \nFirst an OpenVidu app Client-Side Only.\n\n    \n\n    \n\n    \n\n      \nSecond an OpenVidu app Client-Side + Server-Side.\n\n    \n\n    \n\n    \n\n      \nIn production you will usually want the second option to avoid unwanted users.\n\n    \n\n  \n\n\n\n\n\n5. What are the differences related to OpenVidu between an app without a server-side and an app with a server-side?\n\n\nOpenVidu works pretty much the same way, but the process you will follow for connecting to a session is a little bit different:\n\n\nWhen you have a server-side, your server may ask OpenVidu Server for a \nsessionId\n and a \ntoken\n: the first one will give you the session and the second one will connect the user to it.\n\n\nWhen you don't have a server side, the \nsessionId\n must be built in your JavaScript code in the browser, indicating your OpenVidu Server IP, the identifier of the session and your OpenVidu Server secret. Besides, the \ntoken\n param is now completely irrelevant.\n\n\nSo for initializing and connecting to a session:\n\n\n\n\n\n\nOpenVidu app without a server-side\n\n\nvar OPENVIDU_IP = \"my.domain.com\"\nvar OPENVIDU_SECRET = \"MY_SECRET\";\nvar SESSION_ID = \"MY_SESSION\";\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(\"wss://\" + OPENVIDU_IP + \":8443/\" + SESSION_ID + \"?secret=\" + OPENVIDU_SECRET);\n\nsession.connect(null, function() { ... });\n\n\n\n\n\n\n\nOpenVidu app with a server-side\n\n\n// Return a sessionId and a token from your server...\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId)\n\nsession.connect(token, function() { ... });\n\n\n\n\n\n\n\n\n\nTo get a sessionId and a token from OpenVidu Server, you can make use of the \nREST API\n, \nopenvidu-java-client\n or \nopenvidu-node-client\n\n\n\n\n6. The CloudFormation Stack is a nice option for Amazon, but I don't like it. I want more control\n\n\nYou can always deploy everything by yourself. To do so, check \nDeploying OpenVidu as a native service\n section. It is very important to understand all the posibilities you have available regarding to the architecture of your system: you can have everything running in the same host or split the services between two or even more machines. That's up to you.\n\n\n\n  \n\n    \n\n  \n\n  \n\n  \n\n    \n\n      \nApp, OpenVidu Server and KMS run in the same machine\n\n      \nApp runs in its own machine. OpenVidu Server and KMS run in the same machine\n\n      \nApp, OpenVidu Server and KMS all run in different machines\n\n    \n\n    \n\n  \n\n\n\n\n\nIn this diagram \nSTUN/TURN server\n is not outlined. It is another necessary service, and it can be hosted wherever you want (we recommend running it in the same host as Kurento Media Server).\n\n\n7. What are STUN and TURN servers and why do I need them?\n\n\nIf the user's devices don't have a public and reachable IP, WebRTC connections cannot be established and therefore, video streams cannot be sent or received. This occurs when the users are behind NAT's and Firewalls. In brief, when they are hidden under complex networks.\n\n\nIn order to support these circumstances, WebRTC relies on \nSTUN and TURN\n servers:\n\n\n\n\nSTUN\n can easily provide to the user's devices their own public IP (the IP that other devices on the Internet use to connect to it), so they can tell OpenVidu where to send the video streams. Only with a STUN server, around \n86%\n of the time the connection will be successful.\n\n\nTURN\n is an extension of STUN, and covers the most extreme cases of complex networks (symmetric NATs). It acts as a gateway, passing all the media streams form one side to the other. This situation will occur with a probability of around \n8%\n.\n\n\n\n\nFor all purposes, OpenVidu Server acts as a final user, and your connections may fail if it is hosted behind a complex network. To provide a a solid service you definitely need both STUN and TURN servers. There are many public, free-to-use STUN servers (\nSTUN server list\n), but because TURN always faces a much larger load when coming into play, no one offers it free of charge. The good news is that it is very easy to install a COTURN server, which offers both STUN and TURN:\n\n\n\n\nOur ready-to-use \nCloudFormation stack\n already includes a properly configured COTURN server.\n\n\n\n\nIf you are deploying OpenVidu Server by your own, there are detailed instructions in the \nDeploying OpenVidu as a native service\n section, which explains how to install, configure and run COTURN in Ubuntu.\n\n\n\n\nYou can test your \nCOTURN\n server on this website: \nTrickle ICE\n. To do so, remove the default Google server from the list and add your own following this format: \nturn:YOUR_TURN_IP:YOUR_TURN_PORT\n (add your TURN username and password below)\n\n\n\n\n\n\n\n\n8. What does OpenVidu not integrate regarding WebRTC and Kurento yet?\n\n\nAs the main goal OpenVidu has is to make as simple as possible the integration of video-call capabilities in applications, it would make little sense to support all the features provided by Kurento: why would most of developers want visual recognition or augmented reality capabilities when adding video-calls to their apps?\n\n\nBut there's also a bunch of features supported by Kurento or WebRTC that will be part of OpenVidu as well:\n\n\n\n\nVideo composing\n: right now OpenVidu streams are always sent and received without any processing in Kurento Media Server, so every subscription to a video stream in a video-session implies its own WebRTC connection. We intend to provide the possibility of configuring video-sessions to be processed and send as only one video, composed in a grid by all the published streams.\n\n\nDirect p2p connections between users\n: OpenVidu will offer the possibility of connecting users without having to use Kurento Media Server as central node. This can be very advantegeous for certain use-cases, as will reduce the need of infraestructure.\n\n\nVideo recording\n: OpenVidu will support multiple (grid) and single stream recording, so developers can easily access video files later.\n\n\nMobile platforms\n: OpenVIdu will provide clients for both Android and iOS.\n\n\n\n\n9. Does OpenVidu support Android and iOS?\n\n\nAt the moment there are no OpenVidu clients for mobile platforms, but we are working on it. In the future you will have available \nOpenVidu Android\n and \nOpenVidu iOS\n, joining \nOpenVidu Browser\n. The main goal here is that all of them are fully compatible with one another.\n\n\n10. Which is the current status of OpenVidu on scalability and fault tolerance?\n\n\nThis particular point relies on Kurento Media Server performance, as it is the media server used by OpenVidu. \nTestRTC\n published on September 13, 2017 a very interesting article describing in detail the behaviour of Kurento Media Server while holding a different number of video-sessions. \nHere\n is the complete article.\n\n\nThese are the conclusions for a machine with \n8 cores and 15 GB of RAM\n. The upper limit where the following scenarios guaranteed good quality of service are:\n\n\n\n\n\n\n\n\nScenario\n\n\nSize\n\n\n\n\n\n\n\n\n\n\n1:1 video calls\n\n\n18 users in 9 parallel sessions\n\n\n\n\n\n\n4-way group video calls (grid composing)\n\n\n3 rooms of 4 users each\n\n\n\n\n\n\n1:N broadcast\n\n\n1 broadcaster + 80-150 viewers\n\n\n\n\n\n\n\n\nThat said, one of the most important features OpenVidu will offer is the possibility of automated scalability and fault tolerance. We intend to provide an easy-to-use service integrated with Amazon Web Services to allow the automated launching and shutdown of servers depending on the workload of your application.\n\n\n11. I am getting an \"Error accesing the camera\" and I have already granted permissions on the browser\n\n\nIf you are using \nChrome\n: you \ncannot access the camera or microphone from a \nhttp\n URL if it is not \nlocalhost\n or \n127.0.0.1\n. In a nutshell: in Chrome accessing the webcam on \nhttp://localhost:8080\n or \nhttp://127.0.0.1:8080\n is perfectly OK. But, for example, on \nhttp://172.17.0.1:8080\n it will through an error saying \"\nOnly secure origins are allowed\n\". If for any reason you want to serve your app locally on a custom URL, the only solution is to serve it over \nhttps\n with a certificate. If you are making use of the web server we have strongly suggested over the documentation (\nnpm install -g http-server\n), you can do this with the following commands on your application's root path:\n\n\n\n\n\n\nGenerate a selfsigned certificate with \nopenssl\n\n\nopenssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem\n\n\n\n\n\n\n\nRun \nhttp-server\n with SSL flag\n\n\nhttp-server -S", 
            "title": "Troubleshooting / FAQ"
        }, 
        {
            "location": "/troubleshooting/#1-everything-looks-alright-but-i-cannot-see-any-remote-video", 
            "text": "You have an app that uses OpenVidu to stream some video user-to-user, and the process looks perfectly okey. No errors on the console and all the OpenVidu events you are subscribed to are correctly triggered. So what's happening?  99% of the time this is a problem related with  OPENVIDU SERVER NOT HAVING A PUBLIC IP . To learn more about it, you can check  this FAQ . The quickest solution to this problem is to deploy in Amazon our ready-to-use OpenVidu Server with  CloudFormation .  If you are a bit reluctant to this quick solution with Amazon CloudFormation, you can always deploy OpenVidu by yourself in Ubuntu 14.04 and 16.04. Check  Deploying OpenVidu as a native service  section to learn how to properly do it.  Besides that, these are the recommended steps to follow when videos are not received:   Access your OpenVidu dashboard ( https://YOUR_OPENVIDU_IP:8443 ) to quickly test the video transmission.  Please be sure that your OpenVidu Server host meets the  network requirements .   The other 1% of the time this can be an attempt of  accessing the same camera from two different browsers at the same time . Remember that Chrome, Firefox, Opera, Safari and Edge are distinct processes which cannot generally access the same physical resource (as a webcam) at the same time on your computer. On the other hand, accessing the camera from different tabs of the same browser is tipically possible.", 
            "title": "1. Everything looks alright, but I cannot see any remote video"
        }, 
        {
            "location": "/troubleshooting/#2-any-tips-to-make-easier-the-development-of-my-app-with-openvidu", 
            "text": "You can do some things to improve your efficiency while using OpenVidu:", 
            "title": "2. Any tips to make easier the development of my app with OpenVidu?"
        }, 
        {
            "location": "/troubleshooting/#multiple-tabs-to-test-the-video-transmission", 
            "text": "You can use multiple tabs in the same browser to test your video streams.  WARNING : you may have trouble for testing with tabs from different browsers at the same time, as they compete for the camera access.", 
            "title": "Multiple tabs to test the video transmission"
        }, 
        {
            "location": "/troubleshooting/#be-very-aware-of-the-browsers-console", 
            "text": "There you can find logs reporting important stuff. Error messages can help you to solve many issues.  \n   \n     \n   \n   \n     \n   \n   \n     \n      OpenVidu Browser is developed with both  Chrome  (first image) and  Firefox  (second image) in mind in terms of logging. By default the browser's console displays OpenVidu's high-level messages (that's when the option 'Info' is enabled, as seen in the images). This means logs about OpenVidu objects being created and destroyed and logs for each triggered event (only for those you are subscribed to).\n     \n     \n     \n      Warn and Error messages are specifically reserved for unwanted situations, and you should check your code in case you spot one of them.\n     \n     \n     \n      If you enable the lowest level of logging you can see all the messages concerning the WebRTC negotiation process (generally not very interesting for an OpenVidu user).", 
            "title": "Be very aware of the browser's console"
        }, 
        {
            "location": "/troubleshooting/#remember-the-browsers-cache", 
            "text": "If you have changed your HTML, JavaScript or CSS code, refreshed the page and cannot see the changes on the browser, probably the cache is still serving the old files. To perform a hard reload of your page on the browser, press  Ctrl + Shift + R", 
            "title": "Remember the browser's cache"
        }, 
        {
            "location": "/troubleshooting/#use-ngrok-to-share-your-app", 
            "text": "Do you want to be able to publish your development app over your network or even the Internet, without really having to deploy it in a server? This can be very helpful, as you can test with different devices and browsers at the same time. To achieve this, you can use  Ngrok . The set up for Ubuntu is quite simple:   Download  Ngrok  with this link [ LINK ] and unzip it.  Download this  Ngrok  configuration file (named  ngrok.yml ) from our GitHub repo  [ LINK ]  and place it in the same path as  Ngrok  binary.  Run  Ngrok  with this command:  ./ngrok start --all -config=ngrok.yml . You will get two public IPs (ended with  .ngrok.io ) publishing your local address  localhost:5000  and  localhost:3000 .  You just have to run you app at port  3000  and run OpenVidu Server locally adding this parameter:  When running OpenVidu Server as a Docker container:  -Dspring.profiles.active=ngrok  When running OpenVidu Server as a JAR:  -e spring.profiles.active=ngrok    That's it! Now you can connect to your app through the  Ngrok  public IP and the connection to OpenVidu Server will work just fine. You have \"deployed\" your app on your own computer, and cross-device testing through your own network is now possible. Connecting to your app over the Internet is also possible, but the video transmission may not work (check  this FAQ  to learn why).", 
            "title": "Use Ngrok to share your app"
        }, 
        {
            "location": "/troubleshooting/#3-i-am-using-windows-to-run-the-tutorials-develop-my-app-anything-i-should-know", 
            "text": "Yes, some little changes are needed because of the way Docker runs on Windows. In Linux/Mac, Docker containers are easily accesible through  localhost , but in Windows you will have to use the specific IP allocated to your container (usually  192.168.99.100 ). When running any tutorial or developing any application, depending if it is  Client-Side Only  or  Client-Side + Server-Side :", 
            "title": "3. I am using Windows to run the tutorials / develop my app. Anything I should know?"
        }, 
        {
            "location": "/troubleshooting/#client-side-only", 
            "text": "(Tutorials  openvidu-hello-world ,  openvidu-insecure-js ,  openvidu-insecure-angular ,  openvidu-getaroom )  When initializing your Session object, change  location.hostname  to the IP of the Docker container running openvidu-server (usually  192.168.99.100 ). For example:  OV.initSession('wss://' + location.hostname + ':8443/' + ...  in Windows is...  OV.initSession('wss://192.168.99.100:8443/' + ...   Also you will need to serve your apps over  https . Browsers only accept camera usage on http when the address is  localhost , and here it will be  192.168.99.100  or the one that Docker picks up for you. To serve over https with  http-server , generate a self-signed certificate and run with  -S  flag on the root path of your app:  Generate a selfsigned certificate (run in  your Docker console)  openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem  Run with SSL flag  http-server -S", 
            "title": "Client-Side Only"
        }, 
        {
            "location": "/troubleshooting/#client-side-server-side", 
            "text": "Just need to add a new parameter when launching you openvidu-server container and your tutorial/app:    openvidu/openvidu-server-kms Docker container  (See  DockerHub ): override the default value of the property  openvidu.publicurl :  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms  in Windows is...  docker run -p 8443:8443 --rm -e KMS_STUN_IP=stun.l.google.com -e KMS_STUN_PORT=19302 -e openvidu.secret=MY_SECRET -e openvidu.publicurl=https://192.168.99.100:8443/ openvidu/openvidu-server-kms    Java tutorials  (tutorials  openvidu-js-java ,  openvidu-mvc-java ): override the default value of the property  openvidu.url :  mvn package exec:java  in Windows is...  mvn -Dopenvidu.url=https://192.168.99.100:8443/ package exec:java   Here we are simply changing the param  urlOpenViduServer  that our OpenVidu object from  openvidu-java-client  will receive in  its constructor . This change is something related to these specific applications.     Node tutorials  (tutorials  openvidu-js-node ,  openvidu-mvc-node ): change the URL param passed on launch:  node server.js https://localhost:8443/ MY_SECRET  in Windows is...  node server.js https://192.168.99.100:8443/ MY_SECRET   Here we are simply changing the param  urlOpenViduServer  that our OpenVidu object from  openvidu-node-client  will receive in  its constructor . This change is something related to these specific applications.", 
            "title": "Client-Side + Server-Side"
        }, 
        {
            "location": "/troubleshooting/#4-why-does-my-app-need-a-server-side", 
            "text": "First of all, let's differentiate between OpenVidu server-side and your application's server-side.    You will always need OpenVidu Server deployed at some place on the Internet (check the  Deployment section  to learn how to do it in 5 minutes). For now, OpenVidu doesn't support p2p direct connections between two users, so all the traffic must flow to OpenVidu Server or from OpenVidu Server.  You will generally want your application to have its own server-side. Why?   Well, it is really not necessary. You can have a pure client-side application if you want. Just check any of these tutorials: openvidu-hello-world ,  openvidu-insecure-js ,  openvidu-getaroom  The problem here is pretty evident: if you don't have any kind of server side to control your users, anyone can use your app. In fact, you can respectively see  here ,  here  and  here  that when initializing the Session object, the SECRET is hardcoded in the JavaScript file. That means that any user with basic knowledge can get your SECRET just by looking at the source code in the browser.   IMPORTANT : Do NOT include your SECRET in your JavaScript or HTML files in a production environment!   \n   \n     \n   \n   \n     \n   \n   \n     \n       First an OpenVidu app Client-Side Only. \n     \n     \n     \n       Second an OpenVidu app Client-Side + Server-Side. \n     \n     \n     \n       In production you will usually want the second option to avoid unwanted users.", 
            "title": "4. Why does my app need a server-side?"
        }, 
        {
            "location": "/troubleshooting/#5-what-are-the-differences-related-to-openvidu-between-an-app-without-a-server-side-and-an-app-with-a-server-side", 
            "text": "OpenVidu works pretty much the same way, but the process you will follow for connecting to a session is a little bit different:  When you have a server-side, your server may ask OpenVidu Server for a  sessionId  and a  token : the first one will give you the session and the second one will connect the user to it.  When you don't have a server side, the  sessionId  must be built in your JavaScript code in the browser, indicating your OpenVidu Server IP, the identifier of the session and your OpenVidu Server secret. Besides, the  token  param is now completely irrelevant.  So for initializing and connecting to a session:    OpenVidu app without a server-side  var OPENVIDU_IP = \"my.domain.com\"\nvar OPENVIDU_SECRET = \"MY_SECRET\";\nvar SESSION_ID = \"MY_SESSION\";\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(\"wss://\" + OPENVIDU_IP + \":8443/\" + SESSION_ID + \"?secret=\" + OPENVIDU_SECRET);\n\nsession.connect(null, function() { ... });    OpenVidu app with a server-side  // Return a sessionId and a token from your server...\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId)\n\nsession.connect(token, function() { ... });     To get a sessionId and a token from OpenVidu Server, you can make use of the  REST API ,  openvidu-java-client  or  openvidu-node-client", 
            "title": "5. What are the differences related to OpenVidu between an app without a server-side and an app with a server-side?"
        }, 
        {
            "location": "/troubleshooting/#6-the-cloudformation-stack-is-a-nice-option-for-amazon-but-i-dont-like-it-i-want-more-control", 
            "text": "You can always deploy everything by yourself. To do so, check  Deploying OpenVidu as a native service  section. It is very important to understand all the posibilities you have available regarding to the architecture of your system: you can have everything running in the same host or split the services between two or even more machines. That's up to you.  \n   \n     \n   \n   \n   \n     \n       App, OpenVidu Server and KMS run in the same machine \n       App runs in its own machine. OpenVidu Server and KMS run in the same machine \n       App, OpenVidu Server and KMS all run in different machines \n     \n     \n     In this diagram  STUN/TURN server  is not outlined. It is another necessary service, and it can be hosted wherever you want (we recommend running it in the same host as Kurento Media Server).", 
            "title": "6. The CloudFormation Stack is a nice option for Amazon, but I don't like it. I want more control"
        }, 
        {
            "location": "/troubleshooting/#7-what-are-stun-and-turn-servers-and-why-do-i-need-them", 
            "text": "If the user's devices don't have a public and reachable IP, WebRTC connections cannot be established and therefore, video streams cannot be sent or received. This occurs when the users are behind NAT's and Firewalls. In brief, when they are hidden under complex networks.  In order to support these circumstances, WebRTC relies on  STUN and TURN  servers:   STUN  can easily provide to the user's devices their own public IP (the IP that other devices on the Internet use to connect to it), so they can tell OpenVidu where to send the video streams. Only with a STUN server, around  86%  of the time the connection will be successful.  TURN  is an extension of STUN, and covers the most extreme cases of complex networks (symmetric NATs). It acts as a gateway, passing all the media streams form one side to the other. This situation will occur with a probability of around  8% .   For all purposes, OpenVidu Server acts as a final user, and your connections may fail if it is hosted behind a complex network. To provide a a solid service you definitely need both STUN and TURN servers. There are many public, free-to-use STUN servers ( STUN server list ), but because TURN always faces a much larger load when coming into play, no one offers it free of charge. The good news is that it is very easy to install a COTURN server, which offers both STUN and TURN:   Our ready-to-use  CloudFormation stack  already includes a properly configured COTURN server.   If you are deploying OpenVidu Server by your own, there are detailed instructions in the  Deploying OpenVidu as a native service  section, which explains how to install, configure and run COTURN in Ubuntu.   You can test your  COTURN  server on this website:  Trickle ICE . To do so, remove the default Google server from the list and add your own following this format:  turn:YOUR_TURN_IP:YOUR_TURN_PORT  (add your TURN username and password below)", 
            "title": "7. What are STUN and TURN servers and why do I need them?"
        }, 
        {
            "location": "/troubleshooting/#8-what-does-openvidu-not-integrate-regarding-webrtc-and-kurento-yet", 
            "text": "As the main goal OpenVidu has is to make as simple as possible the integration of video-call capabilities in applications, it would make little sense to support all the features provided by Kurento: why would most of developers want visual recognition or augmented reality capabilities when adding video-calls to their apps?  But there's also a bunch of features supported by Kurento or WebRTC that will be part of OpenVidu as well:   Video composing : right now OpenVidu streams are always sent and received without any processing in Kurento Media Server, so every subscription to a video stream in a video-session implies its own WebRTC connection. We intend to provide the possibility of configuring video-sessions to be processed and send as only one video, composed in a grid by all the published streams.  Direct p2p connections between users : OpenVidu will offer the possibility of connecting users without having to use Kurento Media Server as central node. This can be very advantegeous for certain use-cases, as will reduce the need of infraestructure.  Video recording : OpenVidu will support multiple (grid) and single stream recording, so developers can easily access video files later.  Mobile platforms : OpenVIdu will provide clients for both Android and iOS.", 
            "title": "8. What does OpenVidu not integrate regarding WebRTC and Kurento yet?"
        }, 
        {
            "location": "/troubleshooting/#9-does-openvidu-support-android-and-ios", 
            "text": "At the moment there are no OpenVidu clients for mobile platforms, but we are working on it. In the future you will have available  OpenVidu Android  and  OpenVidu iOS , joining  OpenVidu Browser . The main goal here is that all of them are fully compatible with one another.", 
            "title": "9. Does OpenVidu support Android and iOS?"
        }, 
        {
            "location": "/troubleshooting/#10-which-is-the-current-status-of-openvidu-on-scalability-and-fault-tolerance", 
            "text": "This particular point relies on Kurento Media Server performance, as it is the media server used by OpenVidu.  TestRTC  published on September 13, 2017 a very interesting article describing in detail the behaviour of Kurento Media Server while holding a different number of video-sessions.  Here  is the complete article.  These are the conclusions for a machine with  8 cores and 15 GB of RAM . The upper limit where the following scenarios guaranteed good quality of service are:     Scenario  Size      1:1 video calls  18 users in 9 parallel sessions    4-way group video calls (grid composing)  3 rooms of 4 users each    1:N broadcast  1 broadcaster + 80-150 viewers     That said, one of the most important features OpenVidu will offer is the possibility of automated scalability and fault tolerance. We intend to provide an easy-to-use service integrated with Amazon Web Services to allow the automated launching and shutdown of servers depending on the workload of your application.", 
            "title": "10. Which is the current status of OpenVidu on scalability and fault tolerance?"
        }, 
        {
            "location": "/troubleshooting/#11-i-am-getting-an-error-accesing-the-camera-and-i-have-already-granted-permissions-on-the-browser", 
            "text": "If you are using  Chrome : you  cannot access the camera or microphone from a  http  URL if it is not  localhost  or  127.0.0.1 . In a nutshell: in Chrome accessing the webcam on  http://localhost:8080  or  http://127.0.0.1:8080  is perfectly OK. But, for example, on  http://172.17.0.1:8080  it will through an error saying \" Only secure origins are allowed \". If for any reason you want to serve your app locally on a custom URL, the only solution is to serve it over  https  with a certificate. If you are making use of the web server we have strongly suggested over the documentation ( npm install -g http-server ), you can do this with the following commands on your application's root path:    Generate a selfsigned certificate with  openssl  openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj '/CN=www.mydom.com/O=My Company LTD./C=US' -keyout key.pem -out cert.pem    Run  http-server  with SSL flag  http-server -S", 
            "title": "11. I am getting an \"Error accesing the camera\" and I have already granted permissions on the browser"
        }
    ]
}