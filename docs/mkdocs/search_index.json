{
    "docs": [
        {
            "location": "/", 
            "text": "OpenVidu Documentation\n\n\n\n\n\n\nWhat is OpenVidu?\n\n\nOpenVidu is a platform to facilitate the addition of video calls in your web or mobile \napplication, either group or one-to-one calls. In fact, any combination you come up with is easy to implement with OpenVidu.\n\n\nIt is based on \nKurento\n, the WebRTC platform for multimedia applications. Openvidu was forked from \nKurentoRoom project\n.\n\n\nOpenVidu and Kurento are licensed under Apache License v2.\n\n\n\n\nTable of contents\n\n\n\n\nRunning a videocall demo\n\n\nBuilding a simple app\n\n\nSecurization\n\n\nSharing data between users\n\n\nAcknowledgments\n\n\n\n\n\n\nRunning a videocall demo application\n\n\nWe have implemented a very basic demo application to see OpenVidu in action. To ease the installation, we have packaged it as a docker image. \n\n\n\n\nPlease be sure that you have \ndocker CE installed\n\n\nRun this Docker container\n\n\n\n\ndocker run -p 5000:5000 -p 4040:4040 -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-plainjs-demo\n\n\n\n\n\n\nWait until you see a public URL ended with \n.ngrok.io\n. You can connect locally in \nlocalhost:5000\n or by using the ngrok public URL. You can also share this URL with anyone you want to test the app over the Internet!\n\n\n\n\n\n\nBuilding a simple app with OpenVidu\n\n\n\n  \n\n\n\n\n\nOpenVidu has a traditional \nClient - Server\n architecture built on three modules that are shown in the image above. To run \nopenvidu-server\n and \nKurento Media Server\n you can execute the following container: \n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-server-kms\n\n\n\n\nThen, you have to use the library \nopenvidu-browser\n in your JavaScript browser application (frontend). This library is packaged in [OpenVidu.js] file that you can download from https://github.com/OpenVidu/openvidu/blob/master/openvidu-browser/src/main/resources/static/js/OpenVidu.js. Then add the file in your HTML with \nscript src=\"OpenVidu.js\"\n/script\n.\n\n\nWith the \nopenvidu-browser\n library you can handle all available operations straight away from your client, as creating video calls, joining users to them or publishing/unpublishing video and audio\n\n\nSample application\n\n\nOnce you have up and running Kurento Media Server and openvidu-server, you just need to add a few lines of code in your frontend to make your first video call with OpenVidu. You can take a look to the simplest sample application in GitHub https://github.com/OpenVidu/openvidu-tutorials/tree/master/openvidu-insecure-js.\n\n\nYou can clone the repo and serve the app locally with your favourite tool (we recommend http-server: \nnpm install -g http-server\n)\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\ncd openvidu-tutorials/openvidu-insecure-js/web\nhttp-server\n\n\n\n\nYou can now start editing HTML, JS and CSS files. Just reload your browser to see your changes (mind the browser's cache!).\n\n\nCode description\n\n\n\n\nGet an \nOpenVidu\n object and initialize a session with a \nsessionId\n. Have in mind that this is the parameter that defines which video call to connect.\n\n\n\n\nvar OV = new OpenVidu(\nwss://\n + OPENVIDU_SERVER_IP + \n:8443/\n);\nvar session = OV.initSession(sessionId);\n\n\n\n\n\n\nSet the events to be listened by your session. For example, this snippet below will automatically append the new participants videos to HTML element with 'subscriber' id. Available events for the Session object are detailed in \nAPI section\n.\n\n\n\n\nsession.on('streamCreated', function (event) {\n    session.subscribe(event.stream, 'subscriber');\n});\n\n\n\n\n\n\nConnect to the session. For a non-secure approach, the value of \ntoken\n parameter is irrelevant. You can pass as second parameter a callback to be executed after connection is stablished. A common use-case for users that want to stream their own video is the following one: if the connection to the session has been succesful, get a Publisher object (appended to HTML element with id 'publisher') and publish it. The rest of participants will receive the stream.\n\n\n\n\nsession.connect(token, function (error) {\n    // If connection successful, get a publisher and publish to the session\n    if (!error) {\n        var publisher = OV.initPublisher('publisher', {\n            audio: true,\n            video: true,\n            quality: 'MEDIUM' //'LOW','MEDIUM','HIGH'\n        });\n        session.publish(publisher);\n    } else {\n        console.log('Error while connecting to the session');\n    }\n});\n\n\n\n\n\n\nFinally, whenever you want to leave the video call...\n\n\n\n\nsession.disconnect();\n\n\n\n\nWith these few lines of code you will already have a functional video-call capability in your app. Check \nSecurization\n section to learn how to easily make your app ready for production.\n\n\nIf you prefer, there's an Angular version of the sample app that uses \nopenvidu-browser\n npm package. Check it out \nhere\n.\n\n\n\n\nSecurization\n\n\nWhy?\n\n\nIn a production environment probably you don't want unauthorized users swamping your video calls. It's not possible to control access to them with the first approach we have seen in the sections above: anyone who knows the \nsessionId\n could connect to your video call, and if it turns out that the \nsessionId\n doesn't belong to an existing session, a new one would be created.\n\n\nIn addition, a secure version also means you can choose the role each user has in your video calls (see \nOpenViduRole\n section).\n\n\nThus, a non-secure version of OpenVidu is only intended for development environments. Don't worry, adding securization is not a difficult task.\n\n\nHow?\n\n\n\n  \n\n\n\n\n\nIn the image above you can see the main difference with the non-secure version of OpenVidu. Your backend will now have to call two HTTP REST operations in openvidu-server to get the two parameters needed in the securization process:\n\n\n\n\nsessionId\n: just as in the non-secure version, it identifies each specific video-call\n\n\ntoken\n: any user joining a specific video call will need to pass a valid token as a parameter\n\n\n\n\nYou have three different options available for getting sessionIds and tokens from openvidu-server:\n\n\n\n\nREST API\n\n\nopenvidu-java-client\n\n\nopenvidu-node-client\n\n\n\n\nA sequence diagram to sum up\n\n\n\n  \n\n\n\n\n\n\n\nIdentify your user and listen to a request for joining a video call (represented by [LOGIN OPERATION] and [JOIN VIDEO CALL] in the diagram). This process is entirely up to you.\n\n\nYou must get a \nsessionId\n: a new one if the video call is being created or an existing one for an active video call. In the first case you need to ask openvidu-server for it (as shown in the diagram), in the second case you must retrieve it from wherever you stored it when it was created (a data-base or maybe your backend itself).\n\n\nYou also need a new valid \ntoken\n for this session. Ask openvidu-server for it passing the \nsessionId\n.\n\n\nFinally return both parameters to your frontend, where using openvidu-browser you may initilize your session with \nsessionId\n and then connect to it with \ntoken\n. Good news: \nthe code is exactly the same as explained before in \nCode description\n section\n\n\n\n\n\n\nCommunication between \nYour Back\n and \nopenvidu-server\n modules is outlined in the diagram, but it does not correspond to the real methods. Remember you can handle this from your backend by consuming the \nREST API\n or by using \nopenvidu-backend-client\n package.\n\n\n\n\nRunning a secure videocall application\n\n\nWe have implemented a very basic \ndemo application\n to see the secure version of OpenVidu in action. It has a Java backend to manage the user sessions and the securization process with OpenVidu Server.\n\n\n\n\nPlease be sure that you have \ndocker CE installed\n\n\nRun this Docker container\n\n\n\n\ndocker run -p 5000:5000 -p 3000:3000 -p 4040:4040 -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 openvidu/openvidu-sample-secure\n\n\n\n\n\n\nWait until you see a public URL ended with \n.ngrok.io\n. You can connect locally in \nlocalhost:3000\n or by using the ngrok public URL. You can also share this URL with anyone you want to test the app over the Internet!\n\n\n\n\nRunning a sample advanced app\n\n\nWanna try a \nreal sample application\n that makes use of everything we have talked about? Take a look at this app. It wraps a frontend built with Angular, a backend built with Spring and a MySQL database:\n\n\n\n\nPlease be sure that you have docker-compose (\nsudo apt-get install docker-compose\n)\n\n\nDownload the \ndocker-compose.yml\n file and run it:\n\n\n\n\nwget -O docker-compose.yml https://raw.githubusercontent.com/OpenVidu/openvidu-docker/master/openvidu-sample-app/docker-compose.yml\ndocker-compose up\n\n\n\n\n\n\n\n\nWait until you see an output like \nStarted App in XXX seconds (JVM running for XXX)\n\n\n\n\n\n\nGo to \nhttps://localhost:5000\n and accept the self-signed certificate. Here you have a couple registered users (use a standard window and an incognito window to test both of them at the same time):\n\n\n\n\n\n\n\n\nuser\n\n\npassword\n\n\n\n\n\n\n\n\n\n\nteacher@\ngmail.com\n\n\npass\n\n\n\n\n\n\nstudent1@\ngmail.com\n\n\npass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSharing data between users\n\n\nWhatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places:\n\n\n\n\nopenvidu-browser\n: when calling \nsession.connect\n method\n\n\n\n\nsession.connect(token, DATA, function (error) { ... });\n\n\n\n\n\n\nAPI REST\n: when asking for a token to \n/api/tokens\n, you can pass data as third parameter in the BODY of the POST request \n\n\n\n\n{\u201csession\u201d: \u201csessionId\u201d, \u201crole\u201d: \u201crole\u201d, \u201cdata\u201d: \nDATA\n}\n\n\n\n\n\n\nJava and Node clients (\nopenvidu-java-client\n and \nopenvidu-node-client\n) allow you to pass data when creating a Token object: \n\n\ntokenOptions = new TokenOptions.Builder().data(\"DATA\").build();\n\n\n\n\nThe result will be that in all clients, \nConnection\n objects will have in their \ndata\n property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be:\n\n\nsession.on('streamCreated', function (event) {\n    session.subscribe(event.stream, 'subscriber');\n    console.log('USER DATA: ' + event.stream.connection.data);\n});\n\n\n\n\nSome clarifications:\n\n\n\n\n\n\nConnection.data\n will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend: \"OPENVIDUBROWSER_DATA%/%APIREST_DATA\" \n\n\n\n\n\n\nUsing only first option is not secure, as clients could modify the value of the second parameter. It is intended only in development environments. If you want total control over shared data, please use the second way.\n\n\n\n\nYou can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice.\n\n\n\n\nAcknowledgments\n\n\nOpenVidu platform has been supported under project LERNIM (RTC-2016-4674-7) confunded by the \nMinistry of Economy, Finance and Competitiveness\n of Spain, as well as by the \nEuropean Union\n FEDER, whose main goal with this funds is to promote technological development, innovation and high-quality research.", 
            "title": "Home"
        }, 
        {
            "location": "/#what-is-openvidu", 
            "text": "OpenVidu is a platform to facilitate the addition of video calls in your web or mobile \napplication, either group or one-to-one calls. In fact, any combination you come up with is easy to implement with OpenVidu.  It is based on  Kurento , the WebRTC platform for multimedia applications. Openvidu was forked from  KurentoRoom project .  OpenVidu and Kurento are licensed under Apache License v2.", 
            "title": "What is OpenVidu?"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "Running a videocall demo  Building a simple app  Securization  Sharing data between users  Acknowledgments", 
            "title": "Table of contents"
        }, 
        {
            "location": "/#running-a-videocall-demo-application", 
            "text": "We have implemented a very basic demo application to see OpenVidu in action. To ease the installation, we have packaged it as a docker image.    Please be sure that you have  docker CE installed  Run this Docker container   docker run -p 5000:5000 -p 4040:4040 -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-plainjs-demo   Wait until you see a public URL ended with  .ngrok.io . You can connect locally in  localhost:5000  or by using the ngrok public URL. You can also share this URL with anyone you want to test the app over the Internet!", 
            "title": "Running a videocall demo application"
        }, 
        {
            "location": "/#building-a-simple-app-with-openvidu", 
            "text": "OpenVidu has a traditional  Client - Server  architecture built on three modules that are shown in the image above. To run  openvidu-server  and  Kurento Media Server  you can execute the following container:   docker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-server-kms  Then, you have to use the library  openvidu-browser  in your JavaScript browser application (frontend). This library is packaged in [OpenVidu.js] file that you can download from https://github.com/OpenVidu/openvidu/blob/master/openvidu-browser/src/main/resources/static/js/OpenVidu.js. Then add the file in your HTML with  script src=\"OpenVidu.js\" /script .  With the  openvidu-browser  library you can handle all available operations straight away from your client, as creating video calls, joining users to them or publishing/unpublishing video and audio", 
            "title": "Building a simple app with OpenVidu"
        }, 
        {
            "location": "/#sample-application", 
            "text": "Once you have up and running Kurento Media Server and openvidu-server, you just need to add a few lines of code in your frontend to make your first video call with OpenVidu. You can take a look to the simplest sample application in GitHub https://github.com/OpenVidu/openvidu-tutorials/tree/master/openvidu-insecure-js.  You can clone the repo and serve the app locally with your favourite tool (we recommend http-server:  npm install -g http-server )  git clone https://github.com/OpenVidu/openvidu-tutorials.git\ncd openvidu-tutorials/openvidu-insecure-js/web\nhttp-server  You can now start editing HTML, JS and CSS files. Just reload your browser to see your changes (mind the browser's cache!).", 
            "title": "Sample application"
        }, 
        {
            "location": "/#code-description", 
            "text": "Get an  OpenVidu  object and initialize a session with a  sessionId . Have in mind that this is the parameter that defines which video call to connect.   var OV = new OpenVidu( wss://  + OPENVIDU_SERVER_IP +  :8443/ );\nvar session = OV.initSession(sessionId);   Set the events to be listened by your session. For example, this snippet below will automatically append the new participants videos to HTML element with 'subscriber' id. Available events for the Session object are detailed in  API section .   session.on('streamCreated', function (event) {\n    session.subscribe(event.stream, 'subscriber');\n});   Connect to the session. For a non-secure approach, the value of  token  parameter is irrelevant. You can pass as second parameter a callback to be executed after connection is stablished. A common use-case for users that want to stream their own video is the following one: if the connection to the session has been succesful, get a Publisher object (appended to HTML element with id 'publisher') and publish it. The rest of participants will receive the stream.   session.connect(token, function (error) {\n    // If connection successful, get a publisher and publish to the session\n    if (!error) {\n        var publisher = OV.initPublisher('publisher', {\n            audio: true,\n            video: true,\n            quality: 'MEDIUM' //'LOW','MEDIUM','HIGH'\n        });\n        session.publish(publisher);\n    } else {\n        console.log('Error while connecting to the session');\n    }\n});   Finally, whenever you want to leave the video call...   session.disconnect();  With these few lines of code you will already have a functional video-call capability in your app. Check  Securization  section to learn how to easily make your app ready for production.  If you prefer, there's an Angular version of the sample app that uses  openvidu-browser  npm package. Check it out  here .", 
            "title": "Code description"
        }, 
        {
            "location": "/#securization", 
            "text": "", 
            "title": "Securization"
        }, 
        {
            "location": "/#why", 
            "text": "In a production environment probably you don't want unauthorized users swamping your video calls. It's not possible to control access to them with the first approach we have seen in the sections above: anyone who knows the  sessionId  could connect to your video call, and if it turns out that the  sessionId  doesn't belong to an existing session, a new one would be created.  In addition, a secure version also means you can choose the role each user has in your video calls (see  OpenViduRole  section).  Thus, a non-secure version of OpenVidu is only intended for development environments. Don't worry, adding securization is not a difficult task.", 
            "title": "Why?"
        }, 
        {
            "location": "/#how", 
            "text": "In the image above you can see the main difference with the non-secure version of OpenVidu. Your backend will now have to call two HTTP REST operations in openvidu-server to get the two parameters needed in the securization process:   sessionId : just as in the non-secure version, it identifies each specific video-call  token : any user joining a specific video call will need to pass a valid token as a parameter   You have three different options available for getting sessionIds and tokens from openvidu-server:   REST API  openvidu-java-client  openvidu-node-client", 
            "title": "How?"
        }, 
        {
            "location": "/#a-sequence-diagram-to-sum-up", 
            "text": "Identify your user and listen to a request for joining a video call (represented by [LOGIN OPERATION] and [JOIN VIDEO CALL] in the diagram). This process is entirely up to you.  You must get a  sessionId : a new one if the video call is being created or an existing one for an active video call. In the first case you need to ask openvidu-server for it (as shown in the diagram), in the second case you must retrieve it from wherever you stored it when it was created (a data-base or maybe your backend itself).  You also need a new valid  token  for this session. Ask openvidu-server for it passing the  sessionId .  Finally return both parameters to your frontend, where using openvidu-browser you may initilize your session with  sessionId  and then connect to it with  token . Good news:  the code is exactly the same as explained before in  Code description  section    Communication between  Your Back  and  openvidu-server  modules is outlined in the diagram, but it does not correspond to the real methods. Remember you can handle this from your backend by consuming the  REST API  or by using  openvidu-backend-client  package.", 
            "title": "A sequence diagram to sum up"
        }, 
        {
            "location": "/#running-a-secure-videocall-application", 
            "text": "We have implemented a very basic  demo application  to see the secure version of OpenVidu in action. It has a Java backend to manage the user sessions and the securization process with OpenVidu Server.   Please be sure that you have  docker CE installed  Run this Docker container   docker run -p 5000:5000 -p 3000:3000 -p 4040:4040 -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 openvidu/openvidu-sample-secure   Wait until you see a public URL ended with  .ngrok.io . You can connect locally in  localhost:3000  or by using the ngrok public URL. You can also share this URL with anyone you want to test the app over the Internet!", 
            "title": "Running a secure videocall application"
        }, 
        {
            "location": "/#running-a-sample-advanced-app", 
            "text": "Wanna try a  real sample application  that makes use of everything we have talked about? Take a look at this app. It wraps a frontend built with Angular, a backend built with Spring and a MySQL database:   Please be sure that you have docker-compose ( sudo apt-get install docker-compose )  Download the  docker-compose.yml  file and run it:   wget -O docker-compose.yml https://raw.githubusercontent.com/OpenVidu/openvidu-docker/master/openvidu-sample-app/docker-compose.yml\ndocker-compose up    Wait until you see an output like  Started App in XXX seconds (JVM running for XXX)    Go to  https://localhost:5000  and accept the self-signed certificate. Here you have a couple registered users (use a standard window and an incognito window to test both of them at the same time):     user  password      teacher@ gmail.com  pass    student1@ gmail.com  pass", 
            "title": "Running a sample advanced app"
        }, 
        {
            "location": "/#sharing-data-between-users", 
            "text": "Whatever app you are developing, chances are you will need to pass some data for each user, at least a nickname. You can do it in two different places:   openvidu-browser : when calling  session.connect  method   session.connect(token, DATA, function (error) { ... });   API REST : when asking for a token to  /api/tokens , you can pass data as third parameter in the BODY of the POST request    {\u201csession\u201d: \u201csessionId\u201d, \u201crole\u201d: \u201crole\u201d, \u201cdata\u201d:  DATA }   Java and Node clients ( openvidu-java-client  and  openvidu-node-client ) allow you to pass data when creating a Token object:   tokenOptions = new TokenOptions.Builder().data(\"DATA\").build();   The result will be that in all clients,  Connection  objects will have in their  data  property the pertinent value you have provided for each user. So, an easy way to get the data associated to any user would be:  session.on('streamCreated', function (event) {\n    session.subscribe(event.stream, 'subscriber');\n    console.log('USER DATA: ' + event.stream.connection.data);\n});  Some clarifications:    Connection.data  will be a simple string if you have provided data only with one of the methods, and will be a string with the following format if you provide data both from openvidu-browser and your backend: \"OPENVIDUBROWSER_DATA%/%APIREST_DATA\"     Using only first option is not secure, as clients could modify the value of the second parameter. It is intended only in development environments. If you want total control over shared data, please use the second way.   You can choose whatever format you like for the data string, but if you are planning to share more than a simple field, maybe a standard format as JSON would be a wise choice.", 
            "title": "Sharing data between users"
        }, 
        {
            "location": "/#acknowledgments", 
            "text": "OpenVidu platform has been supported under project LERNIM (RTC-2016-4674-7) confunded by the  Ministry of Economy, Finance and Competitiveness  of Spain, as well as by the  European Union  FEDER, whose main goal with this funds is to promote technological development, innovation and high-quality research.", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/tutorials/", 
            "text": "OpenVidu Tutorials\n\n\n\n\n\n\n\n\n\n\n    \n\n\n        \n\n            \nClient Side only \n\n            \nGet started in 5 minutes with the simplest version of OpenVidu\n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript\n\n                    \nVanilla JavaScript app: good old JS code for a traditional approach.\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nAngular\n\n                    \nTry this fantastic tutorial using the last version of Angular framework.\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \nComing soon...\n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nReact\n\n                    \nThis React app will get you going in the blink of an eye.\n\n                \n\n            \n\n\n        \n\n        \n\n\n        \n\n\n        \n\n            \nClient Side + Server Side \n\n            \nTry any of our ready-for-production web apps to see the secure version of OpenVidu in action with a real\n                example\n            \n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Java SPA\n\n                    \nVanilla JavasCript frontend and a SPA Java Backend: forget building HTML templates, just feed your\n                        front with HTTP requests\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Java MVC\n\n                    \nVanilla JavasCript frontend and a traditional Java MVC Backend: serve HTML pages from your server\n\n                \n\n            \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Node SPA\n\n                    \nVanilla JavasCript frontend and a SPA Node Backend: forget building HTML templates, just feed your\n                        front with HTTP requests\n\n                \n\n            \n\n\n\n        \n\n        \n\n\n        \n\n\n            \n\n                \n\n                    \n\n                        \n\n                        \n\n                            \n\n                                \n\n                            \n\n                            \nx\n\n                        \n\n                    \n\n                \n\n                \n\n                    \nJavaScript + Node MVC\n\n                    \nVanilla JavasCript frontend and a traditional Node MVC backend: serve HTML pages from your server", 
            "title": "Intro"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/", 
            "text": "openvidu-insecure-js\n\n\nThis is the simplest demo you can try to get started with OpenVidu. It has the minimum set of features to make a video-call. You will only need a few minutes to get your first application working.\n\n\nUnderstanding this example\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flows transmission\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n to get this sample app working.\n\n\n\n\nExecuting this example\n\n\n\n\n\n\nClone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n\n\nYou will need an http web server installed in your development computer to execute the sample application. If you have \nnode.js\n installed, you can use \nhttp-server\n to serve application files. It can be installed with:\n\n\nnpm install -g http-server\n\n\n\n\n\n\nTo run the sample application, execute the following command in the project:\n\n\ncd openvidu-insecure-js/web\nhttp-server\n\n\n\n\n\n\nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-server-kms\n\n\n\n\n\n\nGo to \nlocalhost:8080\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nUnderstanding the code\n\n\nThis application is very simple. It has only 4 files:\n\n\n\n\nOpenVidu.js\n: openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n: sample application main JavaScritp file, which makes use of \nOpenVidu.js\n. You can manipulate this file to suit your needs.\n\n\nindex.html\n: HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to adapt it to suit your needs. \n    It has two links to both JavaScript files: \n\n\n\n\nscript src=\nOpenVidu.js\n/script\n\n\nscript src=\napp.js\n/script\n\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n. You can manipulate this file to suit your needs.\n\n\n\n\nLet's see how \napp.js\n uses \nOpenVidu.js\n:\n\n\n\n\nFirst lines declare the two variables that will be needed in different points along the code. \nOV\n will be our OpenVidu object and \nsession\n the video-call we will connect to:\n\n\n\n\nvar OV;\nvar session;\n\n\n\n\n\n\nLet's initialize a new session and configure our events:\n\n\n\n\n// --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// OpenVidu listening on \nlocalhost:8443\n\nOV = new OpenVidu(\nwss://\n + location.hostname + \n:8443/\n);\n\n// We will join the video-call \nsessionId\n\nsession = OV.initSession(sessionId);\n\n\n\n\nSince we are in a local sample app, \nOV\n object is initialize with \nlocalhost:8443\n as its \nopenvidu-server\n URL. \nsession\n object is initialize with \nsessionId\n param: this means we will connect to \nsessionId\n video-call. In this case, this parameter is retrieve from HTML input     \ninput type=\"text\" id=\"sessionId\" required\n, which may be filled by the user.\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new \np\n element for the user's nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n\n    // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM\n    removeUserData(event.stream.connection);\n});\n\n\n\n\nHere we subscribe to the events that interest us. In this case, we want to receive all videos published to the video-call, as well as displaying every user's nickname nex to its video. To achieve this:\n\n\nstreamCreated\n: for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'subscriber'. \n\n\nvideoElementCreated\n: event triggered by Subscriber object (returned by the previous \nSession.subscribe\n method). This allows us to add the participant nickname to the new video previously added in \nstreamCreated\n event. Auxiliary method \nappendUserData\n is responsible for appending a new paragraph element just below the \nevent.element\n video, containing \nsubscriber.stream.connection.data\n field (which has the user's nickname).\n\n\nstreamDestroyed\n: for each Stream that has been destroyed (which means a user has left the video-call), we remove the paragraph element with the user's nickname that we added in the previous event (\nappendUserData\n method created the element with an \nid\n containing \nevent.stream.connection.connectionId\n unique value, so we can now identify the right element to be removed). The video element is automatically deleted by default, so we don't need to do anything else.\n\n\n\n\nFinally connect to the session and publish your webcam:\n\n\n\n\n// --- 3) Connect to the session ---\n\n// 'token' param irrelevant when using insecure version of OpenVidu. Second param will be received by every user\n// in Stream.connection.data property, which will be appended to DOM as the user's nickname\nsession.connect(token, '{\nclientData\n: \n' + token + '\n}', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // --- 4) Get your own camera stream with the desired resolution ---\n\n        // Both audio and video will be active. HTML video element will be appended to element with 'publisher' id\n        var publisher = OV.initPublisher('publisher', {\n            audio: true,\n            video: true,\n            quality: 'MEDIUM'\n        });\n\n        // --- 5) Publish your stream ---\n\n        session.publish(publisher);\n\n    } else {\n        console.log('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n\n\n\ntoken\n param is irrelevant when using insecure version of OpenVidu. Remember \nvideoElementCreated\n event, when we added the user's nickname to the HTML? Well, second parameter is the actual value you will receive in \nStream.connection.data\n property. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input \ninput type=\"text\" id=\"participantId\" required\n (filled by the user).\n\n\nIn the callback of \nSession.connect\n method, we check the connection has been succesful (\nerror\n value must be \nnull\n) and right after that we get a \nPublisher\n object with both audio and video activated and MEDIUM quality. This process will end with the addition of a new HTML video element showing your camera, as a child of element with \nid\n 'publisher'. We then just have to publish this object through \nSession.publish\n method, and the rest of users will begin receiving our webcam.", 
            "title": "openvidu-insecure-js"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#openvidu-insecure-js", 
            "text": "This is the simplest demo you can try to get started with OpenVidu. It has the minimum set of features to make a video-call. You will only need a few minutes to get your first application working.", 
            "title": "openvidu-insecure-js"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#understanding-this-example", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flows transmission    You will only have to make use of  openvidu-browser  to get this sample app working.", 
            "title": "Understanding this example"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#executing-this-example", 
            "text": "Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git    You will need an http web server installed in your development computer to execute the sample application. If you have  node.js  installed, you can use  http-server  to serve application files. It can be installed with:  npm install -g http-server    To run the sample application, execute the following command in the project:  cd openvidu-insecure-js/web\nhttp-server    openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-server-kms    Go to  localhost:8080  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.", 
            "title": "Executing this example"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-js/#understanding-the-code", 
            "text": "This application is very simple. It has only 4 files:   OpenVidu.js : openvidu-browser library. You don't have to manipulate this file.   app.js : sample application main JavaScritp file, which makes use of  OpenVidu.js . You can manipulate this file to suit your needs.  index.html : HTML code for the form to connect to a video-call and for the video-call itself. You can manipulate this file to adapt it to suit your needs. \n    It has two links to both JavaScript files:    script src= OpenVidu.js /script  script src= app.js /script    style.css : some CSS classes to style  index.html . You can manipulate this file to suit your needs.   Let's see how  app.js  uses  OpenVidu.js :   First lines declare the two variables that will be needed in different points along the code.  OV  will be our OpenVidu object and  session  the video-call we will connect to:   var OV;\nvar session;   Let's initialize a new session and configure our events:   // --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// OpenVidu listening on  localhost:8443 \nOV = new OpenVidu( wss://  + location.hostname +  :8443/ );\n\n// We will join the video-call  sessionId \nsession = OV.initSession(sessionId);  Since we are in a local sample app,  OV  object is initialize with  localhost:8443  as its  openvidu-server  URL.  session  object is initialize with  sessionId  param: this means we will connect to  sessionId  video-call. In this case, this parameter is retrieve from HTML input      input type=\"text\" id=\"sessionId\" required , which may be filled by the user.  // --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it. HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new  p  element for the user's nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n\n    // Delete the HTML element with the user's nickname. HTML videos are automatically removed from DOM\n    removeUserData(event.stream.connection);\n});  Here we subscribe to the events that interest us. In this case, we want to receive all videos published to the video-call, as well as displaying every user's nickname nex to its video. To achieve this:  streamCreated : for each new Stream received by OpenVidu, we immediately subscribe to it so we can see its video. A new HTML video element will be appended to element with id 'subscriber'.   videoElementCreated : event triggered by Subscriber object (returned by the previous  Session.subscribe  method). This allows us to add the participant nickname to the new video previously added in  streamCreated  event. Auxiliary method  appendUserData  is responsible for appending a new paragraph element just below the  event.element  video, containing  subscriber.stream.connection.data  field (which has the user's nickname).  streamDestroyed : for each Stream that has been destroyed (which means a user has left the video-call), we remove the paragraph element with the user's nickname that we added in the previous event ( appendUserData  method created the element with an  id  containing  event.stream.connection.connectionId  unique value, so we can now identify the right element to be removed). The video element is automatically deleted by default, so we don't need to do anything else.   Finally connect to the session and publish your webcam:   // --- 3) Connect to the session ---\n\n// 'token' param irrelevant when using insecure version of OpenVidu. Second param will be received by every user\n// in Stream.connection.data property, which will be appended to DOM as the user's nickname\nsession.connect(token, '{ clientData :  ' + token + ' }', function (error) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!error) {\n\n        // --- 4) Get your own camera stream with the desired resolution ---\n\n        // Both audio and video will be active. HTML video element will be appended to element with 'publisher' id\n        var publisher = OV.initPublisher('publisher', {\n            audio: true,\n            video: true,\n            quality: 'MEDIUM'\n        });\n\n        // --- 5) Publish your stream ---\n\n        session.publish(publisher);\n\n    } else {\n        console.log('There was an error connecting to the session:', error.code, error.message);\n    }\n});  token  param is irrelevant when using insecure version of OpenVidu. Remember  videoElementCreated  event, when we added the user's nickname to the HTML? Well, second parameter is the actual value you will receive in  Stream.connection.data  property. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input  input type=\"text\" id=\"participantId\" required  (filled by the user).  In the callback of  Session.connect  method, we check the connection has been succesful ( error  value must be  null ) and right after that we get a  Publisher  object with both audio and video activated and MEDIUM quality. This process will end with the addition of a new HTML video element showing your camera, as a child of element with  id  'publisher'. We then just have to publish this object through  Session.publish  method, and the rest of users will begin receiving our webcam.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/", 
            "text": "openvidu-insecure-angular\n\n\nThis is the Angular version of \nopenvidu-insecure-js\n. Try it if you plan to use Angular framework for your frontend.\n\n\nUnderstanding this example\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the three modules displayed on the image above in its insecure version.\n\n\n\n\nopenvidu-browser\n: NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n NPM package to get this sample app working\n\n\n\n\nExecuting this example\n\n\n\n\n\n\nClone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n\n\nYou will need angular-cli to serve the Angular frontend. You can install it with the following command:\n\n\nnpm install -g @angular/cli\n\n\n\n\n\n\nTo run the sample application, execute the following command in the project:\n\n\ncd openvidu-insecure-angular\nnpm install\nng serve\n\n\n\n\n\n\nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-server-kms\n\n\n\n\n\n\nGo to \nlocalhost:4200\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call.\n\n\n\n\n\n\nUnderstanding the code\n\n\nThis is an Angular project generated with angular-cli, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. After getting \nopenvidu-browser\n NPM package (\nnpm install openvidu-browser\n), we will focus on the following files under \nsrc/app/\n folder:\n\n\n\n\napp.component.ts\n: AppComponent, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.\n\n\napp.component.html\n: HTML for AppComponent.\n\n\napp.component.css\n: CSS for AppComponent.\n\n\nstream.component.css\n: StreamComponent, auxiliary component to manage Stream objects on our own. It wraps the final HTML \nvideo\n which will display the video of its Stream property, as well as the user's nickname in a \np\n element.\n\n\n\n\nLet's see how \napp.component.ts\n uses \nopenvidu-browser\n:\n\n\n\n\nFirst line imports the necessary objects from \nopenvidu-browser\n:\n\n\n\n\nimport { OpenVidu, Session, Stream } from 'openvidu-browser';\n\n\n\n\n\n\napp.component.ts\n declares the following properties:\n\n\n\n\n// OpenVidu objects\nOV: OpenVidu;\nsession: Session;\n\n// Streams to feed StreamComponent's\nremoteStreams: Stream[] = [];\nlocalStream: Stream;\n\n// Join form\nsessionId: string;\ntoken: string;\n\n\n\n\nOpenVidu\n object will allow us to get a \nSession\n object, which is declared just after it. \nremoteStreams\n array will store the active streams of other users in the video-call and \nlocalStream\n will be your own local webcam stream. Finally, \nsessionId\n and \ntoken\n params simply represent the video-call and your participant's nickname, as you will see in a moment.\n\n\n\n\nWhenever a user clicks on the submit input defined in \napp.component.html\n, \njoinSession()\n method is called:\n\n\n\n\n// --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// OpenVidu listening on \nlocalhost:8443\n\nthis.OV = new OpenVidu('wss://' + location.hostname + ':8443/');\n\n// We will join the video-call \nsessionId\n\nthis.session = this.OV.initSession(this.sessionId);\n\n\n\n\nSince we are in a local sample app, \nOV\n is initialize with \nlocalhost:8443\n as its \nopenvidu-server\n URL. \nsession\n is initialize with \nsessionId\n param: this means we will connect to \nsessionId\n video-call. In this case, this parameter is binded from an \ninput\n element of \napp.component.html\n, which may be filled by the user.\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event) =\n {\n\n    // Add the new stream to 'remoteStreams' array\n    this.remoteStreams.push(event.stream);\n\n    // Subscribe to the Stream to receive it. Second parameter is an empty string \n    // so OpenVidu doesn't create an HTML video by its own \n    this.session.subscribe(event.stream, '');\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event) =\n {\n\n    // Avoid OpenVidu trying to remove the HTML video element\n    event.preventDefault();\n\n    // Remove the stream from 'remoteStreams' array\n    this.deleteRemoteStream(event.stream);\n});\n\n\n\n\nHere we subscribe to the Session events that interest us. As we are using Angular framework, a good approach will be treating each Stream as a component, contained in a StreamComponent. Thus, we need to store each new stream we received in an array (\nremoteStreams\n), and we must remove from it every deleted stream whenever it is necessary. To achieve this, we use the following events:\n\n\nstreamCreated\n: for each new Stream received by OpenVidu, we store it in our \nremoteStreams\n array and immediately subscribe to it so we can receive its video (empty string as second parameter, so OpenVidu doesn't create an HTML video on its own). HTML template of AppComponent will show the new video, as it contains an \nngFor\n directive which will create a new StreamComponent for each Stream object stored in the array:\n\n\ndiv id=\nsubscriber\n\n    \ndiv *ngFor=\nlet s of this.remoteStreams\n\n        \nstream-component [stream]=\ns\n/stream-component\n\n    \n/div\n\n\n/div\n\n\n\n\n\nstreamDestroyed\n: for each Stream that has been destroyed (which means a user has left the video-call), we remove it from \nremoteStreams\n array, so Angular will automatically delete the required StreamComponent from HTML. We call \nevent.preventDefault()\n to cancel OpenVidu default behaviour towards \nstreamDestroyed\n event, which is the deletion of the previously created HTML video element on \nstreamCreated\n event. Because we are handling the video elements by ourselves taking advantage of Angular capabilities, we tell OpenVidu not to create them on \nstreamCreated\n and not to delete them on \nstreamDestroyed\n, by passing an empty string as second parameter on \nSession.subscribe()\n method on \nstreamCreated\n and by calling \nevent.preventDefault()\n on \nstreamDestroyed\n.\n\n\n\n\nFinally connect to the session and publish your webcam:\n\n\n\n\n\n// --- 3) Connect to the session ---\n\n// 'token' param irrelevant when using insecure version of OpenVidu. Second param will be received by every user\n// in Stream.connection.data property, which will be appended to DOM as the user's nickname\nthis.session.connect(this.token, '{\nclientData\n: \n' + this.token + '\n}', (error) =\n {\n\n    // If the connection is successful...\n    if (!error) {\n\n    // --- 4) Get your own camera stream with the desired resolution ---\n\n    // Both audio and video will be active. HTML video element will be appended to element with 'publisher' id\n    let publisher = this.OV.initPublisher('', {\n        audio: true,\n        video: true,\n        quality: 'MEDIUM'\n    });\n\n    //Store your webcam stream in 'localStream' object\n    this.localStream = publisher.stream;\n\n    // --- 5) Publish your stream ---\n\n    this.session.publish(publisher);\n\n    } else {\n    console.log('There was an error connecting to the session:', error.code, error.message);\n    }\n});\n\n\n\n\ntoken\n param is irrelevant when using insecure version of OpenVidu. Second parameter will supply the user's nickname showed by StreamComponent inside its \np\n element. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input \ninput type=\"text\" name=\"token\" id=\"token\" [(ngModel)]=\"token\" required\n (filled by the user).\n\n\nIn the callback of \nSession.connect\n method, we check the connection has been succesful (\nerror\n value must be \nnull\n) and right after that we get a \nPublisher\n object with both audio and video activated and MEDIUM quality. We then store our local Stream (contained in \nPublisher.stream\n object) in \nlocalStream\n and publish the Publisher object through \nSession.publish()\n method. The rest of users will receive our Stream object and will execute their \nstreamCreated\n event.\n\n\nWith regard to our local Stream, AppComponent's HTML template has also one StreamComponent declaration ready to show our own webcam as we did with remote streams:\n\n\ndiv id=\npublisher\n\n    \ndiv *ngIf=\nthis.localStream\n\n        \nstream-component [stream]=\nthis.localStream\n/stream-component\n\n    \n/div\n\n\n/div\n\n\n\n\n\nLast point worth considering is the \nngDoCheck()\n implementation of StreamComponent. As we are handling Stream objects by ourselves (task which usually is taken care by OpenVidu), and because the URL of Stream objects takes some time to get its final value as the WebRTC negotiation takes place, we must listen to any change in \nstream\n @Input property. This allows us to update \nvideoSrc\n value of the component, which finally ends up being the \nsrc\n value of the \nvideo\n element. If we didn't do this, the Stream object will update its \nsrc\n property, but our StreamComponent would keep the same initial \nvideoSrc\n value. This ensures that all our StreamComponent's will properly display all the videos in the video-call using the correct \nsrc\n value.\n\n\nngDoCheck() { // Detect any change in 'stream' property\n\n    // If 'src' of Stream object has changed, 'videoSrc' value must be updated\n    if (!(this.videSrcUnsafe === this.stream.getVideoSrc())) {\n\n        // Angular mandatory URL sanitization\n        this.videoSrc = this.sanitizer.bypassSecurityTrustUrl(this.stream.getVideoSrc());\n\n        // Auxiliary value to store the URL as a string for upcoming comparisons\n        this.videSrcUnsafe = this.stream.getVideoSrc();\n    }\n}", 
            "title": "openvidu-insecure-angular"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#openvidu-insecure-angular", 
            "text": "This is the Angular version of  openvidu-insecure-js . Try it if you plan to use Angular framework for your frontend.", 
            "title": "openvidu-insecure-angular"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#understanding-this-example", 
            "text": "OpenVidu is composed by the three modules displayed on the image above in its insecure version.   openvidu-browser : NPM package for your Angular app. It allows you to manage your video-calls straight away from your clients  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  NPM package to get this sample app working", 
            "title": "Understanding this example"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#executing-this-example", 
            "text": "Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git    You will need angular-cli to serve the Angular frontend. You can install it with the following command:  npm install -g @angular/cli    To run the sample application, execute the following command in the project:  cd openvidu-insecure-angular\nnpm install\nng serve    openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.security=false openvidu/openvidu-server-kms    Go to  localhost:4200  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call.", 
            "title": "Executing this example"
        }, 
        {
            "location": "/tutorials/openvidu-insecure-angular/#understanding-the-code", 
            "text": "This is an Angular project generated with angular-cli, and therefore you will see lots of configuration files and other stuff that doesn't really matter to us. After getting  openvidu-browser  NPM package ( npm install openvidu-browser ), we will focus on the following files under  src/app/  folder:   app.component.ts : AppComponent, main component of the app. It contains the functionalities for joining a video-call and for handling the video-calls themselves.  app.component.html : HTML for AppComponent.  app.component.css : CSS for AppComponent.  stream.component.css : StreamComponent, auxiliary component to manage Stream objects on our own. It wraps the final HTML  video  which will display the video of its Stream property, as well as the user's nickname in a  p  element.   Let's see how  app.component.ts  uses  openvidu-browser :   First line imports the necessary objects from  openvidu-browser :   import { OpenVidu, Session, Stream } from 'openvidu-browser';   app.component.ts  declares the following properties:   // OpenVidu objects\nOV: OpenVidu;\nsession: Session;\n\n// Streams to feed StreamComponent's\nremoteStreams: Stream[] = [];\nlocalStream: Stream;\n\n// Join form\nsessionId: string;\ntoken: string;  OpenVidu  object will allow us to get a  Session  object, which is declared just after it.  remoteStreams  array will store the active streams of other users in the video-call and  localStream  will be your own local webcam stream. Finally,  sessionId  and  token  params simply represent the video-call and your participant's nickname, as you will see in a moment.   Whenever a user clicks on the submit input defined in  app.component.html ,  joinSession()  method is called:   // --- 1) Get an OpenVidu object and init a session with a sessionId ---\n\n// OpenVidu listening on  localhost:8443 \nthis.OV = new OpenVidu('wss://' + location.hostname + ':8443/');\n\n// We will join the video-call  sessionId \nthis.session = this.OV.initSession(this.sessionId);  Since we are in a local sample app,  OV  is initialize with  localhost:8443  as its  openvidu-server  URL.  session  is initialize with  sessionId  param: this means we will connect to  sessionId  video-call. In this case, this parameter is binded from an  input  element of  app.component.html , which may be filled by the user.  // --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nthis.session.on('streamCreated', (event) =  {\n\n    // Add the new stream to 'remoteStreams' array\n    this.remoteStreams.push(event.stream);\n\n    // Subscribe to the Stream to receive it. Second parameter is an empty string \n    // so OpenVidu doesn't create an HTML video by its own \n    this.session.subscribe(event.stream, '');\n});\n\n// On every Stream destroyed...\nthis.session.on('streamDestroyed', (event) =  {\n\n    // Avoid OpenVidu trying to remove the HTML video element\n    event.preventDefault();\n\n    // Remove the stream from 'remoteStreams' array\n    this.deleteRemoteStream(event.stream);\n});  Here we subscribe to the Session events that interest us. As we are using Angular framework, a good approach will be treating each Stream as a component, contained in a StreamComponent. Thus, we need to store each new stream we received in an array ( remoteStreams ), and we must remove from it every deleted stream whenever it is necessary. To achieve this, we use the following events:  streamCreated : for each new Stream received by OpenVidu, we store it in our  remoteStreams  array and immediately subscribe to it so we can receive its video (empty string as second parameter, so OpenVidu doesn't create an HTML video on its own). HTML template of AppComponent will show the new video, as it contains an  ngFor  directive which will create a new StreamComponent for each Stream object stored in the array:  div id= subscriber \n     div *ngFor= let s of this.remoteStreams \n         stream-component [stream]= s /stream-component \n     /div  /div   streamDestroyed : for each Stream that has been destroyed (which means a user has left the video-call), we remove it from  remoteStreams  array, so Angular will automatically delete the required StreamComponent from HTML. We call  event.preventDefault()  to cancel OpenVidu default behaviour towards  streamDestroyed  event, which is the deletion of the previously created HTML video element on  streamCreated  event. Because we are handling the video elements by ourselves taking advantage of Angular capabilities, we tell OpenVidu not to create them on  streamCreated  and not to delete them on  streamDestroyed , by passing an empty string as second parameter on  Session.subscribe()  method on  streamCreated  and by calling  event.preventDefault()  on  streamDestroyed .   Finally connect to the session and publish your webcam:   \n// --- 3) Connect to the session ---\n\n// 'token' param irrelevant when using insecure version of OpenVidu. Second param will be received by every user\n// in Stream.connection.data property, which will be appended to DOM as the user's nickname\nthis.session.connect(this.token, '{ clientData :  ' + this.token + ' }', (error) =  {\n\n    // If the connection is successful...\n    if (!error) {\n\n    // --- 4) Get your own camera stream with the desired resolution ---\n\n    // Both audio and video will be active. HTML video element will be appended to element with 'publisher' id\n    let publisher = this.OV.initPublisher('', {\n        audio: true,\n        video: true,\n        quality: 'MEDIUM'\n    });\n\n    //Store your webcam stream in 'localStream' object\n    this.localStream = publisher.stream;\n\n    // --- 5) Publish your stream ---\n\n    this.session.publish(publisher);\n\n    } else {\n    console.log('There was an error connecting to the session:', error.code, error.message);\n    }\n});  token  param is irrelevant when using insecure version of OpenVidu. Second parameter will supply the user's nickname showed by StreamComponent inside its  p  element. So in this case it is a JSON formatted string with a \"clientData\" tag with \"token\" value, which is retrieved from HTML input  input type=\"text\" name=\"token\" id=\"token\" [(ngModel)]=\"token\" required  (filled by the user).  In the callback of  Session.connect  method, we check the connection has been succesful ( error  value must be  null ) and right after that we get a  Publisher  object with both audio and video activated and MEDIUM quality. We then store our local Stream (contained in  Publisher.stream  object) in  localStream  and publish the Publisher object through  Session.publish()  method. The rest of users will receive our Stream object and will execute their  streamCreated  event.  With regard to our local Stream, AppComponent's HTML template has also one StreamComponent declaration ready to show our own webcam as we did with remote streams:  div id= publisher \n     div *ngIf= this.localStream \n         stream-component [stream]= this.localStream /stream-component \n     /div  /div   Last point worth considering is the  ngDoCheck()  implementation of StreamComponent. As we are handling Stream objects by ourselves (task which usually is taken care by OpenVidu), and because the URL of Stream objects takes some time to get its final value as the WebRTC negotiation takes place, we must listen to any change in  stream  @Input property. This allows us to update  videoSrc  value of the component, which finally ends up being the  src  value of the  video  element. If we didn't do this, the Stream object will update its  src  property, but our StreamComponent would keep the same initial  videoSrc  value. This ensures that all our StreamComponent's will properly display all the videos in the video-call using the correct  src  value.  ngDoCheck() { // Detect any change in 'stream' property\n\n    // If 'src' of Stream object has changed, 'videoSrc' value must be updated\n    if (!(this.videSrcUnsafe === this.stream.getVideoSrc())) {\n\n        // Angular mandatory URL sanitization\n        this.videoSrc = this.sanitizer.bypassSecurityTrustUrl(this.stream.getVideoSrc());\n\n        // Auxiliary value to store the URL as a string for upcoming comparisons\n        this.videSrcUnsafe = this.stream.getVideoSrc();\n    }\n}", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/", 
            "text": "openvidu-js-java\n\n\nA secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of \nopenvidu-java-client\n to get the necessary params from OpenVidu Server.\n\n\nUnderstanding this example\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-java-client\n: Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-java-client\n to get this sample app working\n\n\n\n\nExecuting this example\n\n\n\n\n\n\nClone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n\n\nYou will need \nmaven\n to build the project. You can install it with:\n\n\nsudo apt-get install maven\n\n\n\n\n\n\nTo run the sample application, execute the following command in the project:\n\n\ncd openvidu-js-java\nmvn package exec:java\n\n\n\n\n\n\nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n\n\nGo to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nHttpSession\n API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: \njournaldev.com\n, \nstudytonight.com\n.\n\n\n\n\n\n\nBackend: SpringBoot app with the following classes (\nsrc/main/java\n path, \nio.openvidu.js.java\n package)\n\n\n\n\nApp.java\n : entrypoint for the app\n\n\nLoginController.java\n : rest controller for handling login and logout operations\n\n\nSessionController.java\n : rest controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them\n\n\n\n\n\n\n\n\nFrontend: Pure JS/HTML/CSS files (\nsrc/main/resources/static\n)\n\n\n\n\nOpenVidu.js\n : openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n : sample application main JavaScritp file, which makes use of \nOpenVidu.js\n.\n\n\n\n\nindex.html\n : HTML code for the form to login, the form to connect to a video-call and for the video-call itself.\n    It has two links to both JavaScript files: \n    \nhtml\n    \nscript src=\"OpenVidu.js\"\n/script\n\n    \nscript src=\"app.js\"\n/script\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1)  User logs in\n\n\nWe have implemented a method for making HTTP requests to the backend, as we will need to make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:\n\n\nfunction httpRequest(method, url, body, errorMsg, callback)\n\n\n\n\nWhere \nmethod\n is whether \"POST\" or \"GET\", \nurl\n the path of the REST operation, \nbody\n the data to be passed, \nerrorMsg\n the output error message if something goes wrong and \ncallback\n the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.\n\n\nindex.html\n will first show a form to log in:\n\n\n\n  \n\n\n\n\n\napp.js\n sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:\n\n\nfunction logIn() {\n    var user = $(\n#user\n).val(); // Username\n    var pass = $(\n#pass\n).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        console.warn(userName + ' login');\n        // HTML shows logged-in page ...\n    });\n}\n\n\n\n\nLoginController.java\n checks the params are correct and if so sets an \nHttpSession\n for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object):\n\n\n@RequestMapping(value = \n/api-login/login\n, method = RequestMethod.POST)\npublic ResponseEntity\nObject\n login(@RequestBody String userPass, HttpSession httpSession) \n                    throws ParseException {\n\n    // Retrieve params from POST body\n    JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass);\n    String user = (String) userPassJson.get(\nuser\n);\n    String pass = (String) userPassJson.get(\npass\n);\n\n    if (login(user, pass)){ // Correct user-pass\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute(\nloggedUser\n, user);\n        return new ResponseEntity\n(HttpStatus.OK);\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        httpSession.invalidate();\n        return new ResponseEntity\n(\nUser/Pass incorrect\n, HttpStatus.UNAUTHORIZED);\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\nHTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:\n\n\n\n  \n\n\n\n\n\napp.js\n will execute \njoinSession()\n method, which starts like this:\n\n\nfunction joinSession() {\n    getSessionIdAndToken(function () { ...\n\n\n\n\nSo the first thing to do here is to retrieve a \nsessionId\n and a \ntoken\n from our backend. Only when we have them available in the browser we will continue with the \njoin\n operation. Let's see what \ngetSessionIdAndToken()\n looks like:\n\n\nfunction getSessionIdAndToken(callback) {\n    sessionName = $(\n#sessionName\n).val(); // Video-call to connect (\nTUTORIAL\n)\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}\n\n\n\n\nHere is the second time we must call our \nhttpRequest()\n method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a \nsessionId\n and a \ntoken\n as response. The interesting part here is in \nSessionController.java\n. First of all there are some important attributes in this class we must mention:\n\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map\nString, Session\n mapSessions = new ConcurrentHashMap\n();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map\nString, Map\nString, OpenViduRole\n mapSessionIdsTokens = new ConcurrentHashMap\n();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;\n\n\n\n\nRest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: \ntokenOptions\n.\n\n\n@RequestMapping(value = \n/api-sessions/get-sessionid-token\n, method = RequestMethod.POST)\npublic ResponseEntity\nJSONObject\n getSessionIdToken(@RequestBody String sessionNameParam, \n        HttpSession httpSession) throws ParseException {\n    // Check the user is logged ... \n\n    JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam);\n\n    // The video-call to connect (\nTUTORIAL\n)\n    String sessionName = (String) sessionJSON.get(\nsession\n);\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\nloggedUser\n)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData = \n{\\\nserverData\\\n: \\\n + httpSession.getAttribute(\nloggedUser\n) + \n\\\n}\n;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n    JSONObject responseJson = new JSONObject();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exitsts? \n\n\nif (this.mapSessions.get(sessionName) != null) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap\n());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity\n(responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}\n\n\n\n\nWe are almost there! Now in \napp.js\n we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new \np\n element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{\nclientData\n: \n' + $(\n#participantName\n).val() + '\n}', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n\n    // HTML shows session page ...\n\n});\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nSessionController.java\n executes \ngetSessionIdAndToken()\n method. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param (\nTUTORIAL\n)\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity\n(responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}\n\n\n\n\nThe code executed in \napp.js\n would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nleaveSession()\n (and therefore \nsession.disconnect()\n) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, \nsession.disconnect()\n updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in \napp.js\n we run:\n\n\nfunction removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}\n\n\n\n\nAnd in \nSessionController.java\n we update the collections:\n\n\n@RequestMapping(value = \n/api-sessions/remove-user\n, method = RequestMethod.POST)\npublic ResponseEntity\nJSONObject\n removeUser(@RequestBody String sessionNameToken, \n    HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // Retrieve the params from BODY\n    JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken);\n    String sessionName = (String) sessionNameTokenJSON.get(\nsessionName\n);\n    String token = (String) sessionNameTokenJSON.get(\ntoken\n);\n\n    // If the session exists (\nTUTORIAL\n in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // Token has been removed\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session \nTUTORIAL\n must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                return new ResponseEntity\n(HttpStatus.OK);\n            } else {\n                // The TOKEN wasn't valid\n                return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    } else {\n        // The SESSION does not exist\n        return new ResponseEntity\n(HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n\n\n\n\nWhen the last user leaves the session \nthis.mapSessions.remove(sessionName);\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.", 
            "title": "openvidu-js-java"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#openvidu-js-java", 
            "text": "A secure OpenVidu sample app with a Java backend and a SPA frontend. It makes use of  openvidu-java-client  to get the necessary params from OpenVidu Server.", 
            "title": "openvidu-js-java"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#understanding-this-example", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-java-client : Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-java-client  to get this sample app working", 
            "title": "Understanding this example"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#executing-this-example", 
            "text": "Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git    You will need  maven  to build the project. You can install it with:  sudo apt-get install maven    To run the sample application, execute the following command in the project:  cd openvidu-js-java\nmvn package exec:java    openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms    Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.", 
            "title": "Executing this example"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Java backend. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  HttpSession  API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial:  journaldev.com ,  studytonight.com .    Backend: SpringBoot app with the following classes ( src/main/java  path,  io.openvidu.js.java  package)   App.java  : entrypoint for the app  LoginController.java  : rest controller for handling login and logout operations  SessionController.java  : rest controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them     Frontend: Pure JS/HTML/CSS files ( src/main/resources/static )   OpenVidu.js  : openvidu-browser library. You don't have to manipulate this file.   app.js  : sample application main JavaScritp file, which makes use of  OpenVidu.js .   index.html  : HTML code for the form to login, the form to connect to a video-call and for the video-call itself.\n    It has two links to both JavaScript files: \n     html\n     script src=\"OpenVidu.js\" /script \n     script src=\"app.js\" /script    style.css : some CSS classes to style  index.html .      Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#1-user-logs-in", 
            "text": "We have implemented a method for making HTTP requests to the backend, as we will need to make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:  function httpRequest(method, url, body, errorMsg, callback)  Where  method  is whether \"POST\" or \"GET\",  url  the path of the REST operation,  body  the data to be passed,  errorMsg  the output error message if something goes wrong and  callback  the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.  index.html  will first show a form to log in:  \n     app.js  sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:  function logIn() {\n    var user = $( #user ).val(); // Username\n    var pass = $( #pass ).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        console.warn(userName + ' login');\n        // HTML shows logged-in page ...\n    });\n}  LoginController.java  checks the params are correct and if so sets an  HttpSession  for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object):  @RequestMapping(value =  /api-login/login , method = RequestMethod.POST)\npublic ResponseEntity Object  login(@RequestBody String userPass, HttpSession httpSession) \n                    throws ParseException {\n\n    // Retrieve params from POST body\n    JSONObject userPassJson = (JSONObject) new JSONParser().parse(userPass);\n    String user = (String) userPassJson.get( user );\n    String pass = (String) userPassJson.get( pass );\n\n    if (login(user, pass)){ // Correct user-pass\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute( loggedUser , user);\n        return new ResponseEntity (HttpStatus.OK);\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        httpSession.invalidate();\n        return new ResponseEntity ( User/Pass incorrect , HttpStatus.UNAUTHORIZED);\n    }\n}", 
            "title": "1)  User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#2-user-connects-to-tutorial-video-call", 
            "text": "HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:  \n     app.js  will execute  joinSession()  method, which starts like this:  function joinSession() {\n    getSessionIdAndToken(function () { ...  So the first thing to do here is to retrieve a  sessionId  and a  token  from our backend. Only when we have them available in the browser we will continue with the  join  operation. Let's see what  getSessionIdAndToken()  looks like:  function getSessionIdAndToken(callback) {\n    sessionName = $( #sessionName ).val(); // Video-call to connect ( TUTORIAL )\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}  Here is the second time we must call our  httpRequest()  method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a  sessionId  and a  token  as response. The interesting part here is in  SessionController.java . First of all there are some important attributes in this class we must mention:  // OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map String, Session  mapSessions = new ConcurrentHashMap ();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map String, Map String, OpenViduRole  mapSessionIdsTokens = new ConcurrentHashMap ();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;  Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on:  tokenOptions .  @RequestMapping(value =  /api-sessions/get-sessionid-token , method = RequestMethod.POST)\npublic ResponseEntity JSONObject  getSessionIdToken(@RequestBody String sessionNameParam, \n        HttpSession httpSession) throws ParseException {\n    // Check the user is logged ... \n\n    JSONObject sessionJSON = (JSONObject) new JSONParser().parse(sessionNameParam);\n\n    // The video-call to connect ( TUTORIAL )\n    String sessionName = (String) sessionJSON.get( session );\n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute( loggedUser )).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData =  {\\ serverData\\ : \\  + httpSession.getAttribute( loggedUser ) +  \\ } ;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n    JSONObject responseJson = new JSONObject();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exitsts?   if (this.mapSessions.get(sessionName) != null) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap ());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity (responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}  We are almost there! Now in  app.js  we can init a new Session with  sessionId  and connect to it with  token :  // --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new  p  element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{ clientData :  ' + $( #participantName ).val() + ' }', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n\n    // HTML shows session page ...\n\n});  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  SessionController.java  executes  getSessionIdAndToken()  method. Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param ( TUTORIAL )\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Prepare the response with the sessionId and the token\n        responseJson.put(0, sessionId);\n        responseJson.put(1, token);\n\n        // Return the response to the client\n        return new ResponseEntity (responseJson, HttpStatus.OK);\n\n    } catch (Exception e) {\n        // If error generate an error message and return it to client\n        return getErrorResponse(e);\n    }\n}  The code executed in  app.js  would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-java/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  leaveSession()  (and therefore  session.disconnect() ) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up,  session.disconnect()  updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in  app.js  we run:  function removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}  And in  SessionController.java  we update the collections:  @RequestMapping(value =  /api-sessions/remove-user , method = RequestMethod.POST)\npublic ResponseEntity JSONObject  removeUser(@RequestBody String sessionNameToken, \n    HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // Retrieve the params from BODY\n    JSONObject sessionNameTokenJSON = (JSONObject) new JSONParser().parse(sessionNameToken);\n    String sessionName = (String) sessionNameTokenJSON.get( sessionName );\n    String token = (String) sessionNameTokenJSON.get( token );\n\n    // If the session exists ( TUTORIAL  in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // Token has been removed\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session  TUTORIAL  must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                return new ResponseEntity (HttpStatus.OK);\n            } else {\n                // The TOKEN wasn't valid\n                return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    } else {\n        // The SESSION does not exist\n        return new ResponseEntity (HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}  When the last user leaves the session  this.mapSessions.remove(sessionName);  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/", 
            "text": "openvidu-mvc-java\n\n\nA secure OpenVidu sample app with a Java backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to \nopenvidu-js-java\n. This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. \nThymeleaf\n is the template engine of choice for this tutorial.\n\n\nUnderstanding this example\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-java-client\n: Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-java-client\n to get this sample app working\n\n\n\n\nExecuting this example\n\n\n\n\n\n\nClone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n\n\nYou will need \nmaven\n to build the project. You can install it with:\n\n\nsudo apt-get install maven\n\n\n\n\n\n\nTo run the sample application, execute the following command in the project:\n\n\ncd openvidu-mvc-java\nmvn package exec:java\n\n\n\n\n\n\nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n\n\nGo to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of \nThymeleaf\n.\n\n\nOpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nHttpSession\n API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial: \njournaldev.com\n, \nstudytonight.com\n.\n\n\n\n\n\n\nBackend\n: SpringBoot app with the following classes (\nsrc/main/java\n path, \nio.openvidu.js.java\n package)\n\n\n\n\nApp.java\n : entrypoint for the app\n\n\nLoginController.java\n : controller for handling login and logout operations\n\n\nSessionController.java\n : controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them\n\n\n\n\n\n\n\n\nFrontend templates\n: Pure JS/HTML/CSS files served by the backend (\nsrc/main/resources/templates\n)\n\n\n\n\nindex.html\n : template with the login form\n\n\ndashboard.html\n : template with the form to join a video-call\n\n\nsession.html\n : template of the video-call itself\n\n\n\n\n\n\n\n\nFrontend static files\n (\nsrc/main/resources/static\n)\n\n\n\n\nOpenVidu.js\n : openvidu-browser library. You don't have to manipulate this file\n\n\nstyle.css\n : some CSS classes to style the templates\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nAt path \n/\n a login form will be displayed:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/dashboard\n whenever \"Log in\" button is clicked, passing the username and the password:\n\n\nform action=\n/dashboard\n method=\npost\n\n    \np\n\n        \nlabel\nUser\n/label\n \ninput type=\ntext\n name=\nuser\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nPass\n/label\n \ninput type=\npassword\n name=\npass\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nbutton type=\nsubmit\nLog in\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nLoginController.java\n first checks if the user is already logged (maybe he has just refreshed \n/dashboard\n page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an \nHttpSession\n for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns \ndashboard.html\n template:\n\n\n@RequestMapping(value = \n/dashboard\n, method = { RequestMethod.GET, RequestMethod.POST })\npublic String login(@RequestParam(name = \nuser\n, required = false) String user,\n            @RequestParam(name = \npass\n, required = false) String pass,\n            Model model, HttpSession httpSession) {\n\n    // Check if the user is already logged in\n    String userName = (String) httpSession.getAttribute(\nloggedUser\n);\n    if (userName != null) { \n        // User is already logged. Immediately return dashboard\n        model.addAttribute(\nusername\n, userName);\n        return \ndashboard\n;\n    }\n\n    // User wasn't logged and wants to\n    if (login(user, pass)) { // Correct user-pass\n\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute(\nloggedUser\n, user);\n        model.addAttribute(\nusername\n, user);\n\n        // Return dashboard.html template\n        return \ndashboard\n;\n\n    } else { // Wrong user-pass\n        // Invalidate session and redirect to index.html\n        httpSession.invalidate();\n        return \nredirect:/\n;\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\ndashboard.html\n template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/session\n whenever \"Join!\" button is clicked, passing the nickname and the session name:\n\n\nform action=\n/session\n method=\npost\n\n    \np\n\n        \nlabel\nName: \n/label\n \ninput name=\ndata\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nSession: \n/label\n \ninput name=\nsession-name\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nbutton type=\nsubmit\nJoin!\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nWhen \nSessionController.java\n receives a request at \n/session\n path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:\n\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map\nString, Session\n mapSessions = new ConcurrentHashMap\n();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map\nString, Map\nString, OpenViduRole\n mapSessionIdsTokens = new ConcurrentHashMap\n();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;\n\n\n\n\nRest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: \ntokenOptions\n.\n\n\n@RequestMapping(value = \n/session\n, method = RequestMethod.POST)\npublic String joinSession(@RequestParam(name = \ndata\n) String clientData,\n              @RequestParam(name = \nsession-name\n) String sessionName, \n              Model model, HttpSession httpSession) {\n    // Check the user is logged ... \n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute(\nloggedUser\n)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData = \n{\\\nserverData\\\n: \\\n + httpSession.getAttribute(\nloggedUser\n) + \n\\\n}\n;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exitsts? \n\n\nif (this.mapSessions.get(sessionName) != null) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap\n());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute(\nsessionId\n, sessionId);\n        model.addAttribute(\ntoken\n, token);\n        model.addAttribute(\nnickName\n, clientData);\n        model.addAttribute(\nuserName\n, httpSession.getAttribute(\nloggedUser\n));\n        model.addAttribute(\nsessionName\n, sessionName);\n\n        // Return session.html template\n        return \nsession\n;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute(\nusername\n, httpSession.getAttribute(\nloggedUser\n));\n        return \ndashboard\n;\n    }\n}\n\n\n\n\nWe are almost there! Now in \nsession.html\n JavaScript code (preceded by a tag \nscript th:inline=\"javascript\"\n) we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// Get all the attributes from the template in Thymeleaf style\nvar sessionId = [[${sessionId}]];\nvar token = [[${token}]];\nvar nickName = [[${nickName}]];\nvar userName = [[${userName}]];\nvar sessionName = [[${sessionName}]];\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new \np\n element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{\nclientData\n: \n' + nickName + '\n}', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher(userName)) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n}); \n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nSessionController.java\n executes \ngetSessionIdAndToken()\n method. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param (\nTUTORIAL\n)\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute(\nsessionId\n, sessionId);\n        model.addAttribute(\ntoken\n, token);\n        model.addAttribute(\nnickName\n, clientData);\n        model.addAttribute(\nuserName\n, httpSession.getAttribute(\nloggedUser\n));\n        model.addAttribute(\nsessionName\n, sessionName);\n\n        // Return session.html template\n        return \nsession\n;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute(\nusername\n, httpSession.getAttribute(\nloggedUser\n));\n        return \ndashboard\n;\n    }\n}\n\n\n\n\nThe code executed in \nsession.html\n \n script \n tag would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call**\n\n\nAfter a while both users decide to leave the session. Apart from calling \nsession.disconnect()\n (triggered in \nleaveSession()\n \nonclick\n method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.\n\n\nIn \nsession.html\n template the \"Leave session\" button actually performs a POST operation to path \n/leave-session\n with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the \nleaveSession()\n method. First updates our backend. Second updates our openvidu-server.\n\n\nform action=\n/leave-session\n method=\npost\n\n    \ninput type=\nhidden\n name=\nsession-name\n th:value=\n${sessionName}\n/input\n\n    \ninput type=\nhidden\n name=\ntoken\n th:value=\n${token}\n/input\n\n    \nbutton type=\nsubmit\n onclick=\nleaveSession()\nLeave session\n/button\n\n\n/form\n\n\n\n\n\nIn \nSessionController.java\n we update the collections:\n\n\n@RequestMapping(value = \n/leave-session\n, method = RequestMethod.POST)\npublic String removeUser(@RequestParam(name = \nsession-name\n) String sessionName,\n             @RequestParam(name = \ntoken\n) String token,\n             Model model, HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // If the session exists (\nTUTORIAL\n in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // Token has been removed\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session \nTUTORIAL\n must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                model.addAttribute(\nsessionId\n, sessionId);\n                return \nredirect:/dashboard\n;\n            } else {\n                // The TOKEN wasn't valid\n                model.addAttribute(\nsessionId\n, sessionId);\n                return \nredirect:/dashboard\n;\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            model.addAttribute(\nsessionId\n, sessionId);\n            return \nredirect:/dashboard\n;\n        }\n    } else {\n        // The SESSION does not exist\n        model.addAttribute(\nsessionId\n, sessionId);\n        return \nredirect:/dashboard\n;\n    }\n}\n\n\n\n\nWhen the last user leaves the session \nthis.mapSessions.remove(sessionName);\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.", 
            "title": "openvidu-mvc-java"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#openvidu-mvc-java", 
            "text": "A secure OpenVidu sample app with a Java backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to  openvidu-js-java . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends.  Thymeleaf  is the template engine of choice for this tutorial.", 
            "title": "openvidu-mvc-java"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#understanding-this-example", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-java-client : Java package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-java-client  to get this sample app working", 
            "title": "Understanding this example"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#executing-this-example", 
            "text": "Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git    You will need  maven  to build the project. You can install it with:  sudo apt-get install maven    To run the sample application, execute the following command in the project:  cd openvidu-mvc-java\nmvn package exec:java    openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms    Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.", 
            "title": "Executing this example"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Java backend that serves HTML files with a MVC approach, building the templates with the help of  Thymeleaf .  OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  HttpSession  API. In these posts multiple options for user session management in Java are explained, inlcuding the one used in this tutorial:  journaldev.com ,  studytonight.com .    Backend : SpringBoot app with the following classes ( src/main/java  path,  io.openvidu.js.java  package)   App.java  : entrypoint for the app  LoginController.java  : controller for handling login and logout operations  SessionController.java  : controller for getting sessionId's and tokens. It also stores our active video-calls and the users connected to them     Frontend templates : Pure JS/HTML/CSS files served by the backend ( src/main/resources/templates )   index.html  : template with the login form  dashboard.html  : template with the form to join a video-call  session.html  : template of the video-call itself     Frontend static files  ( src/main/resources/static )   OpenVidu.js  : openvidu-browser library. You don't have to manipulate this file  style.css  : some CSS classes to style the templates     Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#1-user-logs-in", 
            "text": "At path  /  a login form will be displayed:  \n     The form will execute a POST operation to path  /dashboard  whenever \"Log in\" button is clicked, passing the username and the password:  form action= /dashboard  method= post \n     p \n         label User /label   input type= text  name= user  required= true /input \n     /p \n     p \n         label Pass /label   input type= password  name= pass  required= true /input \n     /p \n     p \n         button type= submit Log in /button \n     /p  /form   LoginController.java  first checks if the user is already logged (maybe he has just refreshed  /dashboard  page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets an  HttpSession  for the newly logged user (adding a \"loggedUser\" attribute with its username in the HttpSession object). Finally it returns  dashboard.html  template:  @RequestMapping(value =  /dashboard , method = { RequestMethod.GET, RequestMethod.POST })\npublic String login(@RequestParam(name =  user , required = false) String user,\n            @RequestParam(name =  pass , required = false) String pass,\n            Model model, HttpSession httpSession) {\n\n    // Check if the user is already logged in\n    String userName = (String) httpSession.getAttribute( loggedUser );\n    if (userName != null) { \n        // User is already logged. Immediately return dashboard\n        model.addAttribute( username , userName);\n        return  dashboard ;\n    }\n\n    // User wasn't logged and wants to\n    if (login(user, pass)) { // Correct user-pass\n\n        // Validate session and return OK \n        // Value stored in HttpSession allows us to identify the user in future requests\n        httpSession.setAttribute( loggedUser , user);\n        model.addAttribute( username , user);\n\n        // Return dashboard.html template\n        return  dashboard ;\n\n    } else { // Wrong user-pass\n        // Invalidate session and redirect to index.html\n        httpSession.invalidate();\n        return  redirect:/ ;\n    }\n}", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#2-user-connects-to-tutorial-video-call", 
            "text": "dashboard.html  template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:  \n     The form will execute a POST operation to path  /session  whenever \"Join!\" button is clicked, passing the nickname and the session name:  form action= /session  method= post \n     p \n         label Name:  /label   input name= data  required= true /input \n     /p \n     p \n         label Session:  /label   input name= session-name  required= true /input \n     /p \n     p \n         button type= submit Join! /button \n     /p  /form   When  SessionController.java  receives a request at  /session  path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:  // OpenVidu object to ask openvidu-server for sessionId and token\nprivate OpenVidu openVidu;\n\n// Collection to pair session names and OpenVidu Session objects\nprivate Map String, Session  mapSessions = new ConcurrentHashMap ();\n// Collection to pair sessionId's and tokens (the inner Map pairs tokens and role associated)\nprivate Map String, Map String, OpenViduRole  mapSessionIdsTokens = new ConcurrentHashMap ();\n\n// URL where our OpenVidu server is listening\nprivate String OPENVIDU_URL;\n// Secret shared with our OpenVidu server\nprivate String SECRET;  Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on:  tokenOptions .  @RequestMapping(value =  /session , method = RequestMethod.POST)\npublic String joinSession(@RequestParam(name =  data ) String clientData,\n              @RequestParam(name =  session-name ) String sessionName, \n              Model model, HttpSession httpSession) {\n    // Check the user is logged ... \n\n    // Role associated to this user\n    OpenViduRole role = LoginController.users.get(httpSession.getAttribute( loggedUser )).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the HttpSession object on login\n    String serverData =  {\\ serverData\\ : \\  + httpSession.getAttribute( loggedUser ) +  \\ } ;\n\n    // Build tokenOptions object with the serverData and the role\n    TokenOptions tokenOptions = new TokenOptions.Builder().data(serverData).role(role).build();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exitsts?   if (this.mapSessions.get(sessionName) != null) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else {\n    // New session: return a new sessionId and a new token\n    try {\n\n        // Create a new OpenVidu Session\n        Session session = this.openVidu.createSession();\n        // Get the sessionId\n        String sessionId = session.getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = session.generateToken(tokenOptions);\n\n        // Store the session and the token in our collections\n        this.mapSessions.put(sessionName, session);\n        this.mapSessionIdsTokens.put(sessionId, new ConcurrentHashMap ());\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute( sessionId , sessionId);\n        model.addAttribute( token , token);\n        model.addAttribute( nickName , clientData);\n        model.addAttribute( userName , httpSession.getAttribute( loggedUser ));\n        model.addAttribute( sessionName , sessionName);\n\n        // Return session.html template\n        return  session ;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute( username , httpSession.getAttribute( loggedUser ));\n        return  dashboard ;\n    }\n}  We are almost there! Now in  session.html  JavaScript code (preceded by a tag  script th:inline=\"javascript\" ) we can init a new Session with  sessionId  and connect to it with  token :  // Get all the attributes from the template in Thymeleaf style\nvar sessionId = [[${sessionId}]];\nvar token = [[${token}]];\nvar nickName = [[${nickName}]];\nvar userName = [[${userName}]];\nvar sessionName = [[${sessionName}]];\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new  p  element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{ clientData :  ' + nickName + ' }', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher(userName)) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n});   The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  SessionController.java  executes  getSessionIdAndToken()  method. Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (this.mapSessions.get(sessionName) != null) {\n    // Session already exists: return existing sessionId and a new token\n    try {\n\n        // Get the existing sessionId from our collection with \n        // the sessionName param ( TUTORIAL )\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n        // Generate a new token with the recently created tokenOptions\n        String token = this.mapSessions.get(sessionName).generateToken(tokenOptions);\n\n        // Update our collection storing the new token\n        this.mapSessionIdsTokens.get(sessionId).put(token, role);\n\n        // Add all the needed attributes to the template\n        model.addAttribute( sessionId , sessionId);\n        model.addAttribute( token , token);\n        model.addAttribute( nickName , clientData);\n        model.addAttribute( userName , httpSession.getAttribute( loggedUser ));\n        model.addAttribute( sessionName , sessionName);\n\n        // Return session.html template\n        return  session ;\n\n    } catch (Exception e) {\n        // If error just return dashboard.html template\n        model.addAttribute( username , httpSession.getAttribute( loggedUser ));\n        return  dashboard ;\n    }\n}  The code executed in  session.html    script   tag would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-java/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  session.disconnect()  (triggered in  leaveSession()   onclick  method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.  In  session.html  template the \"Leave session\" button actually performs a POST operation to path  /leave-session  with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the  leaveSession()  method. First updates our backend. Second updates our openvidu-server.  form action= /leave-session  method= post \n     input type= hidden  name= session-name  th:value= ${sessionName} /input \n     input type= hidden  name= token  th:value= ${token} /input \n     button type= submit  onclick= leaveSession() Leave session /button  /form   In  SessionController.java  we update the collections:  @RequestMapping(value =  /leave-session , method = RequestMethod.POST)\npublic String removeUser(@RequestParam(name =  session-name ) String sessionName,\n             @RequestParam(name =  token ) String token,\n             Model model, HttpSession httpSession) throws Exception {\n    // Check the user is logged ... \n\n    // If the session exists ( TUTORIAL  in this case)\n    if (this.mapSessions.get(sessionName) != null) {\n        String sessionId = this.mapSessions.get(sessionName).getSessionId();\n\n        if (this.mapSessionIdsTokens.containsKey(sessionId)) {\n            // If the token exists\n            if (this.mapSessionIdsTokens.get(sessionId).remove(token) != null) {\n                // Token has been removed\n                if (this.mapSessionIdsTokens.get(sessionId).isEmpty()) {\n                    // Last user left: session  TUTORIAL  must be removed\n                    this.mapSessions.remove(sessionName);\n                }\n                model.addAttribute( sessionId , sessionId);\n                return  redirect:/dashboard ;\n            } else {\n                // The TOKEN wasn't valid\n                model.addAttribute( sessionId , sessionId);\n                return  redirect:/dashboard ;\n            }\n        } else {\n            // The SESSIONID wasn't valid\n            model.addAttribute( sessionId , sessionId);\n            return  redirect:/dashboard ;\n        }\n    } else {\n        // The SESSION does not exist\n        model.addAttribute( sessionId , sessionId);\n        return  redirect:/dashboard ;\n    }\n}  When the last user leaves the session  this.mapSessions.remove(sessionName);  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.", 
            "title": "4) Users leave the video-call**"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/", 
            "text": "openvidu-js-node\n\n\nA secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of the \nopenvidu-node-client\n to get the necessary params from OpenVidu Server.\n\n\nUnderstanding this example\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-node-client\n: NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-node-client\n to get this sample app working\n\n\n\n\nExecuting this example\n\n\n\n\n\n\nClone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n\n\nYou will need \nnode\n and \nNPM\n to execute the app. You can install them with:\n\n\nsudo apt-get install nodejs\nsudo apt-get install npm\n\n\n\n\n\n\nTo run the sample application, execute the following commands in the project. They will install the NPM dependencies and will execute \nserver.js\n server passing two arguments: \"localhost:8443\" as the URL where \nopenvidu-server\n will be listening and \"MY_SECRET\" as the secret share with it:\n\n\ncd openvidu-js-node\nnpm install\nnode server.js localhost:8443 MY_SECRET\n\n\n\n\n\n\nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n\n\nGo to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Node backend with \nexpress\n. OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nexpress-session\n API.\n\n\n\n\n\n\nBackend\n: node server\n\n\n\n\nserver.js\n : single file which handles all operations of server.\n\n\n\n\n\n\n\n\nFrontend\n: Pure JS/HTML/CSS files (\n/public\n folder)\n\n\n\n\nOpenVidu.js\n : openvidu-browser library. You don't have to manipulate this file. \n\n\napp.js\n : sample application main JavaScritp file, which makes use of \nOpenVidu.js\n.\n\n\n\n\nindex.html\n : HTML code for the form to login, the form to connect to a video-call and for the video-call itself.\n    It has two links to both JavaScript files: \n    \nhtml\n    \nscript src=\"OpenVidu.js\"\n/script\n\n    \nscript src=\"app.js\"\n/script\n\n\n\n\n\n\nstyle.css\n: some CSS classes to style \nindex.html\n.\n\n\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nWe have implemented a method for making HTTP requests to the backend, as we will need to    make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:\n\n\nfunction httpRequest(method, url, body, errorMsg, callback)\n\n\n\n\nWhere \nmethod\n is whether \"POST\" or \"GET\", \nurl\n the path of the REST operation, \nbody\n the data to be passed, \nerrorMsg\n the output error message if something goes wrong and \ncallback\n the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.\n\n\nindex.html\n will first show a form to log in:\n\n\n\n  \n\n\n\n\n\napp.js\n sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:\n\n\nfunction logIn() {\n    var user = $(\n#user\n).val(); // Username\n    var pass = $(\n#pass\n).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        console.warn(userName + ' login');\n        // HTML shows logged-in page ...\n    });\n}\n\n\n\n\nserver.js\n at \n/api-login/login\n checks the params are correct and if so sets an active session for the newly logged user (adding a \nloggedUser\n property with its username in the \nreq.session\n object):\n\n\napp.post('/api-login/login', function (req, res) {\n\n    // Retrieve params from POST body\n    var user = req.body.user;\n    var pass = req.body.pass;\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in req.session allows us to identify the user in future requests\n        req.session.loggedUser = user;\n        res.status(200).send();\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        req.session.destroy();\n        res.status(401).send('User/Pass incorrect');\n    }\n});\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\nHTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:\n\n\n\n  \n\n\n\n\n\napp.js\n will execute \njoinSession()\n method, which starts like this:\n\n\nfunction joinSession() {\n    getSessionIdAndToken(function () { ...\n\n\n\n\nSo the first thing to do here is to retrieve a \nsessionId\n and a \ntoken\n from our backend. Only when we have them available in the browser we will continue with the \njoin\n operation. Let's see what \ngetSessionIdAndToken()\n looks like:\n\n\nfunction getSessionIdAndToken(callback) {\n    sessionName = $(\n#sessionName\n).val(); // Video-call to connect (\nTUTORIAL\n)\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}\n\n\n\n\nHere is the second time we must call our \nhttpRequest()\n method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a \nsessionId\n and a \ntoken\n as response. The interesting part here is in \nserver.js\n controller at \n/api-sessions/get-sessionid-token\n. First of all there are some important attributes in this class we must mention:\n\n\n// Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};\n\n\n\n\nRest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on: \ntokenOptions\n.\n\n\napp.post('/api-sessions/get-sessionid-token', function (req, res) {\n    // Check the user is logged ... \n\n    // The video-call to connect (\nTUTORIAL\n)\n    var sessionName = req.body.session;\n\n    // Role associated to this user\n    var role = users.find(u =\n (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = '{\nserverData\n: \n' + req.session.loggedUser + '\n}';\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = new TokenOptions.Builder()\n           .data(serverData)\n           .role(role)\n           .build();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exitsts? \n\n\nif (mapSessionNameSession[sessionName]) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse { // New session: return a new sessionId and a new token\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return the sessionId and token to the client\n            res.status(200).send({\n                0: sessionId,\n                1: token\n            });\n        });\n    });\n}\n\n\n\n\nWe are almost there! Now in \napp.js\n we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new \np\n element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{\nclientData\n: \n' + $(\n#participantName\n).val() + '\n}', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n\n    // HTML shows session page ...\n\n});\n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nserver.js\n executes controller at \n/api-sessions/get-sessionid-token\n. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        var sessionId = mySession.getSessionId();\n\n        // Store the new token in the collection of tokens\n        mapSessionIdTokens[sessionId].push(token);\n\n        // Return the sessionId and token to the client\n        res.status(200).send({\n            0: sessionId,\n            1: token\n        });\n    });\n}\n\n\n\n\nThe code executed in \napp.js\n would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nleaveSession()\n (and therefore \nsession.disconnect()\n) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up, \nsession.disconnect()\n updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in \napp.js\n we run:\n\n\nfunction removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}\n\n\n\n\nAnd in \nserver.js\n we update the collections in \n/api-sessions/remove-user\n:\n\n\napp.post('/api-sessions/remove-user', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionName;\n    var token = req.body.token;\n\n    // If the session exists (\nTUTORIAL\n in this case)\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        var tokens = mapSessionIdTokens[mySession.getSessionId()];\n        if (tokens) {\n            var index = tokens.indexOf(token);\n\n            // If the token exists\n            if (index !== -1) {\n                // Token removed!\n                tokens.splice(index, 1);\n            } else {\n                res.status(500).send('The TOKEN wasn\\'t valid');\n            }\n            if (mapSessionIdTokens[mySession.getSessionId()].length == 0) {\n                // Last user left: session \nTUTORIAL\n must be removed\n                delete mapSessionNameSession[sessionName];\n            }\n            res.status(200).send();\n        } else {\n            res.status(500).send('The SESSIONID wasn\\'t valid');\n        }\n    } else {\n        res.status(500).send('The SESSION does not exist');\n    }\n}\n\n\n\n\nWhen the last user leaves the session \ndelete mapSessionNameSession[sessionName]\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.", 
            "title": "openvidu-js-node"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#openvidu-js-node", 
            "text": "A secure OpenVidu sample app with a Node backend and a SPA frontend. It makes use of the  openvidu-node-client  to get the necessary params from OpenVidu Server.", 
            "title": "openvidu-js-node"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#understanding-this-example", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-node-client : NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-node-client  to get this sample app working", 
            "title": "Understanding this example"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#executing-this-example", 
            "text": "Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git    You will need  node  and  NPM  to execute the app. You can install them with:  sudo apt-get install nodejs\nsudo apt-get install npm    To run the sample application, execute the following commands in the project. They will install the NPM dependencies and will execute  server.js  server passing two arguments: \"localhost:8443\" as the URL where  openvidu-server  will be listening and \"MY_SECRET\" as the secret share with it:  cd openvidu-js-node\nnpm install\nnode server.js localhost:8443 MY_SECRET    openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms    Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.", 
            "title": "Executing this example"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Node backend with  express . OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  express-session  API.    Backend : node server   server.js  : single file which handles all operations of server.     Frontend : Pure JS/HTML/CSS files ( /public  folder)   OpenVidu.js  : openvidu-browser library. You don't have to manipulate this file.   app.js  : sample application main JavaScritp file, which makes use of  OpenVidu.js .   index.html  : HTML code for the form to login, the form to connect to a video-call and for the video-call itself.\n    It has two links to both JavaScript files: \n     html\n     script src=\"OpenVidu.js\" /script \n     script src=\"app.js\" /script    style.css : some CSS classes to style  index.html .      Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#1-user-logs-in", 
            "text": "We have implemented a method for making HTTP requests to the backend, as we will need to    make at least three of them: one for logging in, one for getting the sessionId and a valid token from openvidu-server and one for letting know our backend when any user leaves the video-call. The header of the method looks like this:  function httpRequest(method, url, body, errorMsg, callback)  Where  method  is whether \"POST\" or \"GET\",  url  the path of the REST operation,  body  the data to be passed,  errorMsg  the output error message if something goes wrong and  callback  the function to execute in case of success. As mentioned above, we need to call this method three times for each user that LOGS IN \ud83e\udc52 CONNECTS TO A VIDEO-CALL \ud83e\udc52 LEAVES THE VIDEO-CALL.  index.html  will first show a form to log in:  \n     app.js  sends an HTTP request to \"/api-login/login\" passing the username and the password retrieved from the HTML form whenever \"Log in\" button is clicked:  function logIn() {\n    var user = $( #user ).val(); // Username\n    var pass = $( #pass ).val(); // Password\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'user': user,\n        'pass': pass\n    });\n\n    httpRequest('POST', '/api-login/login', jsonBody, 'Login WRONG',\n      function successCallback(response){ // Send POST request\n        console.warn(userName + ' login');\n        // HTML shows logged-in page ...\n    });\n}  server.js  at  /api-login/login  checks the params are correct and if so sets an active session for the newly logged user (adding a  loggedUser  property with its username in the  req.session  object):  app.post('/api-login/login', function (req, res) {\n\n    // Retrieve params from POST body\n    var user = req.body.user;\n    var pass = req.body.pass;\n\n    if (login(user, pass)) { // Correct user-pass\n        // Validate session and return OK \n        // Value stored in req.session allows us to identify the user in future requests\n        req.session.loggedUser = user;\n        res.status(200).send();\n    } else { // Wrong user-pass\n        // Invalidate session and return error\n        req.session.destroy();\n        res.status(401).send('User/Pass incorrect');\n    }\n});", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#2-user-connects-to-tutorial-video-call", 
            "text": "HTML will display now the user has logged a different form, asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field and press \"Join!\" button:  \n     app.js  will execute  joinSession()  method, which starts like this:  function joinSession() {\n    getSessionIdAndToken(function () { ...  So the first thing to do here is to retrieve a  sessionId  and a  token  from our backend. Only when we have them available in the browser we will continue with the  join  operation. Let's see what  getSessionIdAndToken()  looks like:  function getSessionIdAndToken(callback) {\n    sessionName = $( #sessionName ).val(); // Video-call to connect ( TUTORIAL )\n    var jsonBody = JSON.stringify({ // Body of POST request\n        'session': sessionName\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/get-sessionid-token', jsonBody, \n     'Request of SESSIONID and TOKEN gone WRONG:', function successCallback(response){\n        sessionId = response[0]; // Get sessionId from response\n        token = response[1]; // Get token from response\n        callback(); // Continue the join operation\n    });\n}  Here is the second time we must call our  httpRequest()  method, sending the session we want to connect (\"TUTORIAL\") and waiting to get a  sessionId  and a  token  as response. The interesting part here is in  server.js  controller at  /api-sessions/get-sessionid-token . First of all there are some important attributes in this class we must mention:  // Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};  Rest controller method begins retrieving the param send by the client, which in this case is the video-call name (\"TUTORIAL\"), as well as preparing a param we will need a little further on:  tokenOptions .  app.post('/api-sessions/get-sessionid-token', function (req, res) {\n    // Check the user is logged ... \n\n    // The video-call to connect ( TUTORIAL )\n    var sessionName = req.body.session;\n\n    // Role associated to this user\n    var role = users.find(u =  (u.user === req.session.loggedUser)).role;\n\n    // Optional data to be passed to other users when this user connects to the video-call\n    // In this case, a JSON with the value we stored in the req.session object on login\n    var serverData = '{ serverData :  ' + req.session.loggedUser + ' }';\n\n    // Build tokenOptions object with the serverData and the role\n    var tokenOptions = new TokenOptions.Builder()\n           .data(serverData)\n           .role(role)\n           .build();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exitsts?   if (mapSessionNameSession[sessionName]) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else { // New session: return a new sessionId and a new token\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return the sessionId and token to the client\n            res.status(200).send({\n                0: sessionId,\n                1: token\n            });\n        });\n    });\n}  We are almost there! Now in  app.js  we can init a new Session with  sessionId  and connect to it with  token :  // --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nOV = new OpenVidu();\nsession = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new  p  element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{ clientData :  ' + $( #participantName ).val() + ' }', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher()) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n\n    // HTML shows session page ...\n\n});  The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  server.js  executes controller at  /api-sessions/get-sessionid-token . Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        var sessionId = mySession.getSessionId();\n\n        // Store the new token in the collection of tokens\n        mapSessionIdTokens[sessionId].push(token);\n\n        // Return the sessionId and token to the client\n        res.status(200).send({\n            0: sessionId,\n            1: token\n        });\n    });\n}  The code executed in  app.js  would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-js-node/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  leaveSession()  (and therefore  session.disconnect() ) to destroy the connection on openvidu-server, we need to run the last HTTP operation: we must let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens. To sum up,  session.disconnect()  updates our openvidu-server and the POST operation updates our backend.\nFor the POST operation, in  app.js  we run:  function removeUser() {\n    // Body of POST request with the name of the session and the token of the leaving user\n    var jsonBody = JSON.stringify({\n        'sessionName': sessionName,\n        'token': token\n    });\n\n    // Send POST request\n    httpRequest('POST', '/api-sessions/remove-user', jsonBody,\n        'User couldn\\'t be removed from session', function successCallback(response) {\n        console.warn(userName + ' correctly removed from session ' + sessionName);\n    });\n}  And in  server.js  we update the collections in  /api-sessions/remove-user :  app.post('/api-sessions/remove-user', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionName;\n    var token = req.body.token;\n\n    // If the session exists ( TUTORIAL  in this case)\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        var tokens = mapSessionIdTokens[mySession.getSessionId()];\n        if (tokens) {\n            var index = tokens.indexOf(token);\n\n            // If the token exists\n            if (index !== -1) {\n                // Token removed!\n                tokens.splice(index, 1);\n            } else {\n                res.status(500).send('The TOKEN wasn\\'t valid');\n            }\n            if (mapSessionIdTokens[mySession.getSessionId()].length == 0) {\n                // Last user left: session  TUTORIAL  must be removed\n                delete mapSessionNameSession[sessionName];\n            }\n            res.status(200).send();\n        } else {\n            res.status(500).send('The SESSIONID wasn\\'t valid');\n        }\n    } else {\n        res.status(500).send('The SESSION does not exist');\n    }\n}  When the last user leaves the session  delete mapSessionNameSession[sessionName]  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/", 
            "text": "openvidu-mvc-node\n\n\nA secure OpenVidu sample app with a Node backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to \nopenvidu-js-node\n. This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends. \nEmbedded JavaScript\n is the template engine of choice for this tutorial.\n\n\nUnderstanding this example\n\n\n\n  \n\n\n\n\n\nOpenVidu is composed by the modules displayed on the image above.\n\n\n\n\nopenvidu-browser\n: JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients\n\n\nopenvidu-node-client\n: NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API\n\n\nopenvidu-server\n: Java application that controls Kurento Media Server\n\n\nKurento Media Server\n: server that handles low level operations of media flow transmissions\n\n\n\n\n\n\nYou will only have to make use of \nopenvidu-browser\n and \nopenvidu-node-client\n to get this sample app working\n\n\n\n\nExecuting this example\n\n\n\n\n\n\nClone the repo:\n\n\ngit clone https://github.com/OpenVidu/openvidu-tutorials.git\n\n\n\n\n\n\nYou will need \nnode\n and \nNPM\n to execute the app. You can install them with:\n\n\nsudo apt-get install nodejs\nsudo apt-get install npm\n\n\n\n\n\n\nTo run the sample application, execute the following commands in the project. They will install the NPM dependencies and will execute \nserver.js\n server passing two arguments: \"localhost:8443\" as the URL where \nopenvidu-server\n will be listening and \"MY_SECRET\" as the secret share with it:\n\n\ncd openvidu-mvc-node\nnpm install\nnode server.js localhost:8443 MY_SECRET\n\n\n\n\n\n\nopenvidu-server\n and \nKurento Media Server\n must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need \nDocker CE\n):\n\n\ndocker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms\n\n\n\n\n\n\nGo to \nhttps://localhost:5000\n to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of \nopenvidu-server\n when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.\n\n\n\n\n\n\nUnderstanding the code\n\n\nThis is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Node backend built with \nexpress\n that serves HTML files with a MVC approach, building the templates with the help of \nEmbedded JavaScript\n.\n\n\nOpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive \nexpress-session\n API.\n\n\n\n\n\n\nBackend\n: node server\n\n\n\n\nserver.js\n : single file which handles all operations of server. It returns HTML templates as response to HTTP requests.\n\n\n\n\n\n\n\n\nFrontend templates\n: Pure JS/HTML/CSS files served by the backend, with \n.ejs\n extension to support Embedded JavaScript (\n/views\n folder)\n\n\n\n\nindex.ejs\n : template with the login form\n\n\ndashboard.ejs\n : template with the form to join a video-call\n\n\nsession.ejs\n : template of the video-call itself\n\n\n\n\n\n\n\n\nFrontend static files\n (\n/public\n folder)\n\n\n\n\nOpenVidu.js\n : openvidu-browser library. You don't have to manipulate this file\n\n\nstyle.css\n : some CSS classes to style the templates\n\n\n\n\n\n\n\n\nLet's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.\n\n\n\n\n1) User logs in\n\n\nAt path \n/\n a login form will be displayed:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/dashboard\n whenever \"Log in\" button is clicked, passing the username and the password:\n\n\nform action=\n/dashboard\n method=\npost\n\n    \np\n\n        \nlabel\nUser\n/label\n \ninput type=\ntext\n name=\nuser\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nPass\n/label\n \ninput type=\npassword\n name=\npass\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nbutton type=\nsubmit\nLog in\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nserver.js\n at \n/dashboard\n first checks if the user is already logged (maybe he has just refreshed \n/dashboard\n page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new \nexpress-session\n for the newly logged user (adding a \nloggedUser\n property with its username in the \nreq.session\n object). Finally it returns \ndashboard.ejs\n template:\n\n\napp.post('/dashboard', dashboardController);\napp.get('/dashboard', dashboardController);\n\nfunction dashboardController(req, res) {\n\n    // Check if the user is already logged in\n    if (isLogged(req.session)) {\n        // User is already logged. Immediately return dashboard\n        user = req.session.loggedUser;\n        res.render('dashboard.ejs', {\n            user: user\n        });\n    } else {\n        // User wasn't logged and wants to\n\n        // Retrieve params from POST body\n        var user = req.body.user;\n        var pass = req.body.pass;\n\n        if (login(user, pass)) { // Correct user-pass\n            // Validate session and return OK \n            // Value stored in req.session allows us to identify the user in future requests\n            req.session.loggedUser = user;\n            res.render('dashboard.ejs', {\n                user: user\n            });\n        } else { // Wrong user-pass\n            // Invalidate session and return index template\n            req.session.destroy();\n            res.redirect('/');\n        }\n    }\n}\n\n\n\n\n\n\n2) User connects to \"TUTORIAL\" video-call\n\n\ndashboard.html\n template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:\n\n\n\n  \n\n\n\n\n\nThe form will execute a POST operation to path \n/session\n whenever \"Join!\" button is clicked, passing the nickname and the session name:\n\n\nform action=\n/session\n method=\npost\n\n    \np\n\n        \nlabel\nName: \n/label\n \ninput name=\ndata\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nlabel\nSession: \n/label\n \ninput name=\nsessionname\n required=\ntrue\n/input\n\n    \n/p\n\n    \np\n\n        \nbutton type=\nsubmit\nJoin!\n/button\n\n    \n/p\n\n\n/form\n\n\n\n\n\nWhen \nserver.js\n receives a request at \n/session\n path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:\n\n\n// Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};\n\n\n\n\nRest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on: \ntokenOptions\n.\n\n\napp.post('/session', (req, res) =\n {\n// Check the user is logged ... \n\n// The nickname sent by the client\nvar clientData = req.body.data;\n// The video-call to connect (\nTUTORIAL\n)\nvar sessionName = req.body.sessionname;\n\n// Role associated to this user\nvar role = users.find(u =\n (u.user === req.session.loggedUser)).role;\n\n// Optional data to be passed to other users when this user connects to the video-call\n// In this case, a JSON with the value we stored in the req.session object on login\nvar serverData = '{\nserverData\n: \n' + req.session.loggedUser + '\n}';\n\n// Build tokenOptions object with the serverData and the role\nvar tokenOptions = new TokenOptions.Builder()\n    .data(serverData)\n    .role(role)\n    .build();\n\n\n\n\nJust after that an \nif-else\n statement comes into play: does the session \"TUTORIAL\" already exitsts? \n\n\nif (mapSessionNameSession[sessionName]) { ...\n\n\n\n\nIn this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the \nelse\n branch:\n\n\nelse { // New session: return a new sessionId and a new token\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: sessionId,\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        });\n    });\n}\n\n\n\n\nWe are almost there! Now in \nsession.html\n JavaScript code (preceded by a tag \nscript\n) we can init a new Session with \nsessionId\n and connect to it with \ntoken\n:\n\n\n// Get all the attributes from the template in EJS style\nvar sessionId = \n%- JSON.stringify(sessionId) %\n;\nvar token = \n%- JSON.stringify(token) %\n;\nvar nickName = \n%- JSON.stringify(nickName) %\n;\nvar userName = \n%- JSON.stringify(userName) %\n;\nvar sessionName = \n%- JSON.stringify(sessionName) %\n;\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new \np\n element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{\nclientData\n: \n' + nickName + '\n}', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher(userName)) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n}); \n\n\n\n\nThe user will now see its own video on the page. The connection to the session has completed!\n\n\n\n\n3) Another user connects to the video-call\n\n\nThe process would be exactly the same as before until \nserver.js\n executes controller at \n/api-sessions/get-sessionid-token\n. Now session 'TUTORIAL' already exists, so in the \nif-else\n statement the \nif\n branch would be the one executed:\n\n\nif (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        var sessionId = mySession.getSessionId();\n\n        // Store the new token in the collection of tokens\n        mapSessionIdTokens[sessionId].push(token);\n\n        // Return session template with all the needed attributes\n        res.render('session.ejs', {\n            sessionId: sessionId,\n            token: token,\n            nickName: clientData,\n            userName: req.session.loggedUser,\n            sessionName: sessionName\n        });\n    });\n}\n\n\n\n\nThe code executed in \nsession.html\n \n script \n tag would also be the same. After the \nSession.publish()\n method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.\n\n\n\n\n4) Users leave the video-call\n\n\nAfter a while both users decide to leave the session. Apart from calling \nsession.disconnect()\n (triggered in \nleaveSession()\n \nonclick\n method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.\n\n\nIn \nsession.html\n template the \"Leave session\" button actually performs a POST operation to path \n/leave-session\n with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the \nleaveSession()\n method. First updates our backend. Second updates our openvidu-server.\n\n\nform action=\n/leave-session\n method=\npost\n\n    \ninput type=\nhidden\n name=\nsession-name\n th:value=\n${sessionName}\n/input\n\n    \ninput type=\nhidden\n name=\ntoken\n th:value=\n${token}\n/input\n\n    \nbutton type=\nsubmit\n onclick=\nleaveSession()\nLeave session\n/button\n\n\n/form\n\n\n\n\n\nIn \nserver.js\n we update the collections at \n/leave-session\n:\n\n\napp.post('/leave-session', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionname;\n    var token = req.body.token;\n\n    // If the session exists (\nTUTORIAL\n in this case)\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        var tokens = mapSessionIdTokens[mySession.getSessionId()];\n        if (tokens) {\n            var index = tokens.indexOf(token);\n\n            // If the token exists\n            if (index !== -1) {\n                // Token removed!\n                tokens.splice(index, 1);\n            } else {\n                res.status(500).send('The TOKEN wasn\\'t valid');\n            }\n            if (mapSessionIdTokens[mySession.getSessionId()].length == 0) {\n                // Last user left: session \nTUTORIAL\n must be removed\n                delete mapSessionNameSession[sessionName];\n            }\n            res.redirect('/dashboard');\n        } else {\n            res.status(500).send('The SESSIONID wasn\\'t valid');\n        }\n    } else {\n        res.status(500).send('The SESSION does not exist');\n    }\n}\n\n\n\n\nWhen the last user leaves the session \ndelete mapSessionNameSession[sessionName]\n will be executed: this means the session is empty and that it is going to be closed. The \nsessionId\n and all \ntoken\n params associated to it will be invalidated.\n\n\n\n\n\n\nAt this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches: \nyou can implement your frontend and your backend as you want\n. \n\n\nThe only actual requirements are getting \nsessionId\n and \ntoken\n params from  \nopenvidu-server\n (by using one of the available clients or with the REST API) and using them along with \nopenvidu-browser\n to connect your clients to the sessions.", 
            "title": "openvidu-mvc-node"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#openvidu-mvc-node", 
            "text": "A secure OpenVidu sample app with a Node backend and a traditional MVC frontend. With regard to the use of OpenVidu, it is identical to  openvidu-js-node . This tutorial is intended for developers who feel more comfortable with MVC web architectures for their frontends.  Embedded JavaScript  is the template engine of choice for this tutorial.", 
            "title": "openvidu-mvc-node"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#understanding-this-example", 
            "text": "OpenVidu is composed by the modules displayed on the image above.   openvidu-browser : JavaScript library for the browser. It allows you to manage your video-calls straight away from your clients  openvidu-node-client : NPM package to easily get the necessary params (sessionId's and tokens) from openvidu-server. Quick alternative to REST API  openvidu-server : Java application that controls Kurento Media Server  Kurento Media Server : server that handles low level operations of media flow transmissions    You will only have to make use of  openvidu-browser  and  openvidu-node-client  to get this sample app working", 
            "title": "Understanding this example"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#executing-this-example", 
            "text": "Clone the repo:  git clone https://github.com/OpenVidu/openvidu-tutorials.git    You will need  node  and  NPM  to execute the app. You can install them with:  sudo apt-get install nodejs\nsudo apt-get install npm    To run the sample application, execute the following commands in the project. They will install the NPM dependencies and will execute  server.js  server passing two arguments: \"localhost:8443\" as the URL where  openvidu-server  will be listening and \"MY_SECRET\" as the secret share with it:  cd openvidu-mvc-node\nnpm install\nnode server.js localhost:8443 MY_SECRET    openvidu-server  and  Kurento Media Server  must be up and running in your development machine. The easiest way is running this Docker container which wraps both of them (you will need  Docker CE ):  docker run -p 8443:8443 --rm -e KMS_STUN_IP=193.147.51.12 -e KMS_STUN_PORT=3478 -e openvidu.secret=MY_SECRET openvidu/openvidu-server-kms    Go to  https://localhost:5000  to test the app once the server is running. The first time you use the docker container, an alert message will suggest you accept the self-signed certificate of  openvidu-server  when you first try to join a video-call. To test two users in the same computer, use a standard window and an incognito window.", 
            "title": "Executing this example"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#understanding-the-code", 
            "text": "This is a very basic web application with a pretty simple vanilla JS/HTML/CSS frontend and a straightforward Node backend built with  express  that serves HTML files with a MVC approach, building the templates with the help of  Embedded JavaScript .  OpenVidu assumes you can identify your users so you can tell which users can connect to which video-calls, and what role (and therefore what permissions) each one of them will have in the calls. You can do this as you prefer. Here our backend will manage the users and their sessions with the easy-to-use and non-intrusive  express-session  API.    Backend : node server   server.js  : single file which handles all operations of server. It returns HTML templates as response to HTTP requests.     Frontend templates : Pure JS/HTML/CSS files served by the backend, with  .ejs  extension to support Embedded JavaScript ( /views  folder)   index.ejs  : template with the login form  dashboard.ejs  : template with the form to join a video-call  session.ejs  : template of the video-call itself     Frontend static files  ( /public  folder)   OpenVidu.js  : openvidu-browser library. You don't have to manipulate this file  style.css  : some CSS classes to style the templates     Let's describe the code following this scenario: a user logs in to the app and connects to the video-call \"TUTORIAL\", where he publishes his webcam. A second user will connect to the same video-call just after that and publish its own webcam. Both of them will leave the call after a while.", 
            "title": "Understanding the code"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#1-user-logs-in", 
            "text": "At path  /  a login form will be displayed:  \n     The form will execute a POST operation to path  /dashboard  whenever \"Log in\" button is clicked, passing the username and the password:  form action= /dashboard  method= post \n     p \n         label User /label   input type= text  name= user  required= true /input \n     /p \n     p \n         label Pass /label   input type= password  name= pass  required= true /input \n     /p \n     p \n         button type= submit Log in /button \n     /p  /form   server.js  at  /dashboard  first checks if the user is already logged (maybe he has just refreshed  /dashboard  page), and if so it just redirects to the dashboard itself. If the user is actually logging in, the method checks that the params are correct and if so sets a new  express-session  for the newly logged user (adding a  loggedUser  property with its username in the  req.session  object). Finally it returns  dashboard.ejs  template:  app.post('/dashboard', dashboardController);\napp.get('/dashboard', dashboardController);\n\nfunction dashboardController(req, res) {\n\n    // Check if the user is already logged in\n    if (isLogged(req.session)) {\n        // User is already logged. Immediately return dashboard\n        user = req.session.loggedUser;\n        res.render('dashboard.ejs', {\n            user: user\n        });\n    } else {\n        // User wasn't logged and wants to\n\n        // Retrieve params from POST body\n        var user = req.body.user;\n        var pass = req.body.pass;\n\n        if (login(user, pass)) { // Correct user-pass\n            // Validate session and return OK \n            // Value stored in req.session allows us to identify the user in future requests\n            req.session.loggedUser = user;\n            res.render('dashboard.ejs', {\n                user: user\n            });\n        } else { // Wrong user-pass\n            // Invalidate session and return index template\n            req.session.destroy();\n            res.redirect('/');\n        }\n    }\n}", 
            "title": "1) User logs in"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#2-user-connects-to-tutorial-video-call", 
            "text": "dashboard.html  template will display a form asking for the video-call to connect and the nickname the user wants to have in it. So our 'publisher1' user would write TUTORIAL in \"Session\" field:  \n     The form will execute a POST operation to path  /session  whenever \"Join!\" button is clicked, passing the nickname and the session name:  form action= /session  method= post \n     p \n         label Name:  /label   input name= data  required= true /input \n     /p \n     p \n         label Session:  /label   input name= sessionname  required= true /input \n     /p \n     p \n         button type= submit Join! /button \n     /p  /form   When  server.js  receives a request at  /session  path is when things get interesting.\nFirst of all there are some important attributes in this class we must mention:  // Environment variable: URL where our OpenVidu server is listening\nvar OPENVIDU_URL = process.argv[2];\n// Environment variable: secret shared with our OpenVidu server\nvar OPENVIDU_SECRET = process.argv[3];\n\n// OpenVidu object to ask openvidu-server for sessionId and token\nvar OV = new OpenVidu(OPENVIDU_URL, OPENVIDU_SECRET);\n\n// Collection to pair session names and OpenVidu Session objects\nvar mapSessionNameSession = {};\n// Collection to pair sessionId's (identifiers of Session objects) and tokens\nvar mapSessionIdTokens = {};  Rest controller method receives both params sent by the client (whatever nickname the user has chosen and \"TUTORIAL\" as the sessionName). First it prepares a param we will need a little further on:  tokenOptions .  app.post('/session', (req, res) =  {\n// Check the user is logged ... \n\n// The nickname sent by the client\nvar clientData = req.body.data;\n// The video-call to connect ( TUTORIAL )\nvar sessionName = req.body.sessionname;\n\n// Role associated to this user\nvar role = users.find(u =  (u.user === req.session.loggedUser)).role;\n\n// Optional data to be passed to other users when this user connects to the video-call\n// In this case, a JSON with the value we stored in the req.session object on login\nvar serverData = '{ serverData :  ' + req.session.loggedUser + ' }';\n\n// Build tokenOptions object with the serverData and the role\nvar tokenOptions = new TokenOptions.Builder()\n    .data(serverData)\n    .role(role)\n    .build();  Just after that an  if-else  statement comes into play: does the session \"TUTORIAL\" already exitsts?   if (mapSessionNameSession[sessionName]) { ...  In this case it doesn't because 'publisher1' is the first user connecting to it. So we focus on the  else  branch:  else { // New session: return a new sessionId and a new token\n    // Create a new OpenVidu Session\n    var mySession = OV.createSession();\n\n    // Get the sessionId asynchronously\n    mySession.getSessionId(function (sessionId) {\n\n        // Store the new Session in the collection of Sessions\n        mapSessionNameSession[sessionName] = mySession;\n        // Store a new empty array in the collection of tokens\n        mapSessionIdTokens[sessionId] = [];\n\n        // Generate a new token asynchronously with the recently created tokenOptions\n        mySession.generateToken(tokenOptions, function (token) {\n\n            // Store the new token in the collection of tokens\n            mapSessionIdTokens[sessionId].push(token);\n\n            // Return session template with all the needed attributes\n            res.render('session.ejs', {\n                sessionId: sessionId,\n                token: token,\n                nickName: clientData,\n                userName: req.session.loggedUser,\n                sessionName: sessionName\n            });\n        });\n    });\n}  We are almost there! Now in  session.html  JavaScript code (preceded by a tag  script ) we can init a new Session with  sessionId  and connect to it with  token :  // Get all the attributes from the template in EJS style\nvar sessionId =  %- JSON.stringify(sessionId) % ;\nvar token =  %- JSON.stringify(token) % ;\nvar nickName =  %- JSON.stringify(nickName) % ;\nvar userName =  %- JSON.stringify(userName) % ;\nvar sessionName =  %- JSON.stringify(sessionName) % ;\n\n// --- 1) Get an OpenVidu object and init a session with the retrieved sessionId ---\n\nvar OV = new OpenVidu();\nvar session = OV.initSession(sessionId);\n\n\n// --- 2) Specify the actions when events take place ---\n\n// On every new Stream received...\nsession.on('streamCreated', function (event) {\n\n    // Subscribe to the Stream to receive it\n    // HTML video will be appended to element with 'subscriber' id\n    var subscriber = session.subscribe(event.stream, 'subscriber');\n\n    // When the HTML video has been appended to DOM...\n    subscriber.on('videoElementCreated', function (event) {\n\n        // Add a new  p  element for the user's name and nickname just below its video\n        appendUserData(event.element, subscriber.stream.connection);\n    });\n});\n\n// On every Stream destroyed...\nsession.on('streamDestroyed', function (event) {\n    // Delete the HTML element with the user's name and nickname\n    removeUserData(event.stream.connection);\n});\n\n\n// --- 3) Connect to the session passing the retrieved token and some more data from\n//         the client (in this case a JSON with the nickname chosen by the user) ---\n\nsession.connect(token, '{ clientData :  ' + nickName + ' }', function (err) {\n\n    // If the connection is successful, initialize a publisher and publish to the session\n    if (!err) {\n\n        // Here we check somehow if the user has at least 'PUBLISHER' role before\n        // trying to publish its stream. Even if someone modified the client's code and\n        // published the stream, it wouldn't work if the token sent in Session.connect\n        // method doesn't belong to a 'PUBLIHSER' role\n        if (isPublisher(userName)) {\n\n            // --- 4) Get your own camera stream ---\n\n            var publisher = OV.initPublisher('publisher', {\n                audio: true,\n                video: true,\n                quality: 'MEDIUM'\n            });\n\n            // --- 5) Publish your stream ---\n\n            session.publish(publisher);\n\n        } else {\n            console.warn('You don\\'t have permissions to publish');\n        }\n    } else {\n        console.warn('Error connecting to the session:', error.code, error.message);\n    }\n});   The user will now see its own video on the page. The connection to the session has completed!", 
            "title": "2) User connects to \"TUTORIAL\" video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#3-another-user-connects-to-the-video-call", 
            "text": "The process would be exactly the same as before until  server.js  executes controller at  /api-sessions/get-sessionid-token . Now session 'TUTORIAL' already exists, so in the  if-else  statement the  if  branch would be the one executed:  if (mapSessionNameSession[sessionName]) {\n    // Session already exists: return existing sessionId and a new token\n\n    // Get the existing Session from the collection\n    var mySession = mapSessionNameSession[sessionName];\n\n    // Generate a new token asynchronously with the recently created tokenOptions\n    mySession.generateToken(tokenOptions, function (token) {\n\n        // Get the existing sessionId\n        var sessionId = mySession.getSessionId();\n\n        // Store the new token in the collection of tokens\n        mapSessionIdTokens[sessionId].push(token);\n\n        // Return session template with all the needed attributes\n        res.render('session.ejs', {\n            sessionId: sessionId,\n            token: token,\n            nickName: clientData,\n            userName: req.session.loggedUser,\n            sessionName: sessionName\n        });\n    });\n}  The code executed in  session.html    script   tag would also be the same. After the  Session.publish()  method has been succesful, both users will be seeing each other's video, as well as the username and the nickname below it.", 
            "title": "3) Another user connects to the video-call"
        }, 
        {
            "location": "/tutorials/openvidu-mvc-node/#4-users-leave-the-video-call", 
            "text": "After a while both users decide to leave the session. Apart from calling  session.disconnect()  (triggered in  leaveSession()   onclick  method) to destroy the connection on openvidu-server, we need another POST operation to let the backend know that certain user has left the session so it can update the collections with the active sessions and tokens.  In  session.html  template the \"Leave session\" button actually performs a POST operation to path  /leave-session  with a hidden form. Notice that when the user clicks the submit button, a POST operation will be triggered but also the  leaveSession()  method. First updates our backend. Second updates our openvidu-server.  form action= /leave-session  method= post \n     input type= hidden  name= session-name  th:value= ${sessionName} /input \n     input type= hidden  name= token  th:value= ${token} /input \n     button type= submit  onclick= leaveSession() Leave session /button  /form   In  server.js  we update the collections at  /leave-session :  app.post('/leave-session', function (req, res) {\n    // Check the user is logged ...\n\n    // Retrieve params from POST body\n    var sessionName = req.body.sessionname;\n    var token = req.body.token;\n\n    // If the session exists ( TUTORIAL  in this case)\n    var mySession = mapSessionNameSession[sessionName];\n    if (mySession) {\n        var tokens = mapSessionIdTokens[mySession.getSessionId()];\n        if (tokens) {\n            var index = tokens.indexOf(token);\n\n            // If the token exists\n            if (index !== -1) {\n                // Token removed!\n                tokens.splice(index, 1);\n            } else {\n                res.status(500).send('The TOKEN wasn\\'t valid');\n            }\n            if (mapSessionIdTokens[mySession.getSessionId()].length == 0) {\n                // Last user left: session  TUTORIAL  must be removed\n                delete mapSessionNameSession[sessionName];\n            }\n            res.redirect('/dashboard');\n        } else {\n            res.status(500).send('The SESSIONID wasn\\'t valid');\n        }\n    } else {\n        res.status(500).send('The SESSION does not exist');\n    }\n}  When the last user leaves the session  delete mapSessionNameSession[sessionName]  will be executed: this means the session is empty and that it is going to be closed. The  sessionId  and all  token  params associated to it will be invalidated.    At this point we have covered all the important code from the tutorial. With this scenario we have seen the most common use-case, but you can modify whatever you want to suit your needs. And remember that this is just one of the many possible approaches:  you can implement your frontend and your backend as you want .   The only actual requirements are getting  sessionId  and  token  params from   openvidu-server  (by using one of the available clients or with the REST API) and using them along with  openvidu-browser  to connect your clients to the sessions.", 
            "title": "4) Users leave the video-call"
        }, 
        {
            "location": "/api/", 
            "text": "OpenVidu API\n\n\n\n\n\n\n\n\nNOTE: all input parameters (\"Parameters\" columns) are listed in strict order, optional ones in \nitalics\n\n\n\n\nopenvidu-browser\n\n\n\n\n\n\n\n\nClass\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu\n\n\nUse it to initialize your sessions and publishers\n\n\n\n\n\n\nSession\n\n\nRepresents a video call. It can also be seen as a room where multiple users can connect. Participants who publish their videos to a session will be seen by the rest of users connected to that specific session\n\n\n\n\n\n\nPublisher\n\n\nPacks local media streams. Users can publish it to a session\n\n\n\n\n\n\nSubscriber\n\n\nPacks remote media streams. Users automatically receive them when others publish their streams\n\n\n\n\n\n\nStream\n\n\nRepresents each one of the videos send and receive by a user in a session. Therefore each Publisher and Subscriber has an attribute of type Stream\n\n\n\n\n\n\nConnection\n\n\nRepresents each one of the user's connection to the session (the local one and other user's connections). Therefore each Session and Stream object has an attribute of type Connection\n\n\n\n\n\n\n\n\nOpenVidu\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninitSession\n\n\nSession\n\n\napikey:string\nsessionId:string\n\n\nReturns a session with id \nsessionId\n\n\n\n\n\n\ninitPublisher\n\n\nPublisher\n\n\nparentId:string\ncameraOptions:any\ncallback:function\n\n\nStarts local video stream, appending it to \nparentId\n HTML element, with the specific \ncameraOptions\n settings and executing \ncallback\n function in the end. \ncameraOptions\n must be an object with three properties: \n{audio:boolean, video:boolean, quality:string}\n, being \naudio\n/\nvideo\n false if you want to initialize them muted (\nPublisher.publishAudio(true)\n and \nPublisher.publishVideo(true)\n can unmute them later) and \nquality\n must be 'LOW', 'MEDIUM' or 'HIGH'\n\n\n\n\n\n\ncheckSystemRequirements\n\n\nNumber\n\n\n\n\nReturns 1 if the browser supports WebRTC, 0 otherwise\n\n\n\n\n\n\ngetDevices\n\n\nPromise\n\n\ncallback(error, deviceInfo):function\n\n\nCollects information about the media input and output devices available on the system, returned in \ndeviceInfo\n array\n\n\n\n\n\n\n\n\nSession\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconnect\n\n\n\n\ntoken:string\nmetadata:string\ncallback(error):function\n\n\nConnects to the session using \ntoken\n and executes \ncallback\n in the end (\nerror\n parameter null if success). \nmetadata\n parameter allows you to pass a string as extra data to share with other users when they receive \nparticipantJoined\n event. You can also add metadata through openvidu-backend-client when generating tokens (see \nTokenOptions\n). The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars\n\n\n\n\n\n\ndisconnect\n\n\n\n\n\n\nLeaves the session, destroying all streams and deleting the user as a participant\n\n\n\n\n\n\npublish\n\n\n\n\npublisher:Publisher\n\n\nPublishes the specific user's local stream contained in \npublisher\n object to the session\n\n\n\n\n\n\nunpublish\n\n\n\n\npublisher:Publisher\n\n\nUnpublishes the specific user's local stream contained in \npublisher\n object\n\n\n\n\n\n\non\n\n\n\n\neventName:string\ncallback:function\n\n\ncallback\n function will be triggered each time \neventName\n event is recieved\n\n\n\n\n\n\nonce\n\n\n\n\neventName:string\ncallback:function\n\n\ncallback\n function will be triggered once when \neventName\n event is recieved. The listener is removed immediately\n\n\n\n\n\n\noff\n\n\n\n\neventName:string\neventHandler:any\n\n\nRemoves \neventHandler\n handler for \neventName\n event\n\n\n\n\n\n\nsubscribe\n\n\nSubscriber\n\n\nstream:Stream\nhtmlId:string\nvideoOptions:any\n\n\nSubscribes to \nstream\n, appending a new HTML Video element to DOM element of \nhtmlId\n id, with \nvideoOptions\n settings. This method is usually called in the callback of \nstreamCreated\n event\n\n\n\n\n\n\nunsubscribe\n\n\n\n\nsubscriber:Subscriber\n\n\nUnsubscribes from \nsubscriber\n, automatically removing its HTML Video element\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsessionId\n\n\nstring\n\n\nThe unique id of the session\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstreamCreated\n\n\nstream:Stream\n\n\nTriggered by Session object when a new Stream has been created and added to it\n\n\n\n\n\n\nstreamDestroyed\n\n\nstream:Stream\npreventDefault():Function\n\n\nTriggered by Session object when an existing Stream has been destroyed. The default behaviour is the deletion of the HTML video element associated to it. To prevent it, call \npreventDefault()\n method on the event object\n\n\n\n\n\n\nconnectionCreated\n\n\nconnection:Connection\n\n\nTriggered by Session object whenever any user has joined the session. This includes dispatching one event for each user that joins the session when you are already connected to it, one for each existing participant the first time you connect to the session and once for your own local connection\n\n\n\n\n\n\nconnectionDestroyed\n\n\nconnection:Connection\n\n\nTriggered by Session object whenever a user leaves the session. This event can also mean that \nstreamDestroyed\n events could be dispatched, depending on the streams associated to it\n\n\n\n\n\n\nsessionDisconnected\n\n\npreventDefault():Function\n\n\nTriggered by Session object when the user disconnects from the Session. Default behaviour is the deletion of all HTML video elements. Call \npreventDefault()\n on event object to prevent it and delete them by yourself\n\n\n\n\n\n\n\n\nPublisher\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npublishAudio\n\n\n\n\nvalue:boolean\n\n\nEnable or disable the audio track depending on whether value is \ntrue\n or \nfalse\n\n\n\n\n\n\npublishVideo\n\n\n\n\nvalue:boolean\n\n\nEnable or disable the video track depending on whether value is \ntrue\n or \nfalse\n\n\n\n\n\n\ndestroy\n\n\nPublisher\n\n\n\n\nDelets the publisher object and removes it from DOM. The rest of users will trigger a \nstreamDestroyed\n event\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccessAllowed\n\n\nboolean\n\n\ntrue\n if the user has granted access to the camera, \nfalse\n otherwise\n\n\n\n\n\n\nelement\n\n\nElement\n\n\nThe parent HTML Element which contains the publisher\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe id of the HTML Video element of the publisher\n\n\n\n\n\n\nstream\n\n\nStream\n\n\nThe stream object of the publisher\n\n\n\n\n\n\nsession\n\n\nSession\n\n\nThe session to which the publisher belongs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccessAllowed\n\n\n\n\nTriggered by Publisher object when the user has granted access to the camera/microphone\n\n\n\n\n\n\naccessDenied\n\n\n\n\nTriggered by Publisher object when the user has rejected access to the camera/microphone\n\n\n\n\n\n\nvideoElementCreated\n\n\nelement:HTMLVideoElement\n\n\nTriggered by Publisher object inmediately after a new video element has been added to DOM\n\n\n\n\n\n\n\n\nSubscriber\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nelement\n\n\nElement\n\n\nThe parent HTML Element which contains the subscriber\n\n\n\n\n\n\nid\n\n\nstring\n\n\nThe id of the HTML Video element of the subscriber\n\n\n\n\n\n\nstream\n\n\nStream\n\n\nThe stream object of the subscriber\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEvent\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvideoElementCreated\n\n\nelement:HTMLVideoElement\n\n\nTriggered by Subscriber object inmediately after a new video element has been added to DOM\n\n\n\n\n\n\n\n\nConnection\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconnectionId\n\n\nstring\n\n\nUnique identifier of the connection\n\n\n\n\n\n\ndata\n\n\nstring\n\n\nData associated to this connection (and therefore to certain user). This is an important field: it allows you to broadcast all the information you want for each user (a username, for example)\n\n\n\n\n\n\ncreationTime\n\n\nnumber\n\n\nTime when this connection was created\n\n\n\n\n\n\n\n\nopenvidu-java-client\n\n\n\n\n\n\n\n\nClass\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu\n\n\nUse it to create all the sessions you need\n\n\n\n\n\n\nSession\n\n\nAllows for the creation of tokens\n\n\n\n\n\n\nOpenViduRole\n\n\nEnum that defines the values accepted by \nTokenOptions.Builder.role(OpenViduRole role)\n method\n\n\n\n\n\n\nTokenOptions\n\n\nCustomize each token with this class when generating them\n\n\n\n\n\n\n\n\nOpenVidu\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOpenVidu()\n\n\n\n\nString:urlOpenViduServer\nString:secret\n\n\nThe constructor receives the URL of your OpenVidu Server and the secret shared with it\n\n\n\n\n\n\ncreateSession()\n\n\nSession\n\n\n\n\nGet a Session object by calling this method. You can then store it as you want\n\n\n\n\n\n\n\n\nSession\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetSessionId()\n\n\nString\n\n\n\n\nReturns the unique identifier of the session. You will need to return this parameter to the client side to pass it during the connection process to the session\n\n\n\n\n\n\ngenerateToken()\n\n\nString\n\n\nTokenOptions:tokenOptions\n\n\nThe value returned is required in the client side just as the sessionId in order to connect to a session\n\n\n\n\n\n\n\n\nOpenViduRole\n\n\n\n\n\n\n\n\nEnum\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSUBSCRIBER\n\n\nThey can subscribe to published streams of other users\n\n\n\n\n\n\nPUBLISHER\n\n\nThey can subscribe to published streams of other users and publish their own streams\n\n\n\n\n\n\nMODERATOR\n\n\nThey can subscribe to published streams of other users, publish their own streams and force \nunpublish()\n and \ndisconnect()\n over a third-party stream or user\n\n\n\n\n\n\n\n\nTokenOptions\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetData()\n\n\nString\n\n\n\n\nReturns the metadata associated to the token\n\n\n\n\n\n\ngetRole()\n\n\nOpenViduRole\n\n\n\n\nReturns the role associated to the token\n\n\n\n\n\n\n\n\nTokenOptions.Builder\n \n(inner static class)\n\n\n\n\n\n\n\n\nMethod\n\n\nReturns\n\n\nParameters\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTokenOptions.Builder()\n\n\n\n\n\n\nConstructor\n\n\n\n\n\n\nbuild()\n\n\nTokenOptions\n\n\n\n\nReturns a new \nTokenOptions\n object with the stablished properties. Default values if methods \ndata()\n and \nrole()\n are not called are an empty string and OpenViduRole.PUBLISHER, respectively\n\n\n\n\n\n\ndata()\n\n\nTokenOptions.Builder\n\n\nString:data\n\n\nSome extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars\n\n\n\n\n\n\nrole()\n\n\nTokenOptions.Builder\n\n\nOpenViduRole:role\n\n\nThe role associated to this token", 
            "title": "API"
        }, 
        {
            "location": "/api/#openvidu-browser", 
            "text": "Class  Description      OpenVidu  Use it to initialize your sessions and publishers    Session  Represents a video call. It can also be seen as a room where multiple users can connect. Participants who publish their videos to a session will be seen by the rest of users connected to that specific session    Publisher  Packs local media streams. Users can publish it to a session    Subscriber  Packs remote media streams. Users automatically receive them when others publish their streams    Stream  Represents each one of the videos send and receive by a user in a session. Therefore each Publisher and Subscriber has an attribute of type Stream    Connection  Represents each one of the user's connection to the session (the local one and other user's connections). Therefore each Session and Stream object has an attribute of type Connection", 
            "title": "openvidu-browser"
        }, 
        {
            "location": "/api/#openvidu", 
            "text": "Method  Returns  Parameters  Description      initSession  Session  apikey:string sessionId:string  Returns a session with id  sessionId    initPublisher  Publisher  parentId:string cameraOptions:any callback:function  Starts local video stream, appending it to  parentId  HTML element, with the specific  cameraOptions  settings and executing  callback  function in the end.  cameraOptions  must be an object with three properties:  {audio:boolean, video:boolean, quality:string} , being  audio / video  false if you want to initialize them muted ( Publisher.publishAudio(true)  and  Publisher.publishVideo(true)  can unmute them later) and  quality  must be 'LOW', 'MEDIUM' or 'HIGH'    checkSystemRequirements  Number   Returns 1 if the browser supports WebRTC, 0 otherwise    getDevices  Promise  callback(error, deviceInfo):function  Collects information about the media input and output devices available on the system, returned in  deviceInfo  array", 
            "title": "OpenVidu"
        }, 
        {
            "location": "/api/#session", 
            "text": "Method  Returns  Parameters  Description      connect   token:string metadata:string callback(error):function  Connects to the session using  token  and executes  callback  in the end ( error  parameter null if success).  metadata  parameter allows you to pass a string as extra data to share with other users when they receive  participantJoined  event. You can also add metadata through openvidu-backend-client when generating tokens (see  TokenOptions ). The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars    disconnect    Leaves the session, destroying all streams and deleting the user as a participant    publish   publisher:Publisher  Publishes the specific user's local stream contained in  publisher  object to the session    unpublish   publisher:Publisher  Unpublishes the specific user's local stream contained in  publisher  object    on   eventName:string callback:function  callback  function will be triggered each time  eventName  event is recieved    once   eventName:string callback:function  callback  function will be triggered once when  eventName  event is recieved. The listener is removed immediately    off   eventName:string eventHandler:any  Removes  eventHandler  handler for  eventName  event    subscribe  Subscriber  stream:Stream htmlId:string videoOptions:any  Subscribes to  stream , appending a new HTML Video element to DOM element of  htmlId  id, with  videoOptions  settings. This method is usually called in the callback of  streamCreated  event    unsubscribe   subscriber:Subscriber  Unsubscribes from  subscriber , automatically removing its HTML Video element        Property  Type  Description      sessionId  string  The unique id of the session        Event  Properties  Description      streamCreated  stream:Stream  Triggered by Session object when a new Stream has been created and added to it    streamDestroyed  stream:Stream preventDefault():Function  Triggered by Session object when an existing Stream has been destroyed. The default behaviour is the deletion of the HTML video element associated to it. To prevent it, call  preventDefault()  method on the event object    connectionCreated  connection:Connection  Triggered by Session object whenever any user has joined the session. This includes dispatching one event for each user that joins the session when you are already connected to it, one for each existing participant the first time you connect to the session and once for your own local connection    connectionDestroyed  connection:Connection  Triggered by Session object whenever a user leaves the session. This event can also mean that  streamDestroyed  events could be dispatched, depending on the streams associated to it    sessionDisconnected  preventDefault():Function  Triggered by Session object when the user disconnects from the Session. Default behaviour is the deletion of all HTML video elements. Call  preventDefault()  on event object to prevent it and delete them by yourself", 
            "title": "Session"
        }, 
        {
            "location": "/api/#publisher", 
            "text": "Method  Returns  Parameters  Description      publishAudio   value:boolean  Enable or disable the audio track depending on whether value is  true  or  false    publishVideo   value:boolean  Enable or disable the video track depending on whether value is  true  or  false    destroy  Publisher   Delets the publisher object and removes it from DOM. The rest of users will trigger a  streamDestroyed  event        Property  Type  Description      accessAllowed  boolean  true  if the user has granted access to the camera,  false  otherwise    element  Element  The parent HTML Element which contains the publisher    id  string  The id of the HTML Video element of the publisher    stream  Stream  The stream object of the publisher    session  Session  The session to which the publisher belongs        Event  Properties  Description      accessAllowed   Triggered by Publisher object when the user has granted access to the camera/microphone    accessDenied   Triggered by Publisher object when the user has rejected access to the camera/microphone    videoElementCreated  element:HTMLVideoElement  Triggered by Publisher object inmediately after a new video element has been added to DOM", 
            "title": "Publisher"
        }, 
        {
            "location": "/api/#subscriber", 
            "text": "Method  Returns  Parameters  Description                Property  Type  Description      element  Element  The parent HTML Element which contains the subscriber    id  string  The id of the HTML Video element of the subscriber    stream  Stream  The stream object of the subscriber        Event  Properties  Description      videoElementCreated  element:HTMLVideoElement  Triggered by Subscriber object inmediately after a new video element has been added to DOM", 
            "title": "Subscriber"
        }, 
        {
            "location": "/api/#connection", 
            "text": "Property  Type  Description      connectionId  string  Unique identifier of the connection    data  string  Data associated to this connection (and therefore to certain user). This is an important field: it allows you to broadcast all the information you want for each user (a username, for example)    creationTime  number  Time when this connection was created", 
            "title": "Connection"
        }, 
        {
            "location": "/api/#openvidu-java-client", 
            "text": "Class  Description      OpenVidu  Use it to create all the sessions you need    Session  Allows for the creation of tokens    OpenViduRole  Enum that defines the values accepted by  TokenOptions.Builder.role(OpenViduRole role)  method    TokenOptions  Customize each token with this class when generating them", 
            "title": "openvidu-java-client"
        }, 
        {
            "location": "/api/#openvidu_1", 
            "text": "Method  Returns  Parameters  Description      OpenVidu()   String:urlOpenViduServer String:secret  The constructor receives the URL of your OpenVidu Server and the secret shared with it    createSession()  Session   Get a Session object by calling this method. You can then store it as you want", 
            "title": "OpenVidu"
        }, 
        {
            "location": "/api/#session_1", 
            "text": "Method  Returns  Parameters  Description      getSessionId()  String   Returns the unique identifier of the session. You will need to return this parameter to the client side to pass it during the connection process to the session    generateToken()  String  TokenOptions:tokenOptions  The value returned is required in the client side just as the sessionId in order to connect to a session", 
            "title": "Session"
        }, 
        {
            "location": "/api/#openvidurole", 
            "text": "Enum  Description      SUBSCRIBER  They can subscribe to published streams of other users    PUBLISHER  They can subscribe to published streams of other users and publish their own streams    MODERATOR  They can subscribe to published streams of other users, publish their own streams and force  unpublish()  and  disconnect()  over a third-party stream or user", 
            "title": "OpenViduRole"
        }, 
        {
            "location": "/api/#tokenoptions", 
            "text": "Method  Returns  Parameters  Description      getData()  String   Returns the metadata associated to the token    getRole()  OpenViduRole   Returns the role associated to the token", 
            "title": "TokenOptions"
        }, 
        {
            "location": "/api/#tokenoptionsbuilder-inner-static-class", 
            "text": "Method  Returns  Parameters  Description      TokenOptions.Builder()    Constructor    build()  TokenOptions   Returns a new  TokenOptions  object with the stablished properties. Default values if methods  data()  and  role()  are not called are an empty string and OpenViduRole.PUBLISHER, respectively    data()  TokenOptions.Builder  String:data  Some extra metadata to be associated to the user through its token. The structure of this string is up to you (maybe some standarized format as JSON or XML is a good idea), the only restriction is a maximum length of 1000 chars    role()  TokenOptions.Builder  OpenViduRole:role  The role associated to this token", 
            "title": "TokenOptions.Builder (inner static class)"
        }, 
        {
            "location": "/deployment/", 
            "text": "OpenVidu Deployment\n\n\n\n\n\n\nDeploying on AWS\n\n\nHere you have a step by step guide to deploy a production version of OpenVidu in an Ubuntu machine. In this case, KMS and openvidu-server run in the same machine, the first one as a native service and the second one in a Docker container.\n\n\n1. Install KMS (in first command: \nxenial\n for 16.04, \ntrusty\n for 14.04)\n\n\necho \ndeb http://ubuntu.kurento.org xenial kms6\n | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install kurento-media-server-6.0\n\n\n\n\n2. Install COTURN\n\n\nsudo apt-get install coturn\n\n\n\n\n3. File \n/etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini\n\n\nstunServerAddress=STUN_IP\nstunServerPort=STUN_PORT\nturnURL=USER:PASS@YOUR_MACHINES'S_PUBLIC_IP:3478\n\n\n\n\n4. File \n/etc/turnserver.conf\n\n\nexternal-ip=YOUR_MACHINES'S_PUBLIC_IP\nfingerprint\nuser=USER:PASS\nlt-cred-mech\nrealm=kurento.org\nlog-file=/var/log/turnserver/turnserver.log\nsimple-log\n\n\n\n\n5. File \n/etc/default/coturn\n\n\nTURNSERVER_ENABLED=1\n\n\n\n\n6. Init services\n\n\nsudo service coturn restart\nsudo service kurento-media-server-6.0 restart\n\n\n\n\n7. Init openvidu-server Docker container (securization enabled)\n\n\nsudo docker run -d -p 8443:8443 -e openvidu.security=true -e openvidu.secret=YOUR_SECRET -e kms.uris=[\\\nws://YOUR_MACHINE'S_INTERNAL_IP:8888/kurento\\\n] openvidu/openvidu-server", 
            "title": "Deployment"
        }, 
        {
            "location": "/deployment/#deploying-on-aws", 
            "text": "Here you have a step by step guide to deploy a production version of OpenVidu in an Ubuntu machine. In this case, KMS and openvidu-server run in the same machine, the first one as a native service and the second one in a Docker container.", 
            "title": "Deploying on AWS"
        }, 
        {
            "location": "/deployment/#1-install-kms-in-first-command-xenial-for-1604-trusty-for-1404", 
            "text": "echo  deb http://ubuntu.kurento.org xenial kms6  | sudo tee /etc/apt/sources.list.d/kurento.list\nwget -O - http://ubuntu.kurento.org/kurento.gpg.key | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install kurento-media-server-6.0", 
            "title": "1. Install KMS (in first command: xenial for 16.04, trusty for 14.04)"
        }, 
        {
            "location": "/deployment/#2-install-coturn", 
            "text": "sudo apt-get install coturn", 
            "title": "2. Install COTURN"
        }, 
        {
            "location": "/deployment/#3-file-etckurentomoduleskurentowebrtcendpointconfini", 
            "text": "stunServerAddress=STUN_IP\nstunServerPort=STUN_PORT\nturnURL=USER:PASS@YOUR_MACHINES'S_PUBLIC_IP:3478", 
            "title": "3. File /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini"
        }, 
        {
            "location": "/deployment/#4-file-etcturnserverconf", 
            "text": "external-ip=YOUR_MACHINES'S_PUBLIC_IP\nfingerprint\nuser=USER:PASS\nlt-cred-mech\nrealm=kurento.org\nlog-file=/var/log/turnserver/turnserver.log\nsimple-log", 
            "title": "4. File /etc/turnserver.conf"
        }, 
        {
            "location": "/deployment/#5-file-etcdefaultcoturn", 
            "text": "TURNSERVER_ENABLED=1", 
            "title": "5. File /etc/default/coturn"
        }, 
        {
            "location": "/deployment/#6-init-services", 
            "text": "sudo service coturn restart\nsudo service kurento-media-server-6.0 restart", 
            "title": "6. Init services"
        }, 
        {
            "location": "/deployment/#7-init-openvidu-server-docker-container-securization-enabled", 
            "text": "sudo docker run -d -p 8443:8443 -e openvidu.security=true -e openvidu.secret=YOUR_SECRET -e kms.uris=[\\ ws://YOUR_MACHINE'S_INTERNAL_IP:8888/kurento\\ ] openvidu/openvidu-server", 
            "title": "7. Init openvidu-server Docker container (securization enabled)"
        }
    ]
}